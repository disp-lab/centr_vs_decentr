<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File 
*************************************************	         
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="7.3.4.201605201443" AlpVersion="7.3.3">
<Model>
	<Id>1428929294897</Id>
	<Name><![CDATA[MTSP]]></Name>
	<Description><![CDATA[Video comparing 4 methods to solve TSP: https://youtu.be/q6fPk0--eHY]]></Description>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[tsp]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Hour]]></ModelTimeUnit>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1428929294899</Id>
			<Name><![CDATA[Main]]></Name>
			<Description><![CDATA[ System.nanoTime()]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<Import><![CDATA[import ilog.concert.*;									// import CPLEX
import ilog.cplex.*;									// import CPLEX

import org.ojalgo.OjAlgoUtils;							//import ojalgo
import org.ojalgo.netio.BasicLogger;					//import ojalgo
import org.ojalgo.optimisation.Expression;				//import ojalgo
import org.ojalgo.optimisation.ExpressionsBasedModel;	//import ojalgo
import org.ojalgo.optimisation.Optimisation;			//import ojalgo
import org.ojalgo.optimisation.Variable;				//import ojalgo
import java.math.BigDecimal;							//import ojalgo
import org.ojalgo.optimisation.linear.LinearSolver;

import java.text.*;
import jdk.management.resource.internal.TotalResourceContext;]]></Import>
			<StartupCode><![CDATA[//display what instance is solved (=what Y-coord is used for every X-coord of the cities)
/*Experiment exp = getExperiment();
int deltaY = 0;
if( exp instanceof ExperimentParamVariation )
	deltaY = ((ExperimentParamVariation)exp).getCurrentReplication();
else if( exp instanceof ExperimentSimulation )
	deltaY = ((ExperimentSimulation)exp).getRunCount();
*/

//affect the color to be used by each of the salesmen
salesmen.get(selectedSalesman).ovalShape.setVisible(true);
for(Salesman salesman : salesmen){
	switch(salesman.getIndex()){
		case 0:		salesman.color = black;			break;		case 1:		salesman.color = crimson;			break;
		case 2:		salesman.color = blue;			break;		case 3:		salesman.color = mediumPurple;		break;
		case 4:		salesman.color = yellowGreen;	break;		case 5:		salesman.color = mediumOrchid;		break;
		case 6:		salesman.color = peru;			break;		case 7:		salesman.color = navy;				break;
		case 8:		salesman.color = teal;			break;		case 9:		salesman.color = maroon;			break;
		case 10:	salesman.color = tomato;		break;		case 11:	salesman.color = sandyBrown;		break;
		case 12:	salesman.color = darkSalmon;	break;		case 13:	salesman.color = coral;				break;
		case 14:	salesman.color = orangeRed;		break;		case 15:	salesman.color = lightSalmon;		break;
		case 16:	salesman.color = feldspar;		break;		case 17:	salesman.color = sienna;			break;
		case 18:	salesman.color = seaShell;		break;		case 19:	salesman.color = saddleBrown;		break;
		case 20:	salesman.color = chocolate;		break;		case 21:	salesman.color = navajoWhite;		break;
		case 22:	salesman.color = cornsilk;		break;		case 23:	salesman.color = beige;				break;
		case 24:	salesman.color = darkGreen;		break;		case 25:	salesman.color = mintCream;			break;
		case 26:	salesman.color = darkSlateGray;	break;		case 27:	salesman.color = lightSkyBlue;		break;
		case 28:	salesman.color = darkBlue;		break;		case 29:	salesman.color = blueViolet;		break;
		case 30:	salesman.color = thistle;		break;		case 31:	salesman.color = lightPink;			break;
		case 32:	salesman.color = pink;			break;		case 33:	salesman.color = plum;				break;
		case 34:	salesman.color = orange;		break;		case 35:	salesman.color = mediumSlateBlue;	break;
		case 36:	salesman.color = mediumBlue;	break;		case 37:	salesman.color = skyBlue;			break;
		case 38:	salesman.color = springGreen;	break;		case 39:	salesman.color = green;				break;
		case 40:	salesman.color = lightYellow;	break;		case 41:	salesman.color = goldenRod;			break;
		case 42:	salesman.color = antiqueWhite;	break;		case 43:	salesman.color = tan;				break;
		case 44:	salesman.color = floralWhite;	break;		case 45:	salesman.color = olive;				break;
		case 46:	salesman.color = lime;			break;		case 47:	salesman.color = cyan;				break;
		case 48:	salesman.color = azure;			break;		case 49:	salesman.color = dodgerBlue;		break;
		case 50:	salesman.color = khaki;			break;		case 51:	salesman.color = indigo;			break;
	}
}

//cities are given to salesmen
int salesmn=0;
for(City city : cities){
	if(city.getIndex() > 0){ //the common depot is not affected by default, but only if stated otherwise (see below)
		salesmen.get( salesmn ).ownedCities.add(city);
		salesmen.get( salesmn ).allocatedCities.add(city);
		city.cityText.setColor( salesmen.get(salesmn).color );
	
		salesmn++;
		if( salesmn >= salesmen.size() ) salesmn=0;
		city.visitingSalesman = salesmen.get( salesmn );
	}
}

//Take account of the two check boxes in the screen of simulation settings
for(Salesman salesman : salesmen){
	if( salesmenShareDepot0 ){
			salesman.ownedCities.add( 0, cities.get(0) );
			salesman.allocatedCities.add( 0, cities.get(0) );
		}
	if( salesmenStartFromTheirDepot ) //otherwise, let them where they have been randomly placed
		salesman.setXY( salesman.ownedCities.get(0).getX(), salesman.ownedCities.get(0).getY() );
}

//Start simulation
solve();

for(Salesman salesman : salesmen){
	//remove the depot (or current position of the salesman) from the route
	//salesman.route.remove(0);
	salesman.drawRoute();
	salesman.nextCity2visit = (Agent)salesman.route.get( 0 );
	//next, go to the 1st city in the route
	//salesman.moveTo( salesman.nextCity2visit );
}]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1456145103467</Id>
				<Name><![CDATA[1456145103467]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameters:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[0]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[KPH]]></Unit>
				</VelocityCode>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[rectangleWidth]]></WidthCode>
					<HeightCode><![CDATA[rectangleHeight]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>RANDOM</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>RANDOM</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1456214400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1456145103504</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-370</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>KILOMETER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1428929294898</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1429113658034</Id>
					<Name><![CDATA[mouseMode]]></Name>
					<X>390</X><Y>-180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1432939361497</Id>
					<Name><![CDATA[selectedSalesman]]></Name>
					<X>390</X><Y>-160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1460550386440</Id>
					<Name><![CDATA[mechanismStartTime]]></Name>
					<X>390</X><Y>-140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[long]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[-1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1460560869734</Id>
					<Name><![CDATA[consoleOutput_backup]]></Name>
					<X>390</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[consoleOutput]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1469095338391</Id>
					<Name><![CDATA[computationTimeOfFunctionSolveOfCentralPlanner]]></Name>
					<X>670</X><Y>-170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1491837403556</Id>
					<Name><![CDATA[remainingComputationTime]]></Name>
					<X>670</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[maximumComputationTimeSpan]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1459241670424</Id>
					<Name><![CDATA[instance]]></Name>
					<X>390</X><Y>-230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1459241670422</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438344938353</Id>
					<Name><![CDATA[selectedTspSolver]]></Name>
					<X>390</X><Y>-40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438344938350</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1432939710079</Id>
					<Name><![CDATA[cityNumber]]></Name>
					<X>20</X><Y>-210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1432939710077</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1432939692046</Id>
					<Name><![CDATA[salesmanNumber]]></Name>
					<X>20</X><Y>-230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1432939692041</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1458831747464</Id>
					<Name><![CDATA[staticSolver]]></Name>
					<X>390</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1458831747462</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438179992551</Id>
					<Name><![CDATA[salesmenShareDepot0]]></Name>
					<X>20</X><Y>-150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438179992549</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438097066524</Id>
					<Name><![CDATA[salesmenStartFromTheirDepot]]></Name>
					<X>20</X><Y>-170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438097066522</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438345000788</Id>
					<Name><![CDATA[rectangleWidth]]></Name>
					<X>20</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[700]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438345000786</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438345018681</Id>
					<Name><![CDATA[rectangleHeight]]></Name>
					<X>20</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[700]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438345018679</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1438353862912</Id>
					<Name><![CDATA[solveNdrawAutomatically]]></Name>
					<X>20</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1438353862910</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1442407514543</Id>
					<Name><![CDATA[maxReallocations]]></Name>
					<X>20</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1442407514531</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1460119249255</Id>
					<Name><![CDATA[selectedAllocationMechanism]]></Name>
					<X>390</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1460119249253</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1469114079695</Id>
					<Name><![CDATA[debugOutput]]></Name>
					<X>390</X><Y>-260</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1469114079693</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1484585434335</Id>
					<Name><![CDATA[centralPlannerNumber]]></Name>
					<X>20</X><Y>-190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1484585434333</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1491564485473</Id>
					<Name><![CDATA[maximumComputationTimeSpan]]></Name>
					<X>670</X><Y>-40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[double]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1491564485471</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1491911458286</Id>
					<Name><![CDATA[swap]]></Name>
					<X>390</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1491911458284</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1516371552155</Id>
					<Name><![CDATA[problemID]]></Name>
					<X>20</X><Y>-130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[int]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1516371552153</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1459959603899</Id>
					<Name><![CDATA[consoleOutput]]></Name>
					<X>390</X><Y>-120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<ParameterEditor>
							<Id>1459959603897</Id>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1479394223909</Id>
					<Name><![CDATA[durations_of_calls_to_the_solver]]></Name>
					<Description><![CDATA[When used by CNP:
Each line contains a double[m+3] where position:
- k=0..(m-1) indicates the computation time of the corresponding salesman k in CNP5_guest_sends_proposal
- m        indicates the computation time of the host in CNP3_host_broadcasts_RFPs
- (m+1) indicates the computation time of the host in CNP9_host_sends_allocation_replies
- (m+2) is the id of the host


When used by P2P :
* The first m lines contain a double[6] in which the double in position zero indicates the concerned salesman and the double in position two is the computation time during the initialisation
* Each of the subsequent line contain a double[6] in which position:
  - 0 indicates the id of the host
  - 1 indicates the id of the guest
  - 2 indicates the computation time of the guest in state P2P4_guest_proposes_a_city
  - 3 indicates the computation time of the host in state P2P6_host_proposes_city_to_guest
  - 4 indicates the sum of the two computation times of the guest in transition P2P7_guest_receives_proposition_and_sends_reply	
  - 5 indicates the computation time of the host in transition P2P8_host_receives_acceptation_or_rejection

When used by Auction:
Each line contains a double[2m+1] where position:
- k=0..(m-1) indicates the computation time of the corresponding salesman k in A4_propose_a_city_to_give
- k=m..(2m-1) indicates the computation time of the corresponding salesman k in A10_bid_on_every_proposed_city
- 2m indicates the computation time of the central planner in A14_send_allocation_of_cities]]></Description>
					<X>670</X><Y>-150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[double[]]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
			</Variables>
			<Events>
				<Event>
					<Id>1469033158950</Id>
					<Name><![CDATA[print_or_save_results_after_mechanism_has_terminated]]></Name>
					<X>670</X><Y>-190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties TriggerType="timeout" Mode="occuresOnce">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<OccurrenceAtTime>true</OccurrenceAtTime>
						<OccurrenceDate>1469088000000</OccurrenceDate>
						<OccurrenceTime Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</OccurrenceTime>
						<RecurrenceCode Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</RecurrenceCode>
						<Condition><![CDATA[!consoleOutput]]></Condition>
					</Properties>
					<Action><![CDATA[DecimalFormat df = new DecimalFormat ( ) ;	//'df' removes the decimal part of numbers
df.setMaximumFractionDigits ( 0 ) ;
df.setDecimalSeparatorAlwaysShown ( false ) ;
df.setGroupingSize(99);
rectangleP.setFillColor(white);

if(consoleOutput){	//CASE 1: simulation experiment (=write results in the console)
	trace("\t"+salesmen.size()+"\t"+cities.size()+"\t");
	if(selectedAllocationMechanism<=2){
		trace(df.format(computationTimeOfFunctionSolveOfCentralPlanner)+"=\t" + df.format(computationTimeOfFunctionSolveOfCentralPlanner) + "\t");
	}
	else{
		if(selectedAllocationMechanism==7)
			duration_of_CNPswap();	//Salesman.my_computation_time to include the calculation in the last m rounds
	
		double totalComputationTime = centralPlanner.get(0).my_computation_time + computationTimeOfFunctionSolveOfCentralPlanner;
		trace(df.format(totalComputationTime));
		double largestComputationTime = 0;
		for(Salesman salesman : salesmen){
			totalComputationTime += salesman.my_computation_time;
			if( largestComputationTime < salesman.my_computation_time)
				largestComputationTime = salesman.my_computation_time;
			trace("+"+df.format(salesman.my_computation_time));
		}
		if(selectedAllocationMechanism==3 || selectedAllocationMechanism==4)
			trace("=@\t"+df.format( computationTimeOfFunctionSolveOfCentralPlanner+largestComputationTime)+"\t");
		else if(selectedAllocationMechanism==5)
			trace("=\t"+df.format(duration_of_AuctionSwap())+"\t");
		else if(selectedAllocationMechanism==6)
			trace("=\t"+df.format(duration_of_P2Pswap())+"\t");
		else if(selectedAllocationMechanism==7)
			trace("=\t"+df.format(duration_of_CNPswap())+"\t");
		else
			trace("=\t"+df.format(totalComputationTime)+"\t");
	}
	
	double totalRouteLength = 0;
	for(Salesman salesman : salesmen){
		double routeLength = salesman.routeLength();
		totalRouteLength += routeLength;
		trace((int)routeLength+"+");
	}//for(Salesman)
	trace("=\t"+(int)totalRouteLength+"\t");
	
	trace(maxReallocations+"\t");
	
	int total_number_of_messages_received = 0;
	if(selectedAllocationMechanism == 5){
		trace(centralPlanner.get(0).number_of_messages_received+"+");
		total_number_of_messages_received += centralPlanner.get(0).number_of_messages_received;
	}
	for(Salesman salesman : salesmen){
		trace(salesman.number_of_messages_received+"+");
		total_number_of_messages_received += salesman.number_of_messages_received;
	}
	trace("=\t"+total_number_of_messages_received+"\t"+centralPlanner.get(0).number_of_rounds);
	
	traceln();
}	//if(consoleOutput)
else{	//CASE 2: parameter variation experiment (=write results in the csv file)
	//traceln("Algo\tinstnce\t#SMen\t#cities\tcmpT\tTOTcmpT\troutLen\tTOTroutLen\tmaxRealloc\tmsgExch");
	csv_file.print("\t"+instance + "\t"+salesmen.size()+"\t"+cities.size());
	
	// save computation times
	if(selectedAllocationMechanism<=2){
		csv_file.print("\t=\t" + df.format(computationTimeOfFunctionSolveOfCentralPlanner)+"\t");
	}
	else if(selectedAllocationMechanism==3 || selectedAllocationMechanism==4){	//totalComputationTime equals the duration of clustering by the central planner
			csv_file.print("\t"+df.format(computationTimeOfFunctionSolveOfCentralPlanner));
			double largestComputationTime = 0;
			for(Salesman salesman : salesmen){
				if( largestComputationTime < salesman.my_computation_time)
					largestComputationTime = salesman.my_computation_time;
				csv_file.print("+"+df.format(salesman.my_computation_time));
			}
		csv_file.print("=\t"+df.format(largestComputationTime+computationTimeOfFunctionSolveOfCentralPlanner)+"\t");
	}
	else if(selectedAllocationMechanism==5){
		duration_of_AuctionSwap();	//Add the computation time in the last round to every salesman's 'Salesman.my_computation_time'
		csv_file.print("\t"+df.format(centralPlanner.get(0).my_computation_time));
		for(Salesman salesman : salesmen)
			csv_file.print("+"+df.format(salesman.my_computation_time));
		csv_file.print("=\t"+df.format(duration_of_AuctionSwap())+"\t");	
	}
	else if(selectedAllocationMechanism==6 || selectedAllocationMechanism==7 || selectedAllocationMechanism==8){
		csv_file.print("\t0");	//no central planner => its computation time equals zero
		if(selectedAllocationMechanism==7)
			duration_of_CNPswap();	//Salesman.my_computation_time to include the calculation in the last m rounds
		
		double maxComputationTime = 0;
		for(Salesman salesman : salesmen){
			if( maxComputationTime < salesman.my_computation_time )
				maxComputationTime = salesman.my_computation_time;
			csv_file.print("+"+df.format(salesman.my_computation_time));
		}
		if(selectedAllocationMechanism==6)
			csv_file.print("=\t"+df.format(duration_of_P2Pswap())+"\t");
		else if(selectedAllocationMechanism==7)
			csv_file.print("=\t"+df.format(duration_of_CNPswap())+"\t");
		else if(selectedAllocationMechanism==8)
			csv_file.print("=\t"+df.format(maxComputationTime)+"\t");
		else{
			double a=1/0;	//we should never come here
		}
	}
	
	//save total route lengths
	double totalRouteLength = 0;
	for(Salesman salesman : salesmen){
		double routeLength = salesman.routeLength();
		totalRouteLength += routeLength;

		csv_file.print((int)routeLength+"+");
			
		salesman.nextCity2visit = salesman.route.get(0);
		//salesman.moveTo(salesman.nextCity2visit.getX(), salesman.nextCity2visit.getY());
	}	
	csv_file.print("=\t"+(int)totalRouteLength);

	csv_file.print("\t"+maxReallocations+"\t");	//current value of maxReallocations

	int total_number_of_messages_received = 0;
	for(Salesman salesman : salesmen){
		total_number_of_messages_received += salesman.number_of_messages_received;
		csv_file.print(salesman.number_of_messages_received+"+");
	}
	csv_file.print("=\t"+total_number_of_messages_received);
	
	if(selectedAllocationMechanism==5)
		csv_file.print("\t"+centralPlanner.get(0).number_of_rounds);
	else if(selectedAllocationMechanism==7)
		csv_file.print("\t0");
	csv_file.println();
}//else
csv_file.close();

//button_durations_of_calls_to_solve.action();]]></Action>
				</Event>
			</Events>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1435673563555</Id>
					<Name><![CDATA[solve]]></Name>
					<X>670</X><Y>-210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[boolean consoleOutput_bkp = consoleOutput;
double longest_call_to_the_solver = 0;
switch(selectedAllocationMechanism){
	case 0:	if(consoleOutput)	trace(instance + "\t");	// *** 2-index CDM ***
			switch(selectedTspSolver){			
				case 0: if(staticSolver)	traceln("not implemented yet");								//Insertion
						else				centralPlanner.get(0).solve_DMTSPinsert();
						break;
				case 1: if(staticSolver)	centralPlanner.get(0).solve_FullCentr();	//solve_MTSPcplex_2indices();	//Cplex
						else				centralPlanner.get(0).solve_DMTSPcplex();
						break;
				case 2: if(staticSolver)	centralPlanner.get(0).solve_MTSPojalgo_2indices();								//Ojalgo
						else				centralPlanner.get(0).solve_DMTSPojalgo();
						break;
			} break;
	case 1: if(consoleOutput)	trace(instance + "\t");	// *** 3-index CDM ***
			if(swap)
				centralPlanner.get(0).solve_OptDecentr();
			else{
				switch(selectedTspSolver){
				case 0: if(staticSolver)	traceln("not implemented yet");						//Insertion
						else				traceln("not implemented yet");
						break;
				case 1: if(staticSolver)	centralPlanner.get(0).solve_MTSPWRcplex();								//Cplex
						else				centralPlanner.get(0).solve_DMTSPWRcplex();
						break;
				case 2: if(staticSolver)	traceln("not implemented yet");						//Ojalgo
						else				traceln("not implemented yet");
						break;		
				}//switch
			}//else
			break;
	case 2: if(consoleOutput_backup) trace(instance+"\tnoReal"); else csv_file.print("noRealloc"+maximumComputationTimeSpan/3600000);			//No reallocations
			consoleOutput = false;
			durations_of_calls_to_the_solver.add(new double[salesmen.size()]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
				
			}
			remainingComputationTime -= longest_call_to_the_solver;
			consoleOutput = consoleOutput_backup;
			break;		
	case 3:	if(consoleOutput)	trace(instance + "\t");	// *** CLUSTER RAO ***
			if(swap)
				centralPlanner.get(0).solve_cluster_Rao_swap();
			else
				centralPlanner.get(0).solve_cluster_Rao();
			durations_of_calls_to_the_solver.add(new double[salesmen.size()]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				//if(consoleOutput)	trace(city_deltaY + "\t");
				consoleOutput = false;
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
			}
			remainingComputationTime -= longest_call_to_the_solver;
			break;
	case 4:	if(consoleOutput)	trace(instance + "\t");	// *** CLUSTER SAGLAM ***
			if(swap)
				centralPlanner.get(0).solve_cluster_Saglam_swap();
			else
				centralPlanner.get(0).solve_cluster_Saglam();
			durations_of_calls_to_the_solver.add(new double[salesmen.size()]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				//if(consoleOutput)	trace(city_deltaY + "\t");
				consoleOutput = false;
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
			}
			remainingComputationTime -= longest_call_to_the_solver;
			break;
	case 5:	if(consoleOutput) trace(instance+"\tAuctinS"); else csv_file.print("AuctionSwap"+maximumComputationTimeSpan/3600000);
			consoleOutput = false;						// *** AUCTION ***
			durations_of_calls_to_the_solver.add(new double[2*salesmen.size()+1]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				if(consoleOutput)	trace(instance + "\t");
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
			}
			remainingComputationTime -= longest_call_to_the_solver;
			break;
	case 6:	if(consoleOutput)	trace(instance + "\t");	// *** P2P ***
			consoleOutput = false;
			durations_of_calls_to_the_solver.add(new double[6]);
			for(Salesman salesman : salesmen){
				salesman.solve();
				salesman.P2P_end_date_of_computation = salesman.duration_of_last_call_to_the_solver;
			if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
				longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
			}
			durations_of_calls_to_the_solver.get(0)[2] = longest_call_to_the_solver;
			remainingComputationTime -= longest_call_to_the_solver;
			if(swap)
				if(consoleOutput_backup) trace("P2Pswap"); else csv_file.print("P2Pswap"+maximumComputationTimeSpan/3600000);
			else
				if(consoleOutput_backup) trace("P2PWR"); else csv_file.print("P2PWR"+maximumComputationTimeSpan/3600000);
			break;
	case 7:	if(consoleOutput)	trace(instance + "\t");	// *** CONTRACT NET PROTOCOL ***
			consoleOutput = false;
			durations_of_calls_to_the_solver.add(new double[salesmen.size()+3]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
			}
			remainingComputationTime -= longest_call_to_the_solver;
			if(consoleOutput_backup) trace("CNPswap"); else csv_file.print("CNPswap"+maximumComputationTimeSpan/3600000);
			break;
	case 8:	if(consoleOutput_backup) trace(instance+"\tnoReal"); else csv_file.print("noRealloc"+maximumComputationTimeSpan/3600000);			//No reallocations
			consoleOutput = false;
			durations_of_calls_to_the_solver.add(new double[salesmen.size()]);
			longest_call_to_the_solver = 0;
			for(Salesman salesman : salesmen){
				salesman.solve();
				durations_of_calls_to_the_solver.get(0)[salesman.getIndex()] = salesman.duration_of_last_call_to_the_solver;
				if( longest_call_to_the_solver < salesman.duration_of_last_call_to_the_solver)
					longest_call_to_the_solver = salesman.duration_of_last_call_to_the_solver;
				
			}
			remainingComputationTime -= longest_call_to_the_solver;
			consoleOutput = consoleOutput_backup;
			break;
}
consoleOutput = consoleOutput_bkp;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1473769156344</Id>
					<Name><![CDATA[routeLength]]></Name>
					<X>390</X><Y>-210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double routeLength = 0;
for(Salesman salesman : salesmen)
	routeLength += salesman.routeLength();
return routeLength;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1479404281873</Id>
					<Name><![CDATA[duration_of_P2Pswap]]></Name>
					<X>670</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/*
interaction[0] = ID of host
interaction[1] = ID of guest
interaction[2] = duration of CPLEX call in the initialisation + P2P4_guest_proposes_a_city
interaction[3] = duration of CPLEX call in P2P6_host_proposes_city_to_guest
interaction[4] = duration of CPLEX call in P2P7_guest_receives_proposition_and_sends_reply
interaction[4] = duration of CPLEX call in P2P8_host_receives_acceptation_or_rejection
*/
/*
for(double[] interaction : durations_of_calls_to_the_solver)
	traceln("\t"+interaction[0]+"\t"+interaction[1]+"\t"+interaction[2]+"\t"+interaction[3]+"\t"+interaction[4]+"\t"+interaction[5]);
traceln();
*/
double total_computation_time = durations_of_calls_to_the_solver.get(0)[2];
// calculate the duration of the initialisation (=first call to anySalesman.solve_TSPcplex() in order to find the route before any round of P2P)
for(int salesman = 1 ; salesman < salesmen.size() ; salesman++)
	total_computation_time = max( total_computation_time, durations_of_calls_to_the_solver.get( salesman )[2] );

double[] end_date_of_computation_of_salesman = new double[ salesmen.size() ];
for(int salesman = 0 ; salesman < salesmen.size() ; salesman++)
	end_date_of_computation_of_salesman[ salesman ] = total_computation_time;

for(int interaction =  salesmen.size(); interaction<durations_of_calls_to_the_solver.size() ; interaction++){
	double[] curInteraction = durations_of_calls_to_the_solver.get(interaction);
	
	// host and guest both wait for each other to terminate a previous interaction
	end_date_of_computation_of_salesman[ (int)curInteraction[0] ] = max( end_date_of_computation_of_salesman[ (int)curInteraction[0] ], end_date_of_computation_of_salesman[ (int)curInteraction[1] ] );
	end_date_of_computation_of_salesman[ (int)curInteraction[1] ] = max( end_date_of_computation_of_salesman[ (int)curInteraction[0] ], end_date_of_computation_of_salesman[ (int)curInteraction[1] ] );
	
/*	for(int salesman = 0 ; salesman < salesmen.size() ; salesman++)
		traceln(interaction+" start_of_computation_time_of_salesman["+salesman+"] = " + end_of_computation_time_of_salesman[ salesman ]);*/
	// update host
	end_date_of_computation_of_salesman[ (int)curInteraction[0] ] += curInteraction[2] + curInteraction[3] + curInteraction[4] + curInteraction[5];
	// update guest
	end_date_of_computation_of_salesman[ (int)curInteraction[1] ] += curInteraction[2] + curInteraction[3] + curInteraction[4];
/*	for(int salesman = 0 ; salesman < salesmen.size() ; salesman++)
		traceln(interaction+" end_of_computation_time_of_salesman["+salesman+"] = " + end_of_computation_time_of_salesman[ salesman ]);
	traceln();*/
}

// find the end date of the last interaction
for(int salesman = 0 ; salesman < salesmen.size() ; salesman++)
	total_computation_time = max( total_computation_time, end_date_of_computation_of_salesman[ salesman ] );
return total_computation_time;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1497623224454</Id>
					<Name><![CDATA[duration_of_CNPswap]]></Name>
					<X>670</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/*
interaction[ 0 <= k < m] = duration of CPLEX call of the guest k in CNP5_guest_sends_proposal
interaction[m] = duration of CPLEX call of the host in CNP3_host_broadcasts_RFPs
interaction[m+1] = total duration of CPLEX callS of the host in CNP9_host_sends_allocation_replies
interaction[m+2] = id of the host
*/
boolean debug = false;
if(debug){
	trace("\nInitial my_computation_times: ");
	for(Salesman s : salesmen)
		trace(s.my_computation_time+" ");
	traceln();
}

double   total_computation_time = 0;
double[] computation_time_of_salesman = new double[salesmen.size()];

//add the initialisation time before CNP interactions start
double max_duration_of_initilisation = 0;
double[] interaction = durations_of_calls_to_the_solver.get(0);
for(int salesman=0 ; salesman<salesmen.size() ; salesman++){
	if(debug)	trace(interaction[salesman]+"\t");
	if( max_duration_of_initilisation < interaction[salesman] )
		max_duration_of_initilisation = interaction[salesman];
	computation_time_of_salesman[salesman] = interaction[salesman];
}
total_computation_time += max_duration_of_initilisation;
if(debug)	traceln();

//add the duration of every interaction
for(int interactionID=1 ; interactionID<durations_of_calls_to_the_solver.size() ; interactionID++){
	interaction = durations_of_calls_to_the_solver.get( interactionID );

	//add the longest duration of the parallel runs of CNP5
	double max_computation_time_of_all_salesmen = 0;
	for(int salesman=0 ; salesman<salesmen.size() ; salesman++){
		if(debug)	trace(interaction[salesman]+"\t");
		if( max_computation_time_of_all_salesmen < interaction[salesman])
			max_computation_time_of_all_salesmen = interaction[salesman];
		computation_time_of_salesman[salesman] += interaction[salesman];
	}
	total_computation_time += max_computation_time_of_all_salesmen;
	
	//add the duration of host's CNP3 and CNP9
	computation_time_of_salesman[ (int)interaction[salesmen.size()+2] ] += interaction[salesmen.size()];
	total_computation_time += interaction[salesmen.size()];
	if(debug)	trace(interaction[salesmen.size()]+"\t");
	
	computation_time_of_salesman[ (int)interaction[salesmen.size()+2] ] += interaction[salesmen.size()+1];
	total_computation_time += interaction[salesmen.size()+1];
	if(debug)	trace(interaction[salesmen.size()+1]+"\t");
	
	if(debug)	traceln(interaction[salesmen.size()+2]);
}

/*	The maximum of the computation times of guests in CNP 5 is calculated by the host in CNP9.
	Since CNP9 is not run in the last m rounds, Salesman.my_computation_time are false.
	computation_time_of_salesman[] takes these last rounds into account
*/
for(Salesman s : salesmen)
	s.my_computation_time = computation_time_of_salesman[s.getIndex()];

return total_computation_time;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1499257387399</Id>
					<Name><![CDATA[duration_of_AuctionSwap]]></Name>
					<X>670</X><Y>-120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/*
interaction[0]		= duration of CPLEX call of Salesman 0		in A4_propose_a_city_to_give (or in the initialisation in the 1st line of durations_of_calls_to_the_solver)
...					= ...
interaction[m-1]	= duration of CPLEX call of Salesman m-1	in A4_propose_a_city_to_give (or in the initialisation in the 1st line of durations_of_calls_to_the_solver)
interaction[m]		= duration of CPLEX call of Salesman 0		in A10_bid_on_every_proposed_city
...					= ...
interaction[2m-1]	= duration of CPLEX call of Salesman m-1	in A10_bid_on_every_proposed_city
interaction[2m]		= duration of CPLEX call of central planner	in A14_send_allocation_of_cities
*/
boolean debug = false;
double total_computation_time = 0;
double[] computation_time_of_salesman = new double[salesmen.size()];

for(double[] interaction : durations_of_calls_to_the_solver){
	double max_duration_of_A4 = 0;
	for(int salesman=0 ; salesman<salesmen.size() ; salesman++){
		if( max_duration_of_A4 < interaction[salesman])
			max_duration_of_A4 = interaction[salesman];
		computation_time_of_salesman[ salesman ] += interaction[salesman];
	}
	total_computation_time += max_duration_of_A4;
	//trace(" max_duration_of_A4= "+max_duration_of_A4);
	
	double max_duration_of_A10 = 0;
	for(int salesman=salesmen.size() ; salesman<2*salesmen.size() ; salesman++){
		if( max_duration_of_A10 < interaction[salesman])
			max_duration_of_A10 = interaction[salesman];
		computation_time_of_salesman[ salesman-salesmen.size() ] += interaction[salesman];
	}
	total_computation_time += max_duration_of_A10;
	//trace(" max_duration_of_A10= "+max_duration_of_A10);
	
	//add the duration of A14_send_allocation_of_cities
	total_computation_time += interaction[ 2*salesmen.size() ];
	//traceln(" duration_of_A14= "+interaction[ 2*salesmen.size()]);
}

/*	The maximum of the computation times of guests in CNP 5 is calculated by the host in CNP9.
	Since CNP9 is not run in the last m rounds, Salesman.my_computation_time are false.
	computation_time_of_salesman[] takes these last rounds into account
*/
for(Salesman s : salesmen)
	s.my_computation_time = computation_time_of_salesman[s.getIndex()];

return total_computation_time;]]></Body>
				</Function>
			</Functions>
			<Connectivity>
				<TextFile>
					<Id>1469544529124</Id>
					<Name><![CDATA[csv_file]]></Name>
					<X>390</X><Y>-300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<FileType>FILE</FileType>
					<FileName><![CDATA[output.csv]]></FileName>
					<FileMode>WRITE_APPEND</FileMode>
					<CharsetName>null</CharsetName>
					<Separators>	</Separators>
				</TextFile>
			</Connectivity>
			<AgentLinks>
				<AgentLink>
					<Id>1428929294898</Id>
					<Name><![CDATA[connections]]></Name>
					<X>30</X><Y>-310</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<EmbeddedObjects>
				<EmbeddedObject>
					<Id>1428938970961</Id>
					<Name><![CDATA[cities]]></Name>
					<X>860</X><Y>430</Y>
					<Label><X>10</X><Y>1</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<PresentationId>1428938972074</PresentationId>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[City]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[tsp]]></PackageName>
							<ClassName><![CDATA[City]]></ClassName>
							<ItemName><![CDATA[1456145103508]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
					</Parameters>
					<ReplicationFlag>true</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[cityNumber]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialSpeedCode Class="CodeUnitValue">
						<Code><![CDATA[10]]></Code>
						<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
					</InitialSpeedCode>
					<InitialLocationType>AT_ANIMATION_POSITION</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LatitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LatitudeCode>
					<LongitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LongitudeCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1429198042808</Id>
					<Name><![CDATA[salesmen]]></Name>
					<X>860</X><Y>410</Y>
					<Label><X>10</X><Y>1</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<PresentationId>1429198045126</PresentationId>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[tsp]]></PackageName>
							<ClassName><![CDATA[Salesman]]></ClassName>
							<ItemName><![CDATA[1456145103515]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
						<Parameter>
							<Name><![CDATA[color]]></Name>
						</Parameter>
					</Parameters>
					<ReplicationFlag>true</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[salesmanNumber]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialSpeedCode Class="CodeUnitValue">
						<Code><![CDATA[10]]></Code>
						<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
					</InitialSpeedCode>
					<InitialLocationType>AT_ANIMATION_POSITION</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[cities.get( cities.size() ).getX()]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[cities.get(0).getY()]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[cities.get(0).getZ()]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LatitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LatitudeCode>
					<LongitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LongitudeCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
				<EmbeddedObject>
					<Id>1459942702481</Id>
					<Name><![CDATA[centralPlanner]]></Name>
					<X>860</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<PresentationId>1459942702644</PresentationId>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[CentralAuthority]]></ClassName>
					</ActiveObjectClass>
					<GenericParameterSubstitute>
						<GenericParameterSubstituteReference>
							<PackageName><![CDATA[tsp]]></PackageName>
							<ClassName><![CDATA[CentralAuthority]]></ClassName>
							<ItemName><![CDATA[1459942693470]]></ItemName>
						</GenericParameterSubstituteReference>
					</GenericParameterSubstitute>
					<Parameters>
					</Parameters>
					<ReplicationFlag>true</ReplicationFlag>
					<Replication Class="CodeValue">
						<Code><![CDATA[centralPlannerNumber]]></Code>
					</Replication>
					<CollectionType>ARRAY_LIST_BASED</CollectionType>
					<InEnvironment>true</InEnvironment>	
					<InitialSpeedCode Class="CodeUnitValue">
						<Code><![CDATA[10]]></Code>
						<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
					</InitialSpeedCode>
					<InitialLocationType>AT_ANIMATION_POSITION</InitialLocationType>
					<XCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</XCode>
					<YCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</YCode>
					<ZCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ZCode>
					<ColumnCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</ColumnCode>
					<RowCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</RowCode>
					<LatitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LatitudeCode>
					<LongitudeCode Class="CodeValue">
						<Code><![CDATA[0]]></Code>
					</LongitudeCode>
					<LocationNameCode Class="CodeValue">
						<Code><![CDATA[""]]></Code>
					</LocationNameCode>
					<InitializationType>SPECIFIED_NUMBER</InitializationType>
					<InitializationDatabaseTableQuery>
						<TableReference>
						</TableReference>
					</InitializationDatabaseTableQuery>
					<InitializationDatabaseType>ONE_AGENT_PER_DATABASE_RECORD</InitializationDatabaseType>
					<QuantityColumn>
					</QuantityColumn>
				</EmbeddedObject>
			</EmbeddedObjects>

			<Shapes>
				<Rectangle>
					<Id>1429111617114</Id>
					<Name><![CDATA[rectangleP]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[switch(mouseMode){
	case 2:	if(selectedSalesman >= 0){	//add new city
				City city = add_cities();
				city.setXY(clickx, clicky);
				city.cityText.setColor( salesmen.get(selectedSalesman).color );
				salesmen.get(selectedSalesman).ownedCities.add(city);
				salesmen.get(selectedSalesman).allocatedCities.add(city);
				if( solveNdrawAutomatically ){
					salesmen.get(selectedSalesman).solve();
					salesmen.get(selectedSalesman).eraseRoute();
					salesmen.get(selectedSalesman).drawRoute();
				}
			} else {
				for( Salesman salesman : salesmen ){
					City city = add_cities();
					city.setXY(clickx, clicky);
					salesman.ownedCities.add(city);
					salesman.allocatedCities.add(city);
					solve();
					if( solveNdrawAutomatically ){
						salesman.eraseRoute();
						salesman.drawRoute();
					}
				}
			}
			break;
	case 3: salesmen.get( selectedSalesman ).setXY( clickx, clicky );	//move salesman
/*			if( solveAutomatically ){
				salesmen.get( selectedSalesman ).solve();
				salesmen.get( selectedSalesman ).nextCity2Visit = (City)salesmen.get( selectedSalesman ).route.get(0);
				salesmen.get( selectedSalesman ).moveTo( salesmen.get( selectedSalesman ).nextCity2Visit.getX(), salesmen.get( selectedSalesman ).nextCity2Visit.getY() );
			}*/
			break;
}]]></OnClickCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<Width>1000</Width>
					<Height>700</Height>
					<WidthCode><![CDATA[rectangleWidth]]></WidthCode>
					<HeightCode><![CDATA[rectangleHeight]]></HeightCode>
					<Rotation>0.0</Rotation>
					<FillColor>-24454</FillColor>
					<FillMaterial>null</FillMaterial>
				</Rectangle>
				<EmbeddedObjectPresentation>
					<Id>1428938972074</Id>
					<Name><![CDATA[cities_presentation]]></Name>
					<X>120</X><Y>-280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<ReplicationCode Class="CodeValue">
						<Code><![CDATA[cities.size()]]></Code>
					</ReplicationCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<DrawingMode>AGENT_CURRENT_POSITION</DrawingMode>
					<ScaleType>AUTOMATICALLY_CALCULATED</ScaleType>
					<GISScaleForRealEmbeddedObjectPresentationSize>1000</GISScaleForRealEmbeddedObjectPresentationSize>
					<GISScaleForFixedEmbeddedObjectPresentationSize>1000000000</GISScaleForFixedEmbeddedObjectPresentationSize>
					<Latitude>0.0</Latitude>
					<Longitude>0.0</Longitude>
				</EmbeddedObjectPresentation>
				<EmbeddedObjectPresentation>
					<Id>1429198045126</Id>
					<Name><![CDATA[salesmen_presentation]]></Name>
					<X>40</X><Y>-270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<ReplicationCode Class="CodeValue">
						<Code><![CDATA[salesmen.size()]]></Code>
					</ReplicationCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<DrawingMode>AGENT_CURRENT_POSITION</DrawingMode>
					<ScaleType>AUTOMATICALLY_CALCULATED</ScaleType>
					<GISScaleForRealEmbeddedObjectPresentationSize>1000</GISScaleForRealEmbeddedObjectPresentationSize>
					<GISScaleForFixedEmbeddedObjectPresentationSize>1000000000</GISScaleForFixedEmbeddedObjectPresentationSize>
					<Latitude>0.0</Latitude>
					<Longitude>0.0</Longitude>
				</EmbeddedObjectPresentation>
				<Text>
					<Id>1432819244971</Id>
					<Name><![CDATA[text]]></Name>
					<X>8</X><Y>706</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Action of the mouse:]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<EmbeddedObjectPresentation>
					<Id>1459942702644</Id>
					<Name><![CDATA[centralPlanner_presentation]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<ReplicationCode Class="CodeValue">
						<Code><![CDATA[centralPlanner.size()]]></Code>
					</ReplicationCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<DrawingMode>AGENT_CURRENT_POSITION</DrawingMode>
					<ScaleType>AUTOMATICALLY_CALCULATED</ScaleType>
					<GISScaleForRealEmbeddedObjectPresentationSize>1000</GISScaleForRealEmbeddedObjectPresentationSize>
					<GISScaleForFixedEmbeddedObjectPresentationSize>1000000000</GISScaleForFixedEmbeddedObjectPresentationSize>
					<Latitude>0.0</Latitude>
					<Longitude>0.0</Longitude>
				</EmbeddedObjectPresentation>
			</Shapes>
			<Controls>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1429108765342</Id>
					<Name><![CDATA[AddCity_button]]></Name>
					<X>103.748</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[Salesman chosenSalesman;
if(selectedSalesman < 0)
	chosenSalesman = salesmen.get( (int)(Math.random()*salesmanNumber) );
else
	chosenSalesman = salesmen.get( selectedSalesman );

City city = add_cities();
double x = Math.random()*rectangleWidth;
double y = Math.random()*rectangleHeight;
city.setXY(x, y);
city.cityText.setColor( chosenSalesman.color );
chosenSalesman.ownedCities.add(city);
chosenSalesman.allocatedCities.add(city);
if( solveNdrawAutomatically )
	for(Salesman salesman : salesmen)
		salesman.eraseRoute();
if(selectedSalesman < 0){
	solve();
	for(Salesman salesman : salesmen)	salesman.moveTo(salesman.nextCity2visit.getX(), salesman.nextCity2visit.getY());
}
else{
	chosenSalesman.solve();
	chosenSalesman.moveTo(chosenSalesman.nextCity2visit.getX(), chosenSalesman.nextCity2visit.getY());
}
if( solveNdrawAutomatically )
	for(Salesman salesman : salesmen)
		salesman.drawRoute();


/*if(selectedSalesman >= 0) {
	City city = add_cities();
	city.setXY(Math.random()*rectangleWidth, Math.random()*rectangleHeight);
	city.cityText.setColor(salesmen.get(selectedSalesman).color);
	salesmen.get(selectedSalesman).cities.add(city);
	salesmen.get(selectedSalesman).cities2visit.add(city);
	if( solveNdrawAutomatically )
		salesmen.get(selectedSalesman).eraseRoute();
	salesmen.get(selectedSalesman).solve();
	if( solveNdrawAutomatically )
		salesmen.get(selectedSalesman).drawRoute();
} else for(Salesman salesman : salesmen){
	City city = add_cities();
	city.setXY(Math.random()*rectangleWidth, Math.random()*rectangleHeight);
	city.cityText.setColor(salesman.color);
	salesman.cities.add(city);
	salesman.cities2visit.add(city);
	if( solveNdrawAutomatically )
		salesman.eraseRoute();
	solve();
	if( solveNdrawAutomatically )
		salesman.drawRoute();
}*/]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[+ random city]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1429113637004</Id>
					<Name><![CDATA[solve_button]]></Name>
					<X>0</X><Y>753</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if(selectedSalesman<0)
	solve();
else salesmen.get( selectedSalesman ).solve();

if( solveNdrawAutomatically ){
	for(Salesman salesman : salesmen){
		salesman.eraseRoute();
		salesman.drawRoute();
	}
}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Solve with:]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1432805111079</Id>
					<Name><![CDATA[solverRadioButtons]]></Name>
					<X>118</X><Y>770</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="240" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[insertion]]></Button>
						<Button><![CDATA[cplex]]></Button>
						<Button><![CDATA[ojalgo]]></Button>
						<LinkTo>true</LinkTo>
						<Link>selectedTspSolver</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1432818752233</Id>
					<Name><![CDATA[radio]]></Name>
					<X>116</X><Y>691</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="740" Height="40" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[Select salesman]]></Button>
						<Button><![CDATA[Delete  city]]></Button>
						<Button><![CDATA[Add  city to selected salesman]]></Button>
						<Button><![CDATA[Move selected salesman]]></Button>
						<LinkTo>true</LinkTo>
						<Link>mouseMode</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1433170491493</Id>
					<Name><![CDATA[selectAll_button]]></Name>
					<X>0</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[selectedSalesman = -1;
//globalOptimization = true;
for(Salesman salesman : salesmen)
	salesman.ovalShape.setVisible(true);
]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Select all salesmen]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438267540415</Id>
					<Name><![CDATA[eraseRoute_button]]></Name>
					<X>311.244</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if(selectedSalesman >= 0)
	salesmen.get(selectedSalesman).eraseRoute();
else for(Salesman salesman : salesmen)
		salesman.eraseRoute();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Erase route]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438268032871</Id>
					<Name><![CDATA[drawRoute_button]]></Name>
					<X>207.497</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if(selectedSalesman >= 0){
	salesmen.get(selectedSalesman).eraseRoute();
	salesmen.get(selectedSalesman).drawRoute();
}
else for(Salesman salesman : salesmen){
		salesman.eraseRoute();
		salesman.drawRoute();
	}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Draw route]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438354611949</Id>
					<Name><![CDATA[solveNdrawAutomatically_checkbox]]></Name>
					<X>190</X><Y>-80</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>solveNdrawAutomatically</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1440686058605</Id>
					<Name><![CDATA[salesmenShareDepot0_checkbox]]></Name>
					<X>190</X><Y>-170</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>salesmenShareDepot0</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1440789770202</Id>
					<Name><![CDATA[clear_button]]></Name>
					<X>414.993</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if(selectedSalesman >= 0)
	salesmen.get(selectedSalesman).route.clear();
else for(Salesman salesman : salesmen)
		salesman.route.clear();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Clear route]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1449583234638</Id>
					<Name><![CDATA[maxReallocations_editbox]]></Name>
					<X>180</X><Y>-40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[for(Salesman salesman : salesmen)
	salesman.maxReallocations = Integer.parseInt(value);]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LinkTo>true</LinkTo>
						<Link>maxReallocations</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1457110497801</Id>
					<Name><![CDATA[unallocate_button]]></Name>
					<X>518.741</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[for(Salesman salesman : salesmen){
	salesman.allocatedCities = (ArrayList)salesman.ownedCities.clone();
}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Unallocate]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1458834905072</Id>
					<Name><![CDATA[staticSolver_checkbox]]></Name>
					<X>880</X><Y>750</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Static Solver]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>staticSolver</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1460119299216</Id>
					<Name><![CDATA[approachRadioButtons]]></Name>
					<X>117</X><Y>750</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="773" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[FullCentr]]></Button>
						<Button><![CDATA[OptDecentr]]></Button>
						<Button><![CDATA[-]]></Button>
						<Button><![CDATA[Cluster Rao]]></Button>
						<Button><![CDATA[Cluster Saglam]]></Button>
						<Button><![CDATA[Auction]]></Button>
						<Button><![CDATA[P2P]]></Button>
						<Button><![CDATA[CNP]]></Button>
						<Button><![CDATA[NoRealloc]]></Button>
						<LinkTo>true</LinkTo>
						<Link>selectedAllocationMechanism</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1460566021428</Id>
					<Name><![CDATA[routeLength_button]]></Name>
					<X>622.489</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[for(Salesman salesman : salesmen){
	trace(salesman);
	double totalRouteLen = 0;
	for(int city=0 ; city<salesman.allocatedCities.size()-1 ; city++){
		trace("\tC"+salesman.allocatedCities.get(city).getIndex());
		trace("C"+salesman.allocatedCities.get(city+1).getIndex());
		trace("="+(int)Math.sqrt( Math.pow( salesman.allocatedCities.get(city).getX()-salesman.allocatedCities.get(city+1).getX(), 2) + Math.pow( salesman.allocatedCities.get(city).getY()-salesman.allocatedCities.get(city+1).getY(), 2)));
	}
	trace("\tC"+salesman.allocatedCities.get(salesman.allocatedCities.size()-1).getIndex());
	trace("C"+salesman.allocatedCities.get(0).getIndex());
	trace("="+(int)Math.sqrt( Math.pow( salesman.allocatedCities.get(salesman.allocatedCities.size()-1).getX()-salesman.allocatedCities.get(0).getX(), 2) + Math.pow( salesman.allocatedCities.get(salesman.allocatedCities.size()-1).getY()-salesman.allocatedCities.get(0).getY(), 2)));
	traceln("\t"+salesman.routeLength());
}

/*if( selectedSalesman>=0)
	traceln(salesmen.get(selectedSalesman)+" routeLength = " + salesmen.get(selectedSalesman).routeLength());
else for(Salesman salesman : salesmen)
	traceln(salesman + " routeLength = " + salesman.routeLength());*/]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[route lengths]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1466065026637</Id>
					<Name><![CDATA[go_button]]></Name>
					<X>734</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="116" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[for(Salesman salesman : salesmen){
	if( !(salesman.getX() == salesman.nextCity2visit.getX() && salesman.getY() == salesman.nextCity2visit.getY()) )
		salesman.moveTo( salesman.nextCity2visit );
	else if(salesman.route.size()>1){
		if(salesman.route.indexOf( salesman.nextCity2visit ) < salesman.route.size()){
			salesman.nextCity2visit = salesman.route.get( salesman.route.indexOf( salesman.nextCity2visit ) + 1 );
		}
		else{
			salesman.nextCity2visit = salesman.route.get(0);
		}
		salesman.moveTo( salesman.nextCity2visit );
	}
}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[go!]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1469028323967</Id>
					<Name><![CDATA[button_previously_proposed_cities]]></Name>
					<X>845</X><Y>723</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[trace("\t\t");
for(int city=0 ; city<cities.size() ; city++)
	trace("\tC"+city);
traceln();
for(Salesman salesman : salesmen){
	trace(salesman);
	for(City city : cities){
		if(salesman.ownedCities.contains( city ))
			trace("\towns");
		else
			trace("\t.");
	}
	traceln();
	trace(salesman);
	for(City city : cities){
		if(salesman.allocatedCities.contains( city ))
			trace("\talloc");
		else
			trace("\t.");
	}
	traceln();
	for(int sman=0 ; sman<salesmen.size() ; sman++){
		if(sman != salesman.getIndex())
		{
			trace(salesman+ " " + sman);
//			traceln();
//			trace(salesman+ " " + sman);
			for(int city=0 ; city<cities.size() ; city++){
				if(salesman.propCities[sman][city])
					trace("\tTRUE");
				else
					trace("\t.");
			}
		traceln();
		}
	}
}
/*for(Salesman salesman : salesmen){
	trace(salesman+": "+salesman.routeLength()+"\t");
	salesman.routeLength_verbose();
	traceln();
	
}*/]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Prev. prop._cities]]></LabelText>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1498555165214</Id>
					<Name><![CDATA[button_durations_of_calls_to_solve]]></Name>
					<X>860</X><Y>-70</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[traceln("Content of durations_of_calls_to_the_solver:");
for(double[] interaction : durations_of_calls_to_the_solver){
	for(int salesman=0 ; salesman<interaction.length ; salesman++){
		trace("\t"+interaction[salesman]);
	}
	traceln();
}
trace("Content of every salesman's my_computation_time: "+centralPlanner.get(0).my_computation_time);
for(Salesman salesman : salesmen){
	trace("+"+salesman.my_computation_time);
}
traceln("\nremainingComputationTime: "+remainingComputationTime);
traceln("computationTime: "+(maximumComputationTimeSpan-remainingComputationTime) );

trace("P2P_end_date_of_computation for: ");
for(Salesman salesman : salesmen){
	trace(salesman+": "+salesman.P2P_end_date_of_computation+"\t");
}
traceln();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[button_durations_of_calls_to_solve]]></LabelText>
					</ExtendedProperties>
				</Control>
			</Controls>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1428936935027</Id>
			<Name><![CDATA[City]]></Name>
			<Description><![CDATA[The position of the cities is derived from TSPLIB (more specifically, http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz)]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<StartupCode><![CDATA[/*	Set the coordinates according to TSPLIB	*/
switch(get_Main().problemID){
	case 0:	if(getIndex()==0)	//write only once
				if(get_Main().consoleOutput)	trace("uniform\t");
				else		get_Main().csv_file.print("uniform\t");
			setXY(uniform(0, get_Main().rectangleWidth), uniform(0, get_Main().rectangleHeight));
			break;
	case 1:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("normal\t");
				else		get_Main().csv_file.print("normal\t");
			setXY(normal(get_Main().rectangleWidth/6, get_Main().rectangleWidth/2), normal(get_Main().rectangleHeight/6, get_Main().rectangleHeight/2));
			break;
	case 2:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("CH130\t");
				else		get_Main().csv_file.print("CH130\t");
			setXY( possibleLocations_CH130_X[ getIndex() ] , possibleLocations_CH130_Y[ ( getIndex()+get_Main().instance )%possibleLocations_CH130_Y.length ] );
			break;
	case 3:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("TS225\t");
				else		get_Main().csv_file.print("TS225\t");
			setXY( possibleLocations_TS225_X[ getIndex() ] , possibleLocations_TS225_Y[ ( getIndex()+get_Main().instance )%possibleLocations_TS225_Y.length ] );
			break;
	case 4:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("TSP225\t");
				else		get_Main().csv_file.print("TSP225\t");
			setXY( possibleLocations_TSP225_X[ getIndex() ] , possibleLocations_TSP225_Y[ ( getIndex()+get_Main().instance )%possibleLocations_TSP225_Y.length ] );
			break;
	case 5:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("A280\t");
				else		get_Main().csv_file.print("A280\t");
			setXY( possibleLocations_A280_X[ getIndex() ] , possibleLocations_A280_Y[ ( getIndex()+get_Main().instance )%possibleLocations_A280_Y.length ] );
			break;
	case 6:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("PR299\t");
				else		get_Main().csv_file.print("PR299\t");
			setXY( possibleLocations_PR299_X[ getIndex() ] , possibleLocations_PR299_Y[ ( getIndex()+get_Main().instance )%possibleLocations_PR299_Y.length ] );
			break;
	case 7:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("LIN318\t");
				else		get_Main().csv_file.print("LIN318\t");
			setXY( possibleLocations_LIN318_X[ getIndex() ] , possibleLocations_LIN318_Y[ ( getIndex()+get_Main().instance )%possibleLocations_LIN318_Y.length ] );
			break;
	case 8:	if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("FL417\t");
				else		get_Main().csv_file.print("FL417\t");
			setXY( possibleLocations_FL417_X[ getIndex() ] , possibleLocations_FL417_Y[ ( getIndex()+get_Main().instance )%possibleLocations_FL417_Y.length ] );
			break;
	case 9:if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("GR431\t");
				else		get_Main().csv_file.print("GR431\t");
			setXY( possibleLocations_GR431_X[ getIndex() ] , possibleLocations_GR431_Y[ ( getIndex()+get_Main().instance )%possibleLocations_GR431_Y.length ] );
			break;
	case 10:if(getIndex()==0)
				if(get_Main().consoleOutput)	trace("D493\t");
				else		get_Main().csv_file.print("D493\t");
			setXY( possibleLocations_D493_X[ getIndex() ] , possibleLocations_D493_Y[ ( getIndex()+get_Main().instance )%possibleLocations_D493_Y.length ] );
			break;
}
//traceln(this +" X="+getX() + " Y="+getY() + " iter=" + ((ExperimentParamVariation)getExperiment()).getCurrentIteration() + " replic=" + ((ExperimentParamVariation)getExperiment()).getCurrentReplication());
//if(getIndex()==0)	setXY(get_Main().rectangleWidth/2,		get_Main().rectangleHeight/2);

//2 salesmen + 11 cities
/*if(getIndex()==0)	setXY(get_Main().rectangle.getWidth()/2 - 100,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==1)	setXY(get_Main().rectangle.getWidth()/2 - 200,	get_Main().rectangle.getHeight()/2 + 0);
if(getIndex()==2)	setXY(get_Main().rectangle.getWidth()/2 + 0,	get_Main().rectangle.getHeight()/2 + 0);
if(getIndex()==4)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 + 0);
if(getIndex()==3)	setXY(get_Main().rectangle.getWidth()/2 - 300,	get_Main().rectangle.getHeight()/2 + 0);
if(getIndex()==6)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==5)	setXY(get_Main().rectangle.getWidth()/2 - 300,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==8)	setXY(get_Main().rectangle.getWidth()/2 + 0,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==7)	setXY(get_Main().rectangle.getWidth()/2 - 200,	get_Main().rectangle.getHeight()/2 + 200);

if(getIndex()==9)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==10)	setXY(get_Main().rectangle.getWidth()/2 - 400,	get_Main().rectangle.getHeight()/2 + 100);
*/
//3 salesmen
/*if(getIndex()==0)	setXY(get_Main().rectangle.getWidth()/2 + 0,	get_Main().rectangle.getHeight()/2 + 0);
if(getIndex()==1)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 - 100);
if(getIndex()==2)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==3)	setXY(get_Main().rectangle.getWidth()/2 - 100,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==4)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 - 100);
if(getIndex()==5)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==6)	setXY(get_Main().rectangle.getWidth()/2 - 200,	get_Main().rectangle.getHeight()/2 + 100);
if(getIndex()==7)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 - 200);
if(getIndex()==8)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==9)	setXY(get_Main().rectangle.getWidth()/2 - 100,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==10)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 - 200);
if(getIndex()==11)	setXY(get_Main().rectangle.getWidth()/2 + 100,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==12)	setXY(get_Main().rectangle.getWidth()/2 - 200,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==13)	setXY(get_Main().rectangle.getWidth()/2 - 300,	get_Main().rectangle.getHeight()/2 + 200);
if(getIndex()==14)	setXY(get_Main().rectangle.getWidth()/2 + 200,	get_Main().rectangle.getHeight()/2 - 300);
if(getIndex()==15)	setXY(get_Main().rectangle.getWidth()/2 + 300,	get_Main().rectangle.getHeight()/2 + 200);
*/

x=getX();
y=getY();

/*Experiment exp = getExperiment();
int deltaY = 0;
if( exp instanceof ExperimentParamVariation )
	deltaY = ((ExperimentParamVariation)exp).getCurrentReplication();
else if( exp instanceof ExperimentSimulation )
	deltaY = ((ExperimentSimulation)exp).getRunCount();
*/]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1456145103508</Id>
				<Name><![CDATA[1456145103508]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameters:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10 / getScale().pixelsPerUnit(METER) / 60]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1456214400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1456145103514</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>EXPLICITLY_DEFINED</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>KILOMETER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1428936935026</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1437405898746</Id>
					<Name><![CDATA[owningSalesman]]></Name>
					<X>30</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Salesman]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1440775390858</Id>
					<Name><![CDATA[visitingSalesman]]></Name>
					<X>180</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Salesman]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1441212175661</Id>
					<Name><![CDATA[x]]></Name>
					<X>70</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1441212215835</Id>
					<Name><![CDATA[y]]></Name>
					<X>120</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1458757909018</Id>
					<Name><![CDATA[possibleLocations_CH130_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{334.5909246, 397.6446634, 503.8741827, 444.0479404, 311.6137147, 662.8551011, 40.09790306, 526.8941409, 209.1887938, 683.2674132, 280.7494439, 252.749309, 698.7850452, 678.7574678, 220.0041131, 355.1528557, 296.9724228, 504.5154072, 224.1079497, 470.6801297, 554.2530513, 567.6332684, 599.0532671, 240.5232959, 32.08259728, 91.05387369, 248.2179895, 488.8909044, 206.046794, 575.8409416, 282.6089948, 27.65814849, 568.573731, 269.4638933, 417.8004857, 32.16809387, 561.4775136, 342.9482167, 399.6752075, 571.737105, 370.7559843, 509.7093253, 177.0207, 526.1674199, 316.5725172, 469.29081, 572.7630641, 29.51769943, 454.0082937, 416.1546762, 535.2514331, 265.4455534, 478.054211, 370.4781203, 598.3479202, 201.1521139, 193.692536, 448.5792599, 603.2853486, 543.0102491, 214.5750793, 426.3501452, 89.04470371, 84.49201002, 220.0468614, 688.4613313, 687.2857532, 75.4934934, 63.41709935, 97.93634959, 399.5255885, 456.3167017, 319.8855102, 295.9250895, 288.4868857, 268.3951859, 140.4709056, 689.8079027, 280.5784507, 453.3884434, 213.5704943, 133.6953005, 521.1658691, 30.26579463, 657.0199585, 6.925224196, 252.4286968, 42.85516825, 145.8999394, 638.4885716, 489.2756391, 361.2231139, 519.9475426, 129.3349741, 259.7172815, 676.342189, 84.51338417, 77.71640487, 335.9802443, 264.3554718, 51.68269169, 692.1376849, 169.2191357, 194.0131482, 415.1928395, 415.0432205, 169.838986, 525.0987124, 238.6851191, 116.2112468, 16.92832581, 434.3440768, 40.52538604, 530.4849979, 484.3595849, 263.6501249, 450.2891918, 441.7822806, 24.21691054, 503.7886861, 635.538939, 614.5922733, 21.71613513, 143.826647, 637.7191022, 566.564561, 196.6849168, 384.9270449, 178.1107816, 403.2874387}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1458758257005</Id>
					<Name><![CDATA[possibleLocations_CH130_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{161.7809319, 262.8165331, 172.8741151, 384.649181, 2.009169983, 549.2301264, 187.2375431, 215.7079092, 691.0262292, 414.2096287, 5.920639205, 535.7430385, 348.441373, 410.7256424, 409.1225813, 76.39120764, 313.1312792, 240.8866564, 358.4872229, 309.6259188, 279.4242467, 352.7162027, 361.094869, 430.6036008, 345.855101, 148.721327, 343.9528017, 3.612231139, 437.7639406, 141.967096, 329.4183806, 424.7684582, 287.0975661, 295.9464636, 341.259659, 448.8998721, 357.354393, 492.3321424, 156.8435036, 375.7575351, 151.9060752, 435.7975189, 295.6044773, 409.4859418, 65.64001082, 281.9891445, 373.3208821, 330.0382309, 537.2178548, 227.6133101, 471.0648644, 684.9987192, 509.6452029, 332.5390063, 446.869328, 649.0260269, 680.2322841, 532.793406, 134.4006474, 481.5168231, 43.64601175, 61.7285416, 277.1158386, 31.84748164, 623.0778103, 0.470231273, 373.5346236, 312.9175377, 23.70393097, 211.0910931, 170.8221968, 597.1937162, 626.8396605, 664.6291555, 667.7284071, 52.90101816, 513.5566721, 167.5947004, 458.7533547, 282.9082329, 525.8681818, 677.1757808, 132.8617087, 450.0754503, 39.77729083, 23.87492416, 535.1659365, 63.82320818, 399.5255885, 62.62625585, 665.3131282, 564.2347788, 347.9711417, 435.669274, 454.6495181, 371.0979707, 183.3260739, 354.3833863, 660.6321897, 377.5743377, 676.0429509, 543.8010926, 547.8194325, 263.4791317, 78.9133572, 479.0801702, 245.6103433, 213.5063719, 33.4932911, 363.5742703, 656.5711014, 92.69968314, 424.6829616, 183.8390534, 49.24603873, 426.5852608, 126.3853416, 299.7724363, 500.3474482, 514.689502, 200.9811207, 418.8691931, 660.974176, 92.69968314, 54.20484124, 199.9551616, 221.8209158, 87.4630167, 104.6905806, 205.8971749}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375082439</Id>
					<Name><![CDATA[possibleLocations_TS225_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 13000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 4500, 5000, 5500, 6000, 6500, 4500, 5000, 5500, 6000, 6500, 4500, 5000, 5500, 6000, 6500, 4500, 5000, 5500, 6000, 6500, 4500, 5000, 5500, 6000, 6500, 7500, 8000, 8500, 9000, 9500, 7500, 8000, 8500, 9000, 9500, 7500, 8000, 8500, 9000, 9500, 7500, 8000, 8500, 9000, 9500, 7500, 8000, 8500, 9000, 9500, 10500, 11000, 11500, 12000, 12500, 10500, 11000, 11500, 12000, 12500, 10500, 11000, 11500, 12000, 12500, 10500, 11000, 11500, 12000, 12500, 10500, 11000, 11500, 12000, 12500, 13500, 14000, 14500, 15000, 15500, 13500, 14000, 14500, 15000, 15500, 13500, 14000, 14500, 15000, 15500, 13500, 14000, 14500, 15000, 15500, 13500, 14000, 14500, 15000, 15500}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375082441</Id>
					<Name><![CDATA[possibleLocations_TS225_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, 13000, 13500, 14000, 14500, 15000, 15500, 16000, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, 13000, 13500, 14000, 14500, 15000, 15500, 16000, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, 13000, 13500, 14000, 14500, 15000, 15500, 16000, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, 13000, 13500, 14000, 14500, 15000, 15500, 16000, 4000, 4500, 5000, 5500, 6000, 6500, 7000, 7500, 8000, 8500, 9000, 9500, 10000, 10500, 11000, 11500, 12000, 12500, 13000, 13500, 14000, 14500, 15000, 15500, 16000, 4000, 4000, 4000, 4000, 4000, 7000, 7000, 7000, 7000, 7000, 10000, 10000, 10000, 10000, 10000, 13000, 13000, 13000, 13000, 13000, 16000, 16000, 16000, 16000, 16000, 4000, 4000, 4000, 4000, 4000, 7000, 7000, 7000, 7000, 7000, 10000, 10000, 10000, 10000, 10000, 13000, 13000, 13000, 13000, 13000, 16000, 16000, 16000, 16000, 16000, 4000, 4000, 4000, 4000, 4000, 7000, 7000, 7000, 7000, 7000, 10000, 10000, 10000, 10000, 10000, 13000, 13000, 13000, 13000, 13000, 16000, 16000, 16000, 16000, 16000, 4000, 4000, 4000, 4000, 4000, 7000, 7000, 7000, 7000, 7000, 10000, 10000, 10000, 10000, 10000, 13000, 13000, 13000, 13000, 13000, 16000, 16000, 16000, 16000, 16000}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375082443</Id>
					<Name><![CDATA[possibleLocations_TSP225_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{155.42,375.92,183.92,205.42,205.42,226.42,226.42,226.42,226.42,226.42,226.42,226.42,226.42,205.42,190.92,190.92,176.92,176.92,155.42,155.42,155.42,183.92,219.42,240.92,269.42,290.42,387.42,318.92,318.92,318.92,318.92,297.92,290.42,290.42,297.92,254.92,254.92,254.92,254.92,254.92,254.92,254.92,254.92,276.42,296.42,276.42,375.92,308.92,354.92,338.42,354.92,338.42,338.42,354.92,354.92,361.92,361.92,383.42,383.42,404.42,404.42,418.92,418.92,432.92,432.92,418.92,418.92,397.42,397.42,375.92,375.92,368.92,368.92,347.42,347.42,336.42,336.42,347.42,347.42,368.92,368.92,418.92,418.92,432.92,432.92,447.42,447.42,447.42,432.92,432.92,418.92,418.92,397.42,397.42,375.92,375.92,361.92,361.92,375.92,375.92,397.42,397.42,418.92,418.92,439.92,439.92,454.42,454.42,461.42,461.42,461.42,447.42,447.42,439.92,439.92,419.92,419.92,439.92,454.42,475.92,475.92,496.92,496.92,496.92,496.92,496.92,496.92,496.92,496.92,470.42,470.42,496.92,347.42,539.92,560.92,589.42,589.42,603.92,610.92,610.92,610.92,624.92,624.92,610.92,610.92,589.42,589.42,575.42,560.92,542.92,542.92,560.92,575.42,575.42,582.42,582.42,596.42,560.92,596.42,582.42,582.42,575.42,575.42,525.42,525.42,525.42,525.42,525.42,525.42,525.42,525.42,546.92,546.92,568.42,475.92,603.92,624.92,624.92,596.42,575.42,553.92,532.42,575.42,489.92,468.42,447.42,425.92,404.42,370.42,361.92,340.42,326.42,301.92,276.42,254.92,315.92,212.42,190.92,338.92,155.42,624.92,318.92,155.42,311.92,355.42,318.92,362.92,254.92,383.42,447.42,470.42,525.42,546.92,525.42,525.42,336.42,336.42,293.42,336.42,425.92,391.42,482.92,429.92,330.92,368.42}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375082445</Id>
					<Name><![CDATA[possibleLocations_TSP225_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{150.65,164.65,150.65,150.65,171.65,171.65,186.15,207.15,235.65,264.15,292.65,314.15,335.65,335.65,335.65,328.15,328.15,299.65,299.65,328.15,356.65,356.65,356.65,356.65,356.65,356.65,136.15,356.65,335.65,328.15,299.65,299.65,328.15,335.65,328.15,335.65,314.15,292.65,271.65,243.15,221.65,193.15,171.65,171.65,150.65,150.65,150.65,150.65,164.65,174.65,174.65,200.15,221.65,221.65,200.15,200.15,186.15,186.15,179.15,179.15,186.15,186.15,200.15,200.15,221.65,221.65,235.65,235.65,243.15,243.15,257.15,257.15,264.15,264.15,278.65,278.65,328.15,328.15,342.65,342.65,353.65,353.65,342.65,342.65,356.65,356.65,321.15,292.65,292.65,314.15,314.15,321.15,321.15,333.65,333.65,321.15,321.15,299.65,299.65,285.65,285.65,271.65,271.65,264.15,264.15,250.15,250.15,243.15,243.15,214.65,193.15,193.15,179.15,179.15,167.65,167.65,150.65,150.65,150.65,150.65,171.65,171.65,193.15,214.65,243.15,271.65,292.65,317.15,335.65,335.65,356.65,356.65,150.65,356.65,356.65,356.65,342.65,342.65,342.65,335.65,321.15,321.15,278.65,278.65,257.15,257.15,250.15,250.15,250.15,250.15,264.15,264.15,264.15,271.65,271.65,285.65,285.65,335.65,314.15,314.15,321.15,321.15,335.65,335.65,314.15,299.65,281.65,233.15,214.65,193.15,171.65,171.65,150.65,150.65,160.65,150.65,150.65,136.15,136.15,136.15,136.15,136.15,356.65,136.15,136.15,136.15,136.15,136.15,136.15,150.65,136.15,136.15,136.15,136.15,136.15,136.15,136.15,136.15,150.65,136.15,299.65,321.65,314.15,356.65,136.15,314.15,164.65,356.65,333.65,335.65,345.65,250.15,335.65,261.15,356.65,298.65,313.15,136.15,306.15,264.15,353.65,335.65,167.65,150.65,150.65}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375164608</Id>
					<Name><![CDATA[possibleLocations_A280_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{288,288,270,256,256,246,236,228,228,220,212,204,196,188,196,188,172,164,156,148,140,148,164,172,156,140,132,124,116,104,104,104,90,80,64,64,56,56,56,56,56,56,56,40,40,40,40,40,40,40,32,32,32,32,32,32,32,32,40,56,56,48,40,32,32,24,16,16,8,8,8,8,8,8,8,16,8,8,24,32,32,32,32,32,32,40,40,40,40,44,44,44,32,24,16,16,24,32,44,56,56,56,56,56,64,72,72,56,48,56,56,48,48,56,56,48,56,56,104,104,104,104,104,104,104,116,124,132,132,140,148,156,164,172,172,172,172,172,172,180,180,180,180,180,172,172,172,172,164,148,124,124,124,124,124,124,104,104,104,104,104,104,104,104,104,92,80,72,64,72,80,80,80,88,104,124,124,132,140,132,124,124,124,124,124,132,124,120,128,136,148,162,156,172,180,180,172,172,172,180,180,188,196,204,212,220,228,228,236,236,236,228,228,236,236,228,228,236,236,228,228,236,252,260,260,260,260,260,260,260,276,276,276,276,284,284,284,284,284,284,284,288,280,276,276,276,268,260,252,260,260,236,228,228,236,236,228,228,228,228,220,212,204,196,188,180,180,180,180,180,196,204,212,220,228,236,246,252,260,280}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375164610</Id>
					<Name><![CDATA[possibleLocations_A280_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{149,129,133,141,157,157,169,169,161,169,169,169,169,169,161,145,145,145,145,145,145,169,169,169,169,169,169,169,161,153,161,169,165,157,157,165,169,161,153,145,137,129,121,121,129,137,145,153,161,169,169,161,153,145,137,129,121,113,113,113,105,99,99,97,89,89,97,109,109,97,89,81,73,65,57,57,49,41,45,41,49,57,65,73,81,83,73,63,51,43,35,27,25,25,25,17,17,17,11,9,17,25,33,41,41,41,49,49,51,57,65,63,73,73,81,83,89,97,97,105,113,121,129,137,145,145,145,145,137,137,137,137,137,125,117,109,101,93,85,85,77,69,61,53,53,61,69,77,81,85,85,93,109,125,117,101,89,81,73,65,49,41,33,25,17,9,9,9,21,25,25,25,41,49,57,69,77,81,65,61,61,53,45,37,29,21,21,9,9,9,9,9,25,21,21,29,29,37,45,45,37,41,49,57,65,73,69,77,77,69,61,61,53,53,45,45,37,37,29,29,21,21,21,29,37,45,53,61,69,77,77,69,61,53,53,61,69,77,85,93,101,109,109,101,93,85,97,109,101,93,85,85,85,93,93,101,101,109,117,125,125,117,109,101,93,93,101,109,117,125,145,145,145,145,145,145,141,125,129,133,}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375164612</Id>
					<Name><![CDATA[possibleLocations_PR299_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{2156,2456,2355,2256,2656,2556,2975,3275,3375,3475,3575,3700,3900,3875,4275,4275,4375,4500,4450,4550,4560,4775,4710,4860,5010,5160,5310,5460,5610,6375,6525,6675,6675,6525,6875,7075,7260,7259,7625,7410,7560,7409,7560,7825,7710,7711,7875,7975,8075,8175,8275,8375,8475,8825,8820,8825,7725,7725,7475,7625,7575,7075,6825,6775,6975,6675,6200,6425,6000,6025,5675,5275,5425,5525,5025,4975,5075,5075,4775,4925,4675,4775,4425,4525,4175,4125,4275,3875,3875,3975,3975,2925,2925,4175,4325,4275,4275,4425,4525,4600,4600,4775,5175,5450,6775,7275,7075,7425,7525,7475,7775,7825,7875,8825,8725,8703,8825,8575,8725,8625,8375,8475,7975,8225,8225,8125,7975,7750,5350,5450,5450,5250,5175,5175,5075,4975,5025,4875,4175,4175,3925,3725,3325,2925,2575,2675,2275,2375,2175,2148,2249,2352,2451,2552,2651,2925,3325,3725,3925,4175,4175,4975,5075,5175,5450,5450,6125,6025,7575,7425,7925,7875,7825,7750,8125,8075,8025,8125,7975,8775,8775,8775,8775,8775,8625,8525,8075,7975,7975,7825,7575,7600,7425,7425,7425,7325,6125,6025,5375,5275,5450,5175,5075,4525,4575,4575,4425,4325,4175,4275,4275,3975,3875,2925,2925,3925,3825,3975,4325,4275,4175,4125,4500,4400,4725,4675,4775,5175,4975,5175,5025,5375,5275,6050,5908,6450,6675,6575,6975,6875,6775,7150,7150,7625,7575,7475,7425,7825,7725,7825,7725,8225,8225,8475,8325,8575,8775,8675,8575,8425,8325,8375,8175,8225,8075,8075,7925,7875,7075,7150,6975,6575,6375,5975,5325,5275,5375,5075,5204,4675,4925,4925,4775,4575,4425,4325,3825,3625,3475,3225,3325,3125,2925,2575,2675,2275,2375,2175,4775}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375164614</Id>
					<Name><![CDATA[possibleLocations_PR299_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{1639,1639,1640,1640,1640,1639,1725,1600,1600,1600,1600,1600,1625,1775,1625,1725,1675,1675,1750,1750,1565,1725,1565,1565,1565,1565,1565,1565,1565,1575,1575,1575,1725,1725,1575,1575,1575,1576,1775,1575,1575,1576,1576,1675,1575,1575,1575,1575,1575,1575,1575,1575,1575,1625,1928,1825,1825,1975,1975,1925,2075,1975,1925,2075,2075,1925,1975,2075,1975,2075,1825,1825,1825,1825,1825,2025,1925,2075,1875,1925,1950,1975,2050,2050,1950,2050,2050,1900,2075,1975,2075,1875,2150,2150,2150,2225,2325,2150,2150,2225,2325,2125,2325,2375,2225,2275,2175,2325,2375,2175,2350,2175,2350,2225,2375,2197,2425,2450,2525,2600,2600,2600,2475,2500,2600,2575,2625,2650,2400,2525,2675,2400,2475,2675,2575,2525,2675,2675,2425,2625,2450,2450,2450,2425,2525,2525,2525,2525,2525,2786,2786,2786,2785,2785,2787,2925,2900,2900,2900,2925,2725,2825,2775,2875,2825,2925,2875,2875,2875,2875,2875,2775,2925,2800,2775,2875,2775,2975,2975,2825,2925,3025,3125,3275,3225,3225,3075,3275,3075,3125,3075,3175,3275,3125,3025,3225,3025,3175,3250,3250,3025,3150,3275,3200,3125,3025,3200,3200,3200,3125,3025,3275,3275,3198,3475,3475,3475,3375,3575,3300,3400,3300,3300,3300,3525,3400,3375,3300,3325,3475,3450,3525,3525,3375,3574,3375,3325,3525,3525,3325,3425,3325,3475,3525,3425,3525,3425,3525,3525,3375,3375,3425,3325,3525,3525,3325,3700,3800,3700,3625,3625,3775,3625,3775,3775,3675,3775,3675,3675,3750,3725,3750,3750,3750,3775,3675,3675,3800,3772,3675,3800,3675,3675,3675,3675,3725,3650,3750,3750,3750,3750,3725,3725,3675,3675,3675,3675,3675,3225}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214735</Id>
					<Name><![CDATA[possibleLocations_LIN318_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{63,94,142,173,205,213,244,276,283,362,394,449,480,512,528,583,591,638,638,638,638,669,677,677,677,709,709,709,701,764,811,843,858,890,921,992,1000,1197,1228,1276,1299,1307,1362,1362,1362,1425,1425,1425,1417,1488,1488,1488,1551,1551,1551,1614,1614,1614,1732,1811,1843,1913,1921,2087,2118,2150,2189,2220,2220,2228,2244,2276,2276,2276,2315,2315,2315,2331,2346,2346,2346,2362,2402,2402,2480,2496,2528,2559,2630,2638,2756,2787,2803,2835,2866,2906,2937,2937,2945,3016,3055,3087,606,1165,1780,63,94,142,173,205,213,244,276,283,362,394,449,480,512,528,583,591,638,638,638,638,669,677,677,677,709,709,709,701,764,811,843,858,890,921,992,1000,1197,1228,1276,1299,1307,1362,1362,1362,1425,1425,1425,1417,1488,1488,1488,1551,1551,1551,1614,1614,1614,1732,1811,1843,1913,1921,2087,2118,2150,2189,2220,2220,2228,2244,2276,2276,2276,2315,2315,2315,2331,2346,2346,2346,2362,2402,2402,2480,2496,2528,2559,2630,2638,2756,2787,2803,2835,2866,2906,2937,2937,2945,3016,3055,3087,606,1165,1780,63,94,142,173,205,213,244,276,283,362,394,449,480,512,528,583,591,638,638,638,638,669,677,677,677,709,709,709,701,764,811,843,858,890,921,992,1000,1197,1228,1276,1299,1307,1362,1362,1362,1425,1425,1425,1417,1488,1488,1488,1551,1551,1551,1614,1614,1614,1732,1811,1843,1913,1921,2087,2118,2150,2189,2220,2220,2228,2244,2276,2276,2276,2315,2315,2315,2331,2346,2346,2346,2362,2402,2402,2480,2496,2528,2559,2630,2638,2756,2787,2803,2835,2866,2906,2937,2937,2945,3016,3055,3087,606,1165,1780,1417,1496,1693}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214737</Id>
					<Name><![CDATA[possibleLocations_LIN318_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{71,71,370,1276,1213,69,69,630,732,69,69,370,1276,1213,157,630,732,654,496,314,142,142,315,496,654,654,496,315,142,220,189,173,370,1276,1213,630,732,1276,1213,205,630,732,654,496,291,654,496,291,173,291,496,654,654,496,291,291,496,654,189,1276,1213,630,732,370,1276,1213,205,189,630,732,142,315,496,654,654,496,315,142,315,496,654,142,157,220,142,370,1276,1213,630,732,69,69,370,1276,1213,69,69,630,732,1276,69,69,220,370,370,1402,1402,1701,2607,2544,1400,1400,1961,2063,1400,1400,1701,2607,2544,1488,1961,2063,1985,1827,1645,1473,1473,1646,1827,1985,1985,1827,1646,1473,1551,1520,1504,1701,2607,2544,1961,2063,2607,2544,1536,1961,2063,1985,1827,1622,1985,1827,1622,1504,1622,1827,1985,1985,1827,1622,1622,1827,1985,1520,2607,2544,1961,2063,1701,2607,2544,1536,1520,1961,2063,1473,1646,1827,1985,1985,1827,1646,1473,1646,1827,1985,1473,1488,1551,1473,1701,2607,2544,1961,2063,1400,1400,1701,2607,2544,1400,1400,1961,2063,2607,1400,1400,1551,1701,1701,2733,2733,3032,3938,3875,2731,2731,3292,3394,2731,2731,3032,3938,3875,2819,3292,3394,3316,3158,2976,2804,2804,2977,3158,3316,3316,3158,2977,2804,2882,2851,2835,3032,3938,3875,3292,3394,3938,3875,2867,3292,3394,3316,3158,2953,3316,3158,2953,2835,2953,3158,3316,3316,3158,2953,2953,3158,3316,2851,3938,3875,3292,3394,3032,3938,3875,2867,2851,3292,3394,2804,2977,3158,3316,3316,3158,2977,2804,2977,3158,3316,2804,2819,2882,2804,3032,3938,3875,3292,3394,2731,2731,3032,3938,3875,2731,2731,3292,3394,3938,2731,2731,2882,3032,3032,-79,-79,4055}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214739</Id>
					<Name><![CDATA[possibleLocations_FL417_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{1.02570e+03,1.16167e+03,1.19123e+03,1.16759e+03,1.09664e+03,1.10256e+03,1.09073e+03,1.01979e+03,1.23262e+03,1.04344e+03,1.23853e+03,1.16759e+03,1.13211e+03,1.26809e+03,1.24444e+03,1.06708e+03,1.17941e+03,1.04935e+03,1.03753e+03,1.12620e+03,1.09073e+03,9.84319e+02,1.32720e+03,1.03161e+03,9.96143e+02,1.04935e+03,1.18532e+03,1.11438e+03,1.31538e+03,1.29173e+03,1.07891e+03,1.01388e+03,1.73512e+03,7.41934e+02,1.72921e+03,7.36022e+02,1.52230e+03,5.29108e+02,1.18532e+03,1.56959e+03,5.76403e+02,1.14985e+03,6.17786e+02,1.03161e+03,1.10847e+03,7.53758e+02,1.03161e+03,5.94138e+02,7.59670e+02,6.05962e+02,7.53758e+02,6.59169e+02,1.26809e+03,5.94138e+02,6.11874e+02,1.27991e+03,6.59169e+02,1.22670e+03,1.14985e+03,1.61097e+03,1.03753e+03,1.31538e+03,1.11438e+03,1.09073e+03,1.27400e+03,1.13211e+03,1.10847e+03,1.01388e+03,1.26809e+03,1.11438e+03,1.03161e+03,1.66418e+03,1.23853e+03,1.09664e+03,1.04935e+03,9.78407e+02,1.23262e+03,1.18532e+03,1.07891e+03,1.05526e+03,1.01979e+03,1.21488e+03,1.19123e+03,1.16759e+03,1.08482e+03,1.07300e+03,1.23262e+03,1.16167e+03,1.26218e+03,1.25035e+03,1.17941e+03,1.02570e+03,1.26809e+03,1.24444e+03,1.17350e+03,1.13211e+03,1.12029e+03,1.01979e+03,9.96143e+02,1.03753e+03,1.00205e+03,1.17350e+03,1.61097e+03,1.17350e+03,1.22079e+03,1.62871e+03,1.62871e+03,1.61689e+03,1.61689e+03,1.60506e+03,1.60506e+03,1.59324e+03,1.59324e+03,1.58141e+03,1.58141e+03,1.56959e+03,1.56959e+03,1.55777e+03,1.55777e+03,1.54594e+03,1.54594e+03,1.53412e+03,1.53412e+03,1.52230e+03,1.52230e+03,1.51047e+03,1.51047e+03,1.49865e+03,1.49865e+03,1.62280e+03,1.62280e+03,1.61097e+03,1.61097e+03,1.59915e+03,1.59915e+03,1.58733e+03,1.58733e+03,1.57550e+03,1.57550e+03,1.56368e+03,1.56368e+03,1.55185e+03,1.55185e+03,1.54003e+03,1.54003e+03,1.52821e+03,1.52821e+03,1.51638e+03,1.51638e+03,1.50456e+03,1.50456e+03,1.49274e+03,1.49274e+03,6.47346e+02,6.47346e+02,6.35522e+02,6.35522e+02,6.23699e+02,6.23699e+02,6.11875e+02,6.11875e+02,6.00051e+02,6.00051e+02,5.88228e+02,5.88228e+02,5.76404e+02,5.76404e+02,5.64581e+02,5.64581e+02,5.52757e+02,5.52757e+02,5.40933e+02,5.40933e+02,5.29109e+02,5.29109e+02,5.17286e+02,5.17286e+02,6.41434e+02,6.41434e+02,6.29611e+02,6.29611e+02,6.17787e+02,6.17787e+02,6.05963e+02,6.05963e+02,5.94140e+02,5.94140e+02,5.82316e+02,5.82316e+02,5.70492e+02,5.70492e+02,5.58669e+02,5.58669e+02,5.46845e+02,5.46845e+02,5.35022e+02,5.35022e+02,5.23198e+02,5.23198e+02,5.11374e+02,5.11374e+02,1.62871e+03,1.62871e+03,1.61689e+03,1.61689e+03,1.60506e+03,1.60506e+03,1.59324e+03,1.59324e+03,1.58141e+03,1.58141e+03,1.56959e+03,1.56959e+03,1.55777e+03,1.55777e+03,1.54594e+03,1.54594e+03,1.53412e+03,1.53412e+03,1.52230e+03,1.52230e+03,1.51047e+03,1.51047e+03,1.49865e+03,1.49865e+03,1.62280e+03,1.62280e+03,1.61097e+03,1.61097e+03,1.59915e+03,1.59915e+03,1.58733e+03,1.58733e+03,1.57550e+03,1.57550e+03,1.56368e+03,1.56368e+03,1.55185e+03,1.55185e+03,1.54003e+03,1.54003e+03,1.52821e+03,1.52821e+03,1.51638e+03,1.51638e+03,1.50456e+03,1.50456e+03,1.49274e+03,1.49274e+03,6.47346e+02,6.47346e+02,6.35522e+02,6.35522e+02,6.23699e+02,6.23699e+02,6.11875e+02,6.11875e+02,6.00051e+02,6.00051e+02,5.88228e+02,5.88228e+02,5.76404e+02,5.76404e+02,5.64581e+02,5.64581e+02,5.52757e+02,5.52757e+02,5.40933e+02,5.40933e+02,5.29109e+02,5.29109e+02,5.17286e+02,5.17286e+02,6.41434e+02,6.41434e+02,6.29611e+02,6.29611e+02,6.17787e+02,6.17787e+02,6.05963e+02,6.05963e+02,5.94140e+02,5.94140e+02,5.82316e+02,5.82316e+02,5.70492e+02,5.70492e+02,5.58669e+02,5.58669e+02,5.46845e+02,5.46845e+02,5.35022e+02,5.35022e+02,5.23198e+02,5.23198e+02,5.11374e+02,5.11374e+02,1.88883e+03,1.87701e+03,1.85336e+03,1.84154e+03,1.82971e+03,1.78242e+03,1.74695e+03,1.72330e+03,1.71147e+03,1.67600e+03,1.65236e+03,9.07466e+02,8.95642e+02,8.71994e+02,8.60171e+02,8.48347e+02,8.01053e+02,7.65581e+02,7.41934e+02,7.30111e+02,6.94640e+02,6.70992e+02,1.87109e+03,1.80015e+03,1.77651e+03,1.75286e+03,8.89730e+02,8.18788e+02,7.95141e+02,7.71494e+02,1.87701e+03,1.85336e+03,1.84154e+03,1.74695e+03,1.72330e+03,1.69965e+03,8.95642e+02,8.71994e+02,8.60171e+02,7.65581e+02,7.41934e+02,7.18287e+02,1.89474e+03,1.87109e+03,1.85927e+03,1.82380e+03,1.81198e+03,1.80015e+03,1.77651e+03,1.76468e+03,1.75286e+03,9.13377e+02,8.89730e+02,8.77906e+02,8.42435e+02,8.30612e+02,8.18788e+02,7.95141e+02,7.83317e+02,7.71494e+02,1.88883e+03,1.87701e+03,1.85336e+03,1.84154e+03,1.82971e+03,1.78242e+03,1.74695e+03,1.72330e+03,1.71147e+03,1.67600e+03,1.65236e+03,9.07466e+02,8.95642e+02,8.71994e+02,8.60171e+02,8.48347e+02,8.01053e+02,7.65581e+02,7.41934e+02,7.30111e+02,6.94640e+02,6.70992e+02,1.87109e+03,1.80015e+03,1.77651e+03,1.75286e+03,8.89730e+02,8.18788e+02,7.95141e+02,7.71494e+02,1.87701e+03,1.85336e+03,1.84154e+03,1.74695e+03,1.72330e+03,1.69965e+03,8.95642e+02,8.71994e+02,8.60171e+02,7.65581e+02,7.41934e+02,7.18287e+02,1.89474e+03,1.87109e+03,1.85927e+03,1.82380e+03,1.81198e+03,1.80015e+03,1.77651e+03,1.76468e+03,1.75286e+03,9.13377e+02,8.89730e+02,8.77906e+02,8.42435e+02,8.30612e+02,8.18788e+02,7.95141e+02,7.83317e+02,7.71494e+02}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214741</Id>
					<Name><![CDATA[possibleLocations_FL417_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{1.97130e+03,1.96539e+03,1.95949e+03,1.95949e+03,1.95949e+03,1.95358e+03,1.95358e+03,1.95358e+03,1.94177e+03,1.94177e+03,1.93587e+03,1.93587e+03,1.93587e+03,1.92996e+03,1.92996e+03,1.92996e+03,1.92406e+03,1.92406e+03,1.92406e+03,1.91815e+03,1.91815e+03,1.91815e+03,1.90634e+03,1.90634e+03,1.90634e+03,1.90044e+03,1.89453e+03,1.89453e+03,1.88272e+03,1.88272e+03,1.88272e+03,1.87682e+03,1.74691e+03,1.74691e+03,1.74100e+03,1.74100e+03,1.72329e+03,1.72329e+03,1.64652e+03,1.52252e+03,1.52252e+03,1.44575e+03,1.44575e+03,1.42213e+03,1.41622e+03,1.41622e+03,1.41032e+03,1.41032e+03,1.39851e+03,1.39851e+03,1.27450e+03,1.25088e+03,1.24498e+03,1.24498e+03,1.22726e+03,1.22136e+03,1.15640e+03,1.00287e+03,9.96967e+02,9.73347e+02,8.02101e+02,7.96196e+02,7.96196e+02,7.96196e+02,7.90290e+02,7.90290e+02,7.90290e+02,7.90290e+02,7.84386e+02,7.84386e+02,7.84386e+02,7.78481e+02,7.78481e+02,7.78481e+02,7.78481e+02,7.78481e+02,7.72576e+02,7.72576e+02,7.72576e+02,7.72576e+02,7.72576e+02,7.66670e+02,7.66670e+02,7.66670e+02,7.66670e+02,7.66670e+02,7.60765e+02,7.60765e+02,7.54861e+02,7.54861e+02,7.54861e+02,7.54861e+02,7.48955e+02,7.48955e+02,7.48955e+02,7.43050e+02,7.43050e+02,7.25335e+02,7.25335e+02,7.19430e+02,7.19430e+02,5.59994e+02,5.48184e+02,5.48184e+02,5.36374e+02,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04806e+03,2.03625e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,2.04216e+03,2.03035e+03,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.70262e+02,1.58452e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,1.64357e+02,1.52547e+02,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04806e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.04216e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03625e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,2.03035e+03,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.70261e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.64357e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.58451e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02,1.52546e+02}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214743</Id>
					<Name><![CDATA[possibleLocations_GR431_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{37.44,38.43,41.11,37.23,36.32,36.43,37.13,37.53,38.21,39.28,41.23,41.38,40.24,41.39,43.15,43.22,38.54,39.34,42.30,44.50,43.36,43.18,43.42,43.42,42.42,45.50,45.26,45.45,45.10,48.24,48.05,47.13,47.23,49.30,48.52,49.15,47.19,48.41,48.35,49.36,50.38,50.50,50.38,51.03,51.13,51.26,51.55,52.22,52.05,53.13,50.23,50.43,50.50,51.29,51.27,51.30,52.30,53.25,53.30,53.23,53.50,54.59,55.57,55.53,56.28,57.10,60.09,62.01,51.54,52.40,53.20,54.35,55.00,64.09,64.11,76.34,70.40,68.26,65.01,61.30,60.27,60.10,63.25,60.23,58.58,59.55,57.43,55.36,58.25,59.20,57.38,56.09,55.24,55.40,53.04,53.33,54.20,54.05,51.57,52.24,52.07,52.31,50.47,50.44,50.56,51.12,51.17,51.28,51.28,51.32,51.31,51.19,50.58,51.29,51.19,50.50,51.03,49.14,50.07,49.25,49.48,49.27,49.03,48.46,49.01,48.08,46.12,46.31,46.57,47.33,47.23,47.16,47.48,48.18,48.13,47.05,45.03,45.28,45.27,45.27,45.40,44.25,44.29,43.46,43.55,39.20,41.54,40.51,41.27,41.07,40.28,38.11,37.30,38.07,35.54,53.24,54.23,53.08,52.25,51.46,52.15,53.09,51.06,50.16,50.03,51.15,49.45,50.05,49.50,49.12,48.09,48.43,47.30,47.32,46.05,46.15,45.45,46.47,47.10,45.48,45.39,44.26,44.11,46.03,45.20,45.48,43.31,43.52,44.50,42.38,41.59,41.20,42.41,42.09,43.13,42.30,39.36,40.38,38.15,37.58,35.20,35.10,68.58,64.34,59.55,59.25,56.57,54.43,54.41,53.54,49.50,50.26,46.28,55.45,56.20,55.45,53.12,51.40,50.00,48.27,44.36,47.14,48.44,46.21,41.43,40.11,40.23,58.00,56.51,67.27,69.20,55.00,55.02,56.01,49.50,43.15,41.20,39.40,38.35,43.48,52.16,47.55,52.03,62.13,64.45,53.01,59.34,50.17,50.35,48.27,46.58,43.10,41.01,38.25,39.56,38.43,39.45,39.55,37.55,37.01,36.12,34.44,33.30,33.53,31.57,32.50,32.04,31.46,24.28,21.30,21.27,15.23,14.48,12.45,14.32,23.37,25.18,25.17,26.13,24.38,29.20,30.30,33.21,35.28,36.20,38.05,37.16,35.40,34.19,30.20,32.40,29.36,30.17,36.18,34.20,31.32,34.31,33.36,31.35,31.25,30.11,30.12,27.42,25.22,24.52,30.19,28.40,26.17,26.55,26.28,25.20,25.36,22.32,23.02,21.09,20.30,18.58,17.23,17.42,15.21,12.59,13.05,10.49,9.56,6.56,27.43,27.28,23.43,22.20,22.00,16.47,18.47,19.52,17.58,21.02,16.28,16.04,10.45,11.33,13.45,5.25,3.10,1.17,3.35,-0.57,-2.55,-6.10,-6.54,-7.48,-7.15,-8.39,-10.10,-3.20,1.33,4.56,-0.30,-5.07,1.29,-3.43,-5.40,7.04,10.18,10.42,14.35,22.17,22.38,25.03,29.40,36.03,34.15,30.39,29.39,25.05,23.06,26.06,30.36,32.03,31.14,34.48,36.06,37.55,39.08,39.55,38.53,41.48,45.45,39.01,37.33,35.06,43.03,39.43,38.15,35.42,35.10,36.34,35.00,34.40,34.24,32.48,31.36,26.13,13.28,-2.32,-4.12,-9.30,-12.28,-31.56,-34.55,-37.49,-42.53,-33.52,-27.28,-19.16,-23.42,-45.52,-43.32,-41.18,-36.52,-21.08,-14.16,-18.08,-22.16,-9.26,-0.32,11.35,21.19,1.52,-9.45,-17.32,-25.04,-27.07}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375214745</Id>
					<Name><![CDATA[possibleLocations_GR431_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{-25.40,-9.08,-8.36,-5.59,-6.18,-4.25,-3.41,-4.46,-0.29,-0.22,2.11,-0.53,-3.41,-4.43,-2.58,-8.23,1.26,2.39,1.31,-0.34,1.26,5.24,7.15,7.23,9.27,1.16,4.24,4.51,5.43,-4.29,-1.41,-1.33,0.41,0.08,2.20,4.02,5.01,6.12,7.45,6.09,5.34,4.20,3.04,3.43,4.25,5.28,4.28,4.54,5.08,6.33,-4.10,-1.54,-0.08,-3.13,-2.35,-0.10,-1.50,-2.55,-2.15,-1.30,-1.35,-1.35,-3.13,-4.15,-3.00,-2.04,-1.09,-6.46,-8.28,-8.38,-6.15,-5.55,-7.19,-21.51,-51.44,-68.47,23.42,17.25,25.28,23.45,22.17,24.58,10.25,5.20,5.45,10.45,11.58,13.00,15.37,18.03,18.18,10.13,10.23,12.35,8.49,9.59,10.08,12.07,7.37,9.44,11.38,13.24,6.05,7.05,6.59,6.47,7.17,7.01,7.13,7.13,7.28,9.29,11.01,11.58,12.20,12.55,13.44,6.59,8.40,8.43,9.56,11.04,8.24,9.11,12.06,11.34,6.09,6.38,7.26,7.35,8.32,11.24,13.02,14.18,16.20,15.27,7.40,9.12,11.00,12.21,13.46,8.57,11.20,11.15,12.28,9.00,12.29,14.17,15.34,16.52,17.15,15.33,15.06,13.21,14.31,14.32,18.40,18.00,16.55,19.30,21.00,23.09,17.00,19.00,19.58,22.35,13.23,14.26,18.17,16.37,17.07,21.15,19.05,21.38,18.13,20.09,21.13,23.36,27.35,24.09,25.37,26.06,28.39,14.31,14.27,15.58,16.27,18.25,20.30,18.07,21.26,19.50,23.19,24.45,27.55,27.28,19.56,22.56,21.44,23.43,25.09,33.22,33.05,40.32,30.15,24.45,24.06,20.30,25.19,27.34,24.00,30.31,30.44,37.35,44.00,49.08,50.09,39.10,36.15,34.59,33.32,39.42,44.25,48.03,44.49,44.30,49.51,56.15,60.36,63.58,88.06,73.24,82.55,92.50,73.10,76.57,69.18,66.48,68.48,87.35,104.20,106.53,113.30,129.49,177.29,158.39,150.48,127.32,137.02,135.06,142.42,131.56,28.58,27.09,32.52,35.30,37.02,41.17,40.14,35.18,37.10,36.43,36.18,35.30,35.56,35.00,34.46,35.14,39.36,39.12,39.49,44.12,42.57,45.12,49.08,58.35,55.18,51.32,50.35,46.43,47.59,47.47,44.25,44.28,43.08,46.18,49.36,51.26,47.04,48.16,51.38,52.32,57.05,59.36,62.12,65.30,69.12,73.04,74.18,73.05,71.29,67.00,68.52,68.22,67.03,78.02,77.13,73.02,75.49,80.21,83.00,85.07,88.22,72.37,79.06,85.50,72.50,78.29,83.18,75.10,77.35,80.17,78.41,78.07,79.51,85.19,89.39,90.25,91.50,96.05,96.10,98.59,102.08,102.36,105.51,107.36,108.13,106.40,104.55,100.31,100.20,101.42,103.51,98.40,100.21,104.45,106.48,107.36,110.22,112.45,115.13,123.35,114.35,110.20,114.55,117.09,119.24,124.51,128.12,132.45,125.36,123.54,122.34,121.00,114.09,120.17,121.30,91.09,103.41,108.52,104.04,106.34,102.40,113.16,119.17,114.17,118.47,121.28,113.39,120.19,112.30,117.12,116.25,121.35,123.27,126.41,125.45,126.58,129.03,141.21,140.07,140.53,139.46,136.55,136.39,135.45,135.30,132.27,129.55,130.33,127.40,144.47,140.42,152.12,147.10,130.50,115.50,138.35,144.58,147.19,151.13,153.02,146.48,133.53,170.30,172.38,174.47,174.46,-175.12,-170.42,178.25,166.27,159.57,166.55,165.23,-157.52,-157.20,-139.00,-149.34,-130.06,-109.22}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375294009</Id>
					<Name><![CDATA[possibleLocations_D493_X]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>30</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{0.00000e+00,1.11630e+03,1.35760e+03,1.14810e+03,1.18620e+03,1.20520e+03,1.23700e+03,1.30050e+03,1.16080e+03,1.17350e+03,1.22430e+03,1.35130e+03,1.73230e+03,1.74500e+03,1.76400e+03,1.76400e+03,1.73230e+03,1.74500e+03,1.64970e+03,1.75770e+03,2.29740e+03,2.21490e+03,2.22760e+03,2.18310e+03,2.61490e+03,2.50700e+03,2.34820e+03,2.22120e+03,2.20850e+03,2.20220e+03,2.21490e+03,2.02440e+03,2.04340e+03,1.94820e+03,1.94180e+03,1.84660e+03,1.75770e+03,1.80210e+03,1.83390e+03,1.73230e+03,2.04340e+03,2.04980e+03,1.99900e+03,1.96090e+03,2.05610e+03,2.01170e+03,2.04340e+03,1.84660e+03,1.82120e+03,1.84660e+03,1.81480e+03,1.66880e+03,1.85930e+03,1.98630e+03,2.01170e+03,1.94820e+03,1.89100e+03,2.01170e+03,2.03710e+03,2.05610e+03,1.89740e+03,1.89740e+03,1.91640e+03,2.05610e+03,2.15770e+03,1.63700e+03,1.70690e+03,1.76400e+03,1.70690e+03,1.76400e+03,1.87200e+03,1.85290e+03,1.87200e+03,1.89740e+03,2.21490e+03,2.19580e+03,2.24660e+03,1.89100e+03,2.20220e+03,1.90370e+03,1.87200e+03,2.01170e+03,1.90370e+03,1.95450e+03,2.05610e+03,2.09420e+03,2.19580e+03,2.58950e+03,2.60860e+03,2.50700e+03,2.89430e+03,2.89430e+03,2.90700e+03,3.02770e+03,2.79270e+03,2.22760e+03,2.58320e+03,2.59590e+03,2.50700e+03,2.72290e+03,2.61490e+03,2.88800e+03,3.21180e+03,3.14200e+03,2.75460e+03,2.45620e+03,2.57050e+03,2.72290e+03,3.36420e+03,2.90070e+03,3.13560e+03,2.71020e+03,2.71650e+03,2.88800e+03,2.84990e+03,2.29740e+03,2.60860e+03,3.22450e+03,2.69110e+03,2.87530e+03,2.50060e+03,2.43080e+03,2.87530e+03,3.12930e+03,2.58320e+03,2.49430e+03,2.78000e+03,2.33550e+03,2.61490e+03,2.92610e+03,2.80540e+03,2.58320e+03,2.82450e+03,2.86260e+03,2.79910e+03,2.69110e+03,2.75460e+03,2.91340e+03,2.34820e+03,2.90700e+03,3.13560e+03,2.92610e+03,3.43410e+03,2.88160e+03,2.60220e+03,2.71020e+03,2.79270e+03,2.82450e+03,2.42440e+03,2.86890e+03,3.43410e+03,2.61490e+03,3.07850e+03,2.58950e+03,2.48790e+03,2.73560e+03,3.44680e+03,3.35150e+03,2.62760e+03,2.69750e+03,2.48790e+03,2.68480e+03,2.46250e+03,3.13560e+03,3.39600e+03,2.74830e+03,2.72290e+03,3.23090e+03,2.97050e+03,2.47520e+03,2.51330e+03,2.92610e+03,2.49430e+03,2.61490e+03,2.51970e+03,2.58950e+03,3.40870e+03,3.64360e+03,2.78640e+03,2.65940e+03,2.49430e+03,2.95780e+03,3.45950e+03,3.05310e+03,2.77370e+03,2.71020e+03,3.23720e+03,3.32610e+03,2.73560e+03,2.49430e+03,3.26900e+03,3.30710e+03,3.36420e+03,2.67210e+03,3.35150e+03,3.47220e+03,2.86890e+03,2.81180e+03,3.35150e+03,3.29440e+03,2.54510e+03,3.11020e+03,3.16100e+03,3.28170e+03,3.33880e+03,2.99590e+03,3.19910e+03,3.00230e+03,2.63400e+03,2.50700e+03,2.96420e+03,3.05940e+03,3.09750e+03,3.64360e+03,2.80540e+03,2.58320e+03,3.07850e+03,2.89430e+03,3.14830e+03,3.21820e+03,3.19910e+03,2.72920e+03,2.95150e+03,2.43080e+03,2.50700e+03,3.59920e+03,3.13560e+03,3.07850e+03,3.05940e+03,2.77370e+03,2.91340e+03,3.30710e+03,3.13560e+03,3.01500e+03,2.42440e+03,2.83080e+03,3.29440e+03,3.12930e+03,3.37690e+03,2.61490e+03,2.93240e+03,3.04620e+03,3.07220e+03,3.09820e+03,3.12420e+03,3.15020e+03,3.17620e+03,3.20220e+03,3.22820e+03,3.25420e+03,3.28020e+03,3.30620e+03,3.33220e+03,3.35820e+03,2.72290e+03,3.06570e+03,3.11120e+03,3.13720e+03,3.16320e+03,3.18920e+03,3.21520e+03,3.24120e+03,3.26720e+03,3.29320e+03,3.34520e+03,2.43710e+03,2.96420e+03,2.74190e+03,2.43080e+03,3.41350e+03,2.99750e+03,2.82450e+03,3.02020e+03,3.39070e+03,3.41350e+03,2.83720e+03,2.60860e+03,2.99750e+03,3.10470e+03,3.13070e+03,3.15670e+03,3.18270e+03,3.20870e+03,3.23470e+03,3.26070e+03,3.28670e+03,3.31270e+03,3.41350e+03,3.07870e+03,3.11770e+03,3.14370e+03,3.16970e+03,3.19570e+03,3.22170e+03,3.24770e+03,3.27370e+03,2.90070e+03,2.69110e+03,2.99750e+03,3.33220e+03,2.43710e+03,3.39070e+03,3.30950e+03,3.02020e+03,2.58320e+03,3.07870e+03,3.41350e+03,3.28350e+03,3.12750e+03,2.99750e+03,3.33220e+03,3.23720e+03,3.19910e+03,3.10150e+03,3.39070e+03,3.44040e+03,2.95150e+03,3.02020e+03,3.30950e+03,3.41350e+03,3.07870e+03,3.16100e+03,2.99750e+03,3.33220e+03,2.93880e+03,2.87530e+03,3.10150e+03,3.39070e+03,3.13990e+03,3.02020e+03,3.30950e+03,3.41350e+03,3.07870e+03,2.79910e+03,3.59920e+03,3.33220e+03,2.99750e+03,3.10150e+03,3.39070e+03,3.26900e+03,2.91970e+03,2.83720e+03,3.02020e+03,3.30950e+03,2.87530e+03,3.07870e+03,3.41350e+03,3.48490e+03,2.97050e+03,2.99750e+03,3.33220e+03,2.91340e+03,3.10150e+03,3.39070e+03,3.30950e+03,3.24360e+03,3.02020e+03,2.95780e+03,3.15470e+03,3.07870e+03,3.41350e+03,3.61190e+03,3.33220e+03,2.99750e+03,3.10150e+03,3.39070e+03,3.30950e+03,3.02020e+03,2.84990e+03,2.87530e+03,2.90070e+03,3.54200e+03,3.41350e+03,3.07870e+03,3.17370e+03,3.33220e+03,2.99750e+03,3.10150e+03,3.39070e+03,3.30950e+03,3.02020e+03,2.76730e+03,3.07870e+03,3.41350e+03,2.60220e+03,3.12750e+03,3.28350e+03,3.33220e+03,2.99750e+03,2.88160e+03,2.79270e+03,2.55780e+03,3.10150e+03,3.39070e+03,3.47850e+03,3.02020e+03,2.91970e+03,2.81810e+03,2.51970e+03,3.07870e+03,3.41350e+03,3.29320e+03,3.26720e+03,3.24120e+03,3.21520e+03,3.18920e+03,3.16320e+03,3.13720e+03,2.99750e+03,3.33220e+03,2.88160e+03,3.09820e+03,3.12420e+03,3.15020e+03,3.17620e+03,3.20220e+03,3.22820e+03,3.25420e+03,3.28020e+03,3.30620e+03,3.41350e+03,2.58950e+03,2.57050e+03,2.99750e+03,3.02020e+03,3.39070e+03,3.45950e+03,3.48490e+03,2.65940e+03,3.41350e+03,2.93880e+03,2.99750e+03,3.06570e+03,3.11770e+03,3.14370e+03,3.16970e+03,3.19570e+03,3.22170e+03,3.24770e+03,3.27370e+03,3.29970e+03,3.34520e+03,2.92610e+03,3.05270e+03,3.07870e+03,3.10470e+03,3.13070e+03,3.15670e+03,3.18270e+03,3.20870e+03,3.23470e+03,3.26070e+03,3.28670e+03,3.31270e+03,3.33870e+03,3.36470e+03,2.74190e+03,2.86260e+03,3.06580e+03,3.03400e+03,2.87530e+03,2.79270e+03,2.90070e+03,2.83720e+03,2.94510e+03,2.86260e+03,2.93880e+03,3.07210e+03,3.05940e+03,3.03400e+03,3.06580e+03,3.09120e+03,3.20550e+03,3.40870e+03,3.45950e+03,3.51030e+03,3.36420e+03,3.38330e+03,3.49760e+03,3.39600e+03,3.29440e+03,3.51660e+03,3.21820e+03,3.56740e+03,3.55470e+03,3.39600e+03,3.54840e+03,3.52930e+03,3.40870e+03,3.47220e+03,3.69440e+03,3.74520e+03,3.74520e+03}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516375294011</Id>
					<Name><![CDATA[possibleLocations_D493_Y]]></Name>
					<Description><![CDATA[Sources of the position of the cities : http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/ch130.tsp.gz]]></Description>
					<X>220</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="true">
						<Type><![CDATA[double[]]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[{0.00000e+00,1.55520e+03,1.47900e+03,1.77110e+03,1.79650e+03,1.88540e+03,1.99340e+03,2.00610e+03,2.02510e+03,2.03780e+03,2.05050e+03,2.24100e+03,2.13310e+03,2.19020e+03,2.29180e+03,2.34260e+03,2.39340e+03,2.41880e+03,2.43150e+03,2.52040e+03,1.77110e+03,1.42820e+03,1.33930e+03,1.32030e+03,1.11070e+03,1.16150e+03,9.52000e+02,1.00910e+03,1.08530e+03,1.13610e+03,1.17420e+03,1.12340e+03,1.30120e+03,1.30760e+03,1.39010e+03,1.41550e+03,1.36470e+03,1.35200e+03,1.26310e+03,1.25040e+03,1.58060e+03,1.74570e+03,1.80290e+03,1.81560e+03,1.82190e+03,1.82830e+03,1.85370e+03,1.78380e+03,1.82830e+03,1.86640e+03,1.65050e+03,1.80920e+03,2.16480e+03,2.13310e+03,2.17750e+03,2.19660e+03,2.24740e+03,2.27280e+03,2.30450e+03,2.35530e+03,2.41250e+03,2.45690e+03,2.46960e+03,2.46960e+03,2.13940e+03,2.69820e+03,2.70460e+03,2.74900e+03,2.77440e+03,2.79980e+03,3.06650e+03,3.00300e+03,2.99670e+03,2.99670e+03,2.97130e+03,2.93950e+03,2.88870e+03,2.86970e+03,2.84430e+03,2.81890e+03,2.81890e+03,2.76170e+03,2.69820e+03,2.58390e+03,2.57760e+03,2.56490e+03,2.47600e+03,2.99030e+03,2.99030e+03,3.00300e+03,3.04750e+03,3.00300e+03,2.97130e+03,3.04750e+03,2.81250e+03,2.81250e+03,2.79980e+03,2.77440e+03,2.77440e+03,2.75540e+03,2.74900e+03,2.73000e+03,2.73000e+03,2.71730e+03,2.69820e+03,2.69820e+03,2.62200e+03,2.62200e+03,2.62200e+03,2.61570e+03,2.60300e+03,2.59660e+03,2.54580e+03,2.53310e+03,2.51410e+03,2.51410e+03,2.49500e+03,2.48870e+03,2.47600e+03,2.43790e+03,2.41880e+03,2.39980e+03,2.39980e+03,2.36800e+03,2.36800e+03,2.36800e+03,2.36170e+03,2.35530e+03,2.31720e+03,2.30450e+03,2.29180e+03,2.29180e+03,2.28550e+03,2.27910e+03,2.26010e+03,2.26010e+03,2.25370e+03,2.25370e+03,2.24100e+03,2.23470e+03,2.23470e+03,2.22830e+03,2.20290e+03,2.19020e+03,2.19020e+03,2.16480e+03,2.14580e+03,2.13310e+03,2.10770e+03,2.10130e+03,2.10130e+03,2.08860e+03,2.08230e+03,2.07590e+03,2.06320e+03,2.06320e+03,2.04420e+03,2.03150e+03,2.01880e+03,2.00610e+03,1.99340e+03,1.97430e+03,1.96800e+03,1.96800e+03,1.96800e+03,1.96160e+03,1.96160e+03,1.95530e+03,1.94260e+03,1.93620e+03,1.92350e+03,1.91720e+03,1.91080e+03,1.90450e+03,1.89180e+03,1.89180e+03,1.89180e+03,1.89180e+03,1.88540e+03,1.88540e+03,1.87910e+03,1.87910e+03,1.87910e+03,1.86640e+03,1.86640e+03,1.86640e+03,1.85370e+03,1.85370e+03,1.84730e+03,1.83460e+03,1.83460e+03,1.83460e+03,1.83460e+03,1.82830e+03,1.82190e+03,1.82190e+03,1.81560e+03,1.80920e+03,1.80290e+03,1.79650e+03,1.79650e+03,1.77750e+03,1.77750e+03,1.77750e+03,1.75840e+03,1.75840e+03,1.72030e+03,1.72030e+03,1.72030e+03,1.70760e+03,1.70760e+03,1.70760e+03,1.70760e+03,1.70760e+03,1.70130e+03,1.69490e+03,1.69490e+03,1.68860e+03,1.68220e+03,1.66320e+03,1.66320e+03,1.66320e+03,1.65050e+03,1.64410e+03,1.63140e+03,1.63140e+03,1.62510e+03,1.62510e+03,1.62510e+03,1.62510e+03,1.61870e+03,1.61870e+03,1.60600e+03,1.60600e+03,1.59970e+03,1.59330e+03,1.59330e+03,1.58060e+03,1.56790e+03,1.56790e+03,1.54890e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.54730e+03,1.53620e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52460e+03,1.52350e+03,1.51080e+03,1.50440e+03,1.50440e+03,1.49860e+03,1.49210e+03,1.48540e+03,1.47910e+03,1.47910e+03,1.47260e+03,1.46630e+03,1.46630e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.46610e+03,1.44660e+03,1.44660e+03,1.44330e+03,1.44330e+03,1.44330e+03,1.44330e+03,1.44330e+03,1.44330e+03,1.44330e+03,1.44090e+03,1.44090e+03,1.44010e+03,1.44010e+03,1.43460e+03,1.43360e+03,1.42710e+03,1.42710e+03,1.42190e+03,1.42060e+03,1.42060e+03,1.41730e+03,1.41730e+03,1.41410e+03,1.41410e+03,1.40920e+03,1.40920e+03,1.40760e+03,1.40760e+03,1.40280e+03,1.40280e+03,1.40110e+03,1.40110e+03,1.39460e+03,1.39460e+03,1.39010e+03,1.38810e+03,1.38810e+03,1.38380e+03,1.38380e+03,1.38160e+03,1.38160e+03,1.37540e+03,1.37510e+03,1.37510e+03,1.36860e+03,1.36860e+03,1.36470e+03,1.36470e+03,1.36210e+03,1.36210e+03,1.35560e+03,1.35560e+03,1.35200e+03,1.35200e+03,1.35200e+03,1.34910e+03,1.34910e+03,1.34570e+03,1.34260e+03,1.34260e+03,1.33930e+03,1.33930e+03,1.33610e+03,1.33610e+03,1.33300e+03,1.32960e+03,1.32960e+03,1.32310e+03,1.32310e+03,1.32310e+03,1.32030e+03,1.32030e+03,1.31660e+03,1.31660e+03,1.31390e+03,1.31010e+03,1.31010e+03,1.30360e+03,1.30360e+03,1.29710e+03,1.29710e+03,1.29490e+03,1.29490e+03,1.29490e+03,1.29490e+03,1.29060e+03,1.29060e+03,1.28850e+03,1.28410e+03,1.28410e+03,1.27760e+03,1.27760e+03,1.27110e+03,1.27110e+03,1.26950e+03,1.26460e+03,1.26460e+03,1.26310e+03,1.26130e+03,1.26130e+03,1.25810e+03,1.25810e+03,1.25680e+03,1.25680e+03,1.25680e+03,1.25160e+03,1.25160e+03,1.25040e+03,1.24510e+03,1.24410e+03,1.24410e+03,1.24410e+03,1.23860e+03,1.23860e+03,1.23530e+03,1.23530e+03,1.23530e+03,1.23530e+03,1.23530e+03,1.23530e+03,1.23530e+03,1.23210e+03,1.23210e+03,1.22500e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21260e+03,1.21230e+03,1.21230e+03,1.20610e+03,1.19960e+03,1.19960e+03,1.19960e+03,1.19960e+03,1.19330e+03,1.18660e+03,1.18040e+03,1.18010e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.15410e+03,1.14250e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.13130e+03,1.12980e+03,1.12340e+03,1.09800e+03,1.09170e+03,1.07900e+03,1.04090e+03,1.02820e+03,1.02180e+03,1.01550e+03,1.00910e+03,8.31300e+02,9.32900e+02,9.52000e+02,9.64700e+02,9.71000e+02,9.90100e+02,9.83700e+02,8.75800e+02,9.20200e+02,1.01550e+03,1.01550e+03,1.02820e+03,1.02820e+03,1.05360e+03,1.05360e+03,1.07260e+03,1.09800e+03,1.10440e+03,1.12340e+03,1.12340e+03,1.14250e+03,1.15520e+03,1.16150e+03,1.17420e+03,1.30120e+03,1.27580e+03,1.02180e+03}]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
			</Variables>
			<AgentLinks>
				<AgentLink>
					<Id>1428936935026</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1429199040981</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Shapes>
				<Text>
					<Id>1429273037186</Id>
					<Name><![CDATA[cityText]]></Name>
					<X>-5</X><Y>-6</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[switch( get_Main().mouseMode){
case 0:	salesmanViewArea.navigateTo();
		break;
case 1: if(getIndex() > 0){ //if mouseMode==deleteCity and not the depot
			visitingSalesman.eraseRoute();
			owningSalesman.ownedCities.remove( visitingSalesman.ownedCities.indexOf(this) );
			visitingSalesman.allocatedCities.remove( visitingSalesman.allocatedCities.indexOf(this) );
			visitingSalesman.route.remove( visitingSalesman.route.indexOf(this));
			visitingSalesman.solve();
			get_Main().remove_cities(this);
		}//if(mouseMode)
		break;
}]]></OnClickCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA["?"]]></Text>
					<TextCode><![CDATA[getIndex()]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>18</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Shapes>
			<Controls>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1437576202885</Id>
					<Name><![CDATA[radio]]></Name>
					<X>20</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="720" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[Salesman previousSalesman = visitingSalesman;
//Remove this city from the previous salesman
if(previousSalesman.route.contains(this))
	previousSalesman.route.remove( previousSalesman.route.indexOf(this) );
if(previousSalesman.allocatedCities.contains(this))
	previousSalesman.allocatedCities.remove( previousSalesman.allocatedCities.indexOf(this) );
switch( value ){
	default: visitingSalesman = get_Main().salesmen.get( value );
}
//cityText.setColor( visitingSalesman.color );
visitingSalesman.allocatedCities.add( this );

if(get_Main().solveNdrawAutomatically){
	previousSalesman.eraseRoute();
	visitingSalesman.eraseRoute();
	
	if(get_Main().selectedSalesman >=0){
		int selectedSalesman = get_Main().selectedSalesman;
		get_Main().selectedSalesman = previousSalesman.getIndex();
		get_Main().solve();
		get_Main().selectedSalesman = visitingSalesman.getIndex();
		get_Main().solve();
		get_Main().selectedSalesman = selectedSalesman;
	}
	else {
		get_Main().solve();
	}
	previousSalesman.drawRoute();
	visitingSalesman.drawRoute();
}]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[SMan0]]></Button>
						<Button><![CDATA[SMan1]]></Button>
						<Button><![CDATA[SMan2]]></Button>
						<Button><![CDATA[SMan3]]></Button>
						<Button><![CDATA[SMan4]]></Button>
						<Button><![CDATA[SMan5]]></Button>
						<Button><![CDATA[SMan6]]></Button>
						<Button><![CDATA[SMan7]]></Button>
						<Button><![CDATA[SMan8]]></Button>
						<Button><![CDATA[SMan9]]></Button>
						<LinkTo>false</LinkTo>
					</ExtendedProperties>
				</Control>
			</Controls>
			<Areas>
				<Area>
					<Id>1437655506051</Id>
					<Name><![CDATA[salesmanViewArea]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Title><![CDATA[]]></Title>
					<Width>100</Width>
					<Height>100</Height>
					<AlignTo>TOP_LEFT</AlignTo>
					<Scaling>NONE</Scaling>
					<Zoom>1.0</Zoom>
				</Area>
			</Areas>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1429198016242</Id>
			<Name><![CDATA[Salesman]]></Name>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<Import><![CDATA[import ilog.concert.*;									// import CPLEX
import ilog.cplex.*;									// import CPLEX

import org.ojalgo.OjAlgoUtils;							//import ojalgo
import org.ojalgo.netio.BasicLogger;					//import ojalgo
import org.ojalgo.optimisation.Expression;				//import ojalgo
import org.ojalgo.optimisation.ExpressionsBasedModel;	//import ojalgo
import org.ojalgo.optimisation.Optimisation;			//import ojalgo
import org.ojalgo.optimisation.Variable;				//import ojalgo
import java.math.BigDecimal;							//import ojalgo
import com.mysema.query.BooleanBuilder;
import tsp.Main._cities_Population;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1456145103515</Id>
				<Name><![CDATA[1456145103515]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameters:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[2]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[KPH]]></Unit>
				</VelocityCode>
				<OnArrival><![CDATA[//if(get_Main().debugOutput)	traceln(this+" on arrival to target location");
//if( !(this.getX() == nextCity2visit.getX() && this.getY() == nextCity2visit.getY()) ){
	if(route.indexOf( nextCity2visit ) < route.size()-1){
		//traceln(this+" 1 nextCity2visit="+nextCity2visit+" route.indexOf( nextCity2visit )="+route.indexOf( nextCity2visit ));
		nextCity2visit = route.get( route.indexOf( nextCity2visit ) + 1 );
	}
	else{
		//traceln(this+" 2 nextCity2visit="+nextCity2visit);
		nextCity2visit = route.get(0);
	}
	moveTo( nextCity2visit );
//}]]></OnArrival>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[MINUTE]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1456214400000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1456145103517</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>EXPLICITLY_DEFINED</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>KILOMETER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1429198016241</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1429198644433</Id>
					<Name><![CDATA[nextCity2visit]]></Name>
					<X>220</X><Y>-20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Agent]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1445506503896</Id>
					<Name><![CDATA[maxReallocations]]></Name>
					<X>30</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[get_Main().maxReallocations]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1459955691607</Id>
					<Name><![CDATA[city_proposed_to_guest]]></Name>
					<X>629</X><Y>219</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1459955697324</Id>
					<Name><![CDATA[guest]]></Name>
					<X>163</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Salesman]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1460042107126</Id>
					<Name><![CDATA[propCities]]></Name>
					<Description><![CDATA[Protocol 'Auc' only needs a vector (the other lines in 'propCities' are requested by P2P protocols).

In a dynamic environment, whenever a salesman loses a city which has left the city, or earns a new city which is added, this matrix should be reinitialised in order to keep proposing every city to all other salesmen. (In addition, my statecharts should be modified in order to leave the final state when such an event occurs.)]]></Description>
					<X>30</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1463671579829</Id>
					<Name><![CDATA[city_proposed_by_host]]></Name>
					<X>439</X><Y>219</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1463671579835</Id>
					<Name><![CDATA[host]]></Name>
					<X>359</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Salesman]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1463781480940</Id>
					<Name><![CDATA[possible_saving_from_giving]]></Name>
					<X>829</X><Y>219</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1464277680904</Id>
					<Name><![CDATA[city_proposed_to_host]]></Name>
					<X>439</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1464277735041</Id>
					<Name><![CDATA[OLD_P2Pswap_possible_saving_of_host]]></Name>
					<X>1370</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1464353949293</Id>
					<Name><![CDATA[OLD_P2Pswap_possible_saving_of_guest]]></Name>
					<X>1370</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1464363617041</Id>
					<Name><![CDATA[city_proposed_by_guest]]></Name>
					<X>629</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1465902816269</Id>
					<Name><![CDATA[my_computation_time]]></Name>
					<X>220</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1465919550657</Id>
					<Name><![CDATA[number_of_messages_received]]></Name>
					<X>829</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1467212576165</Id>
					<Name><![CDATA[list_of_bids]]></Name>
					<X>800</X><Y>582</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City[]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1479393920992</Id>
					<Name><![CDATA[duration_of_last_call_to_the_solver]]></Name>
					<X>220</X><Y>-80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1484584557880</Id>
					<Name><![CDATA[myCentralPlanner]]></Name>
					<X>220</X><Y>-120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[CentralAuthority]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[get_Main().centralPlanner.get(0)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1491996311523</Id>
					<Name><![CDATA[CNP_city_to_get_rid_of]]></Name>
					<X>500</X><Y>474</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1492003481805</Id>
					<Name><![CDATA[CNP_number_of_replies]]></Name>
					<X>500</X><Y>491</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1492010492542</Id>
					<Name><![CDATA[list_of_savings]]></Name>
					<X>940</X><Y>580</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1499960142701</Id>
					<Name><![CDATA[P2P_index_of_hosted_interaction]]></Name>
					<X>800</X><Y>754</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1500305504220</Id>
					<Name><![CDATA[P2P_end_date_of_computation]]></Name>
					<X>800</X><Y>774</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1432932603116</Id>
					<Name><![CDATA[color]]></Name>
					<X>220</X><Y>-60</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[java.awt.Color]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<NumericType><![CDATA[double]]></NumericType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[black]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1432932603111</Id>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1429199427574</Id>
					<Name><![CDATA[shapeLines]]></Name>
					<X>220</X><Y>-40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[java.util.ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[ShapeLine]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1433941759634</Id>
					<Name><![CDATA[ownedCities]]></Name>
					<Description><![CDATA[Cities "owned" by this salesman]]></Description>
					<X>163</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[java.util.ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[City]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1433952823722</Id>
					<Name><![CDATA[route]]></Name>
					<Description><![CDATA["cities2visit" given in the order to be visited]]></Description>
					<X>359</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[Agent]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1438097580310</Id>
					<Name><![CDATA[allocatedCities]]></Name>
					<Description><![CDATA[Cities still to be visited by this salesman (unordered, conversely to route -- quite redundant with route, should thus be removed)]]></Description>
					<X>30</X><Y>220</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[City]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1492016138074</Id>
					<Name><![CDATA[route_found_by_solve_modifiedTSPcplex]]></Name>
					<Description><![CDATA["cities2visit" given in the order to be visited]]></Description>
					<X>359</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[Agent]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1492073947016</Id>
					<Name><![CDATA[route_if_exchange_accepted_as_guest]]></Name>
					<X>500</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[Agent]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
			</Variables>
			<StatechartElements>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1463581758147</Id>
					<Name><![CDATA[P2PWR0_initialisation]]></Name>
					<X>360</X><Y>930</Y>
					<Label><X>50</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="20">
						<EntryAction><![CDATA[propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
if( get_Main().mechanismStartTime == -1)	//if this salesman is the first to initialise this statechart
	get_Main().mechanismStartTime = System.currentTimeMillis();
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1463581758149</Id>
					<Name><![CDATA[P2PWR1_propose_city_to_guest]]></Name>
					<Description><![CDATA[This looks like 2-opt, except that we swap 2 cities between salesmen, instead of swapping 2 edges within a route


/*for(Salesman salesman : get_Main().salesmen){
	trace("\n"+this + " " + salesman+" ");
	boolean[] previouslyProposedCities_temp = previouslyProposedCities[salesman.getIndex()];
	for(City city : get_Main().cities){
		if(previouslyProposedCities_temp[city.getIndex()])
			trace("\tTr");
		else
			trace("\tf");
		}
}
trace("\nAllocated "+this);
for(Agent city : citiesAllocated)
		trace("\t"+city.getIndex());
trace("\nRoute     "+this);
for(Agent city : route)
		trace("\t"+city.getIndex());
traceln();*/

double currentRouteLength = routeLength();

if(P2P_city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)citiesAllocated.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = citiesAllocated.size();
	
	double shortestRouteLength = Double.MAX_VALUE;

	for(City city : citiesAllocated_backup){ //Find the city to give which has never been proposed to anybody - This city corresponds to the shortest route if this city was not to be visited by a salesman
		if(city.getIndex()>0){
			Salesman availableSalesman = null;
			for(Salesman salesman : get_Main().salesmen){ //check if at least one salesman has not been proposed this city
				if( !salesman.equals(this)) {
					boolean[] previouslyProposedCities_temp = P2P_previously_proposed_cities[ salesman.getIndex() ];
					if( previouslyProposedCities_temp[city.getIndex()] == false){
						availableSalesman = salesman;	//a possibleReceiver has been found
						break;
					}//if(previouslyProposedCities_temp)
				}//if(salesman)
			}//for(salesman)

			if( availableSalesman != null ){	//otherwise transition 'P2P2_no_more_exchanges_to_propose" terminates this statechard
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
				citiesAllocated.remove( city );
				solve();
				if( routeLength() < shortestRouteLength ) {
					P2P_possible_receiving_guest = availableSalesman;
					P2P_city_proposed_to_guest = city;
					shortestRouteLength = routeLength();
				}//if(routeLength)
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
			}//if(availableSalesman)
		}//if(city)
	}//for(city)

	if( P2P_city_proposed_to_guest != null){
		//traceln(this + " **PROPOSES** " + P2P2_cityProposedToSalesmanA + " to " + P2P2_possibleReceiver_A + " routeLen without exchange="+currentRouteLength+" routeLen with exchange="+shortestRouteLength);
		send( new P2P_offer_proposition(P2P_city_proposed_to_guest, (currentRouteLength-shortestRouteLength), this ), P2P_possible_receiving_guest );
		P2P_previously_proposed_cities[ P2P_possible_receiving_guest.getIndex() ][ P2P_city_proposed_to_guest.getIndex() ] = true;
	}//if(currentlyProposedCity) (2d one)
	route = route_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></Description>
					<X>360</X><Y>980</Y>
					<Label><X>20</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="20">
						<EntryAction><![CDATA[if(city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = allocatedCities.size();
	
/*	for(int salesman=0; salesman<get_Main().salesmen.size(); salesman++){
		trace("\npreviously_proposed_cities salesman"+salesman);
		for(int city=0; city<get_Main().cities.size(); city++){
			trace("\t"+P2P_previously_proposed_cities[salesman][city]);
		}
	}
	traceln();
	for(City city : citiesAllocated)
		trace(city+"\t");
	traceln();
	*/
	//Try to remove cities previously proposed to salesmen from citiesAllocated, in order to decrease the time of CPLEX optimisation
	for(City city : citiesAllocated_backup){
		int nb_salesmen_who_have_been_proposed_this_city = 0;
		for(Salesman salesman : get_Main().salesmen)
			if( salesman != this )
			{
				if( propCities[salesman.getIndex()][city.getIndex()] == true)
					nb_salesmen_who_have_been_proposed_this_city++;
				if (nb_salesmen_who_have_been_proposed_this_city >= get_Main().salesmen.size()-1 )
					allocatedCities.remove( city );
			}
	}

	solve_modifiedTSPcplex(true, false, true, false);

	if( city_proposed_to_guest != null){
		//"P2P_city_proposed_to_guest" is assigned a city by "solve_TSPcplex_giver()", but the possible receiver needs to be found by the following for():
		for(Salesman salesman : get_Main().salesmen)
			if(salesman != this){
				if(get_Main().debugOutput)	traceln(this+" 1 P2P_city_proposed_to_guest="+guest+": "+city_proposed_to_guest);
				if( ! propCities[salesman.getIndex()][city_proposed_to_guest.getIndex()] )
					guest = salesman;
			}
		assert guest != null;
	
		if(get_Main().debugOutput)	traceln(this + "1 **PROPOSES** " + city_proposed_to_guest + " to " + guest + " P2P_possible_saving_from_giving_to_guest="+possible_saving_from_giving);
		send( new P2P_offer_proposition(city_proposed_to_guest, possible_saving_from_giving, this ), guest );
		propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
	}//if( P2P_city_proposed_to_guest != null){
	route = route_backup;
	allocatedCities = citiesAllocated_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="FinalState" ParentState="ROOT_NODE">
					<Id>1463581758151</Id>
					<Name><![CDATA[P2PWR_FinalState]]></Name>
					<X>380</X><Y>1040</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Properties>	
						<Action><![CDATA[/*if(P2P_city_proposed_to_guest == null || nbReallocations() >= maxReallocations){	//same condition a transition P2PWR_no_more_exchanges_to_propose.... I don't understand: there is no problem with standard experiment, but this transition is fired with parameter variation experiments?!?!?!
	trace("self"+get_Main().salesmen.size()+"\t"+get_Main().cities.size()+"\t=\t");
	double totalTotalComputationTime = 0;
	for(Salesman salesman : get_Main().salesmen ){
		totalTotalComputationTime += salesman.totalComputationTime;
		trace(salesman.totalComputationTime+"+");
	}
	trace("=\t"+totalTotalComputationTime+"\t");
	double totalRouteLength = 0;
	double currentRouteLength = 0;
	for(Salesman salesman : get_Main().salesmen){
		currentRouteLength = salesman.routeLength();
		totalRouteLength += currentRouteLength;
		trace((int)currentRouteLength+"+");
	}
	trace("=\t"+(int)totalRouteLength+"\t"+maxReallocations+"\t");
	int total_number_of_messages_received = 0;
	for(Salesman salesman : get_Main().salesmen){
		total_number_of_messages_received += salesman.number_of_messages_received;
		trace(salesman.number_of_messages_received+"+");
	}
	traceln("=\t"+total_number_of_messages_received);
}*/]]></Action>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464610581039</Id>
					<Name><![CDATA[OLD_P2Pswap_5_propose_city_to_guest]]></Name>
					<Description><![CDATA[This looks like 2-opt, except that we swap 2 cities between salesmen, instead of swapping 2 edges within a route]]></Description>
					<X>1730</X><Y>610</Y>
					<Label><X>15</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[get_Main().consoleOutput = false;
double currentRouteLength = routeLength();
trace("5 " + this+" routeLen="+currentRouteLength+" ");
for(Agent city : allocatedCities)
	trace(city+"\t");

ArrayList<City>	citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
ArrayList<Agent> route_backup			= (ArrayList)route.clone();
allocatedCities.remove( city_proposed_to_guest );
allocatedCities.add( city_proposed_by_guest );

solve();
trace(" -> " + routeLength());
for(Agent city : allocatedCities)
	trace(city+"\t");
traceln();

if( currentRouteLength-routeLength() >= 0 ){	//send the proposition 'P2P_city_proposed_to_guest' found in "P2Pswap_1_invite_guest"
	traceln("5 " + this + " was proposed " + city_proposed_by_guest + " and PROPOSES " + city_proposed_to_guest + " to " + guest+" currentRouteLength="+currentRouteLength+ " routeLength()="+routeLength());
	send( new P2P_offer_proposition(city_proposed_to_guest, possible_saving_from_giving, this ), guest );
	propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
}//if(currentlyProposedCity)
else{	//the proposition 'P2P_city_proposed_to_guest' found in "P2Pswap_1_invite_guest" is not worth being sent
	traceln("5 " + this + " was proposed " + city_proposed_by_guest + " and does NOT PROPOSE anything"+" currentRouteLength="+currentRouteLength+ " routeLength()="+routeLength());
	send( new P2P_offer_proposition(null, Double.MIN_VALUE, this ), guest );
}
allocatedCities = citiesAllocated_backup;
route = route_backup;
get_Main().consoleOutput = true;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464610581041</Id>
					<Name><![CDATA[OLD_P2Pswap_1_invite_guest]]></Name>
					<Description><![CDATA[double currentRouteLength = routeLength();
traceln(this.getIndex());
if(P2P_city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)citiesAllocated.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = citiesAllocated.size();
	
	double shortestRouteLength = Double.MAX_VALUE;

	for(City city : citiesAllocated_backup){ //Find the city to give which has never been proposed to anybody - This city corresponds to the shortest route if this city was not to be visited by a salesman
		if(city.getIndex()>0){
			Salesman availableSalesman = null;
			for(Salesman salesman : get_Main().salesmen){ //check if at least one salesman has not been proposed this city
				if( !salesman.equals(this)) {
					boolean[] previouslyProposedCities_temp = P2P_previously_proposed_cities[ salesman.getIndex() ];
					if( previouslyProposedCities_temp[city.getIndex()] == false){
						availableSalesman = salesman;	//a possibleReceiver has been found
						break;
					}//if(previouslyProposedCities_temp)
				}//if(salesman)
			}//for(salesman)

			if( availableSalesman != null ){	//otherwise transition 'P2P2_no_more_exchanges_to_propose" terminates this statechard
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
				citiesAllocated.remove( city );
				solve();
				if( routeLength() < shortestRouteLength ) {
					P2P_possible_receiving_guest = availableSalesman;
					P2P_city_proposed_to_guest = city;
					shortestRouteLength = routeLength();
				}//if(routeLength)
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
			}//if(availableSalesman)
		}//if(city)
	}//for(city)

	if( P2P_city_proposed_to_guest != null){
		//traceln("1 " + this + " **PROPOSES** " + P2P2_cityProposedToSalesmanA + " to " + P2P2_possibleReceiverA + " routeLen without exchange="+currentRouteLength+" routeLen with exchange="+shortestRouteLength);
		//send( new P2P2_offer_proposition(P2P2_cityProposedToSalesmanA, (currentRouteLength-shortestRouteLength), this ), P2P2_possibleReceiverA );
		
		P2P_possible_saving_from_giving_to_guest = currentRouteLength - shortestRouteLength;
		P2Pswap_nego_invitation message = new P2Pswap_nego_invitation(this);
		traceln("1 " + this + " invites " + P2P_possible_receiving_guest);
		send( message, P2P_possible_receiving_guest);
		//traceln(this+" invites "+P2P_possible_receiving_guest + " and proposes " + P2P_city_proposed_to_guest);
/*		for(Salesman salesman : get_Main().salesmen)
			if( !salesman.equals(this) ){
				boolean[] previouslyProposedCities_temp = P2P_previously_proposed_cities[ salesman.getIndex() ];
				for(int pos=0; pos<previouslyProposedCities_temp.length ; pos++)
					if( previouslyProposedCities_temp[pos] )
						trace("\t"+pos+"Tr");
					else
						trace("\t"+pos+"f");
				traceln();
			}		*/
		P2P_previously_proposed_cities[ P2P_possible_receiving_guest.getIndex() ][ P2P_city_proposed_to_guest.getIndex() ] = true;
	}//if(currentlyProposedCity) (2d one)
	route = route_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)]]></Description>
					<X>1520</X><Y>600</Y>
					<Label><X>30</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[if(city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = allocatedCities.size();
	
/*	for(int salesman=0; salesman<get_Main().salesmen.size(); salesman++){
		trace("\npreviously_proposed_cities salesman"+salesman);
		for(int city=0; city<get_Main().cities.size(); city++){
			trace("\t"+P2P_previously_proposed_cities[salesman][city]);
		}
	}
	traceln();
	for(City city : citiesAllocated)
		trace(city+"\t");
	traceln();
	*/
	//Try to remove cities previously proposed to salesmen from citiesAllocated, in order to decrease the time of CPLEX optimisation
	for(City city : citiesAllocated_backup){
		int nb_salesmen_who_have_been_proposed_this_city = 0;
		for(Salesman salesman : get_Main().salesmen)
			if( salesman != this )
			{
				if( propCities[salesman.getIndex()][city.getIndex()] == true)
					nb_salesmen_who_have_been_proposed_this_city++;
				if (nb_salesmen_who_have_been_proposed_this_city >= get_Main().salesmen.size()-1 )
					allocatedCities.remove( city );
			}
	}

	solve_modifiedTSPcplex(true, false, true, false);

	if( city_proposed_to_guest != null){
		//"P2P_city_proposed_to_guest" is assigned a city by "solve_TSPcplex_giver()", but the possible receiver needs to be found by the following for():
		for(Salesman salesman : get_Main().salesmen)
			if(salesman != this){
				//traceln("P2P_city_proposed_to_guest="+P2P_city_proposed_to_guest);
				if( ! propCities[salesman.getIndex()][city_proposed_to_guest.getIndex()] )
					guest = salesman;
			}
		assert guest != null;
		
		//The following 3 lines are the only difference with P2PWR_1_propose_city_to_guest	
		CNP_P2Pswap_nego_invitation message = new CNP_P2Pswap_nego_invitation(this);
		traceln("1 " + this + " invites " + guest);
		send( message, guest);
	
	}//if( P2P_city_proposed_to_guest != null){
	route = route_backup;
	allocatedCities = citiesAllocated_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="FinalState" ParentState="ROOT_NODE">
					<Id>1464610581043</Id>
					<Name><![CDATA[P2P3self_finalState]]></Name>
					<X>1620</X><Y>720</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Properties>	
						<Action><![CDATA[if(get_Main().selectedTspSolver==0)
	 trace("2i\t" + get_Main().salesmen.size()+"\t"+get_Main().cities.size()+"\t=\t" + (System.currentTimeMillis()-get_Main().mechanismStartTime)+"\t");
else if(get_Main().selectedTspSolver==1)
	 trace("c\t" + get_Main().salesmen.size()+"\t"+get_Main().cities.size()+"\t=\t" + (System.currentTimeMillis()-get_Main().mechanismStartTime)+"\t");
else trace("o\t" + get_Main().salesmen.size()+"\t"+get_Main().cities.size()+"\t=\t" + (System.currentTimeMillis()-get_Main().mechanismStartTime)+"\t");
double totalRouteLength = 0;
double currentRouteLength = 0;
for(Salesman salesman : get_Main().salesmen){
	currentRouteLength = salesman.routeLength();
	totalRouteLength += currentRouteLength;
	trace((int)currentRouteLength+"+");
}
traceln("=\t"+(int)totalRouteLength);]]></Action>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464610581045</Id>
					<Name><![CDATA[OLD_P2Pswap_3_accept_nego_by_proposing_city_to_host]]></Name>
					<X>1310</X><Y>620</Y>
					<Label><X>0</X><Y>20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[ArrayList<City>	citiesAllocated_backup	= (ArrayList)allocatedCities.clone();

//Try to remove cities previously proposed to salesmen from citiesAllocated, in order to decrease the time of CPLEX optimisation
for(City city : citiesAllocated_backup){
	int nb_salesmen_who_have_been_proposed_this_city = 0;
	if( propCities[ host.getIndex() ][city.getIndex()] == true)
		allocatedCities.remove( city );
}

if( allocatedCities.size() > 2 ){
	solve_modifiedTSPcplex(false, false, true, false);
	traceln("3 " + this + " accepts nego with " + host + " and proposes " + city_proposed_to_host+" and would save " + OLD_P2Pswap_possible_saving_of_host);
	send(new CNP_P2Pswap_nego_reply(city_proposed_to_host, OLD_P2Pswap_possible_saving_of_host, this), host);
	propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ] = true;
}
else if( allocatedCities.size() == 2 ){ //if it only remains the depot and one city, then propose this city
	city_proposed_to_host=allocatedCities.get(1);
	double route_length = routeLength();
	route.remove(city_proposed_to_host);
	OLD_P2Pswap_possible_saving_of_host = route_length - routeLength();
	traceln("3 " + this + " accepts nego with " + host + " and proposes his last city " + city_proposed_to_host+" and would save " + OLD_P2Pswap_possible_saving_of_host);
	send(new CNP_P2Pswap_nego_reply(city_proposed_to_host, OLD_P2Pswap_possible_saving_of_host, this), host);
	propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ] = true;
}
else {	//decline negotiation (=propose nothing)
	traceln("3 " + this + " declines nego with " + host);
	double route_length = routeLength();
	route.remove(city_proposed_to_host);
	OLD_P2Pswap_possible_saving_of_host = route_length - routeLength();
	send(new CNP_P2Pswap_nego_reply(null, 0, this), host);
}

allocatedCities = citiesAllocated_backup ;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464688386588</Id>
					<Name><![CDATA[A0_initialisation]]></Name>
					<X>790</X><Y>289</Y>
					<Label><X>70</X><Y>11</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[possible_saving_from_giving = Double.MIN_VALUE;
city_proposed_to_guest = null;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464688386590</Id>
					<Name><![CDATA[A1_wait_for_RFP]]></Name>
					<X>790</X><Y>339</Y>
					<Label><X>65</X><Y>11</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1464782725388</Id>
					<Name><![CDATA[OLD_P2Pswap_0_initialisation]]></Name>
					<X>1520</X><Y>540</Y>
					<Label><X>40</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
if( get_Main().mechanismStartTime == -1)	//if this salesman is the first to initialise this statechart
	get_Main().mechanismStartTime = System.currentTimeMillis();
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1465569762917</Id>
					<Name><![CDATA[A4_propose_a_city_to_give]]></Name>
					<X>790</X><Y>389</Y>
					<Label><X>25</X><Y>11</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[assert possible_saving_from_giving == Double.MIN_VALUE;
assert city_proposed_to_guest == null;

//remove previously proposed cities from 'citiesAllocated' in order not to propose them again
ArrayList<City>citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
/*trace("4 " + this + " citiesAllocated ==");
for(Agent city : citiesAllocated)
	trace(city+"\t");
traceln();*/

solve_modifiedTSPcplex(true, true, false, false);	// P2P_possible_saving_from_giving_to_guest and P2P_city_proposed_to_guest are chosen by solve_TSPcplex_giver()

get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[getIndex()] = duration_of_last_call_to_the_solver ;
//if(get_Main().debugOutput)	traceln("4 "+this+" remainingComputationTime="+get_Main().remainingComputationTime+" duration_of_last_call_to_solve="+duration_of_last_call_to_the_solver);

//send( new P2P_offer_proposition(P2P_city_proposed_to_guest, P2P_possible_saving_from_giving_to_guest, this), get_Main().auctioneer);
P2P_offer_proposition message =  new P2P_offer_proposition(city_proposed_to_guest, possible_saving_from_giving, this);

//if(get_Main().debugOutput)	traceln("4   " + this + " PROPOSES "+city_proposed_to_guest+" for P2P_possible_saving_from_giving_to_guest="+possible_saving_from_giving +" msg="+message);
send( message, myCentralPlanner);

/*trace("4 " + this + " citiesAllocated=");
for(Agent city : citiesAllocated)
	trace(city+"\t");
traceln();*/

allocatedCities = citiesAllocated_backup;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1466168614696</Id>
					<Name><![CDATA[P2PWR_0_initialisation_OLD]]></Name>
					<X>1550</X><Y>350</Y>
					<Label><X>40</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
if( get_Main().mechanismStartTime == -1)	//if this salesman is the first to initialise this statechart
	get_Main().mechanismStartTime = System.currentTimeMillis();
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1466168614700</Id>
					<Name><![CDATA[P2PWR_1_propose_city_to_guest_OLD]]></Name>
					<Description><![CDATA[This looks like 2-opt, except that we swap 2 cities between salesmen, instead of swapping 2 edges within a route


/*for(Salesman salesman : get_Main().salesmen){
	trace("\n"+this + " " + salesman+" ");
	boolean[] previouslyProposedCities_temp = previouslyProposedCities[salesman.getIndex()];
	for(City city : get_Main().cities){
		if(previouslyProposedCities_temp[city.getIndex()])
			trace("\tTr");
		else
			trace("\tf");
		}
}
trace("\nAllocated "+this);
for(Agent city : citiesAllocated)
		trace("\t"+city.getIndex());
trace("\nRoute     "+this);
for(Agent city : route)
		trace("\t"+city.getIndex());
traceln();*/

double currentRouteLength = routeLength();

if(P2P_city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)citiesAllocated.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = citiesAllocated.size();
	
	double shortestRouteLength = Double.MAX_VALUE;

	for(City city : citiesAllocated_backup){ //Find the city to give which has never been proposed to anybody - This city corresponds to the shortest route if this city was not to be visited by a salesman
		if(city.getIndex()>0){
			Salesman availableSalesman = null;
			for(Salesman salesman : get_Main().salesmen){ //check if at least one salesman has not been proposed this city
				if( !salesman.equals(this)) {
					boolean[] previouslyProposedCities_temp = P2P_previously_proposed_cities[ salesman.getIndex() ];
					if( previouslyProposedCities_temp[city.getIndex()] == false){
						availableSalesman = salesman;	//a possibleReceiver has been found
						break;
					}//if(previouslyProposedCities_temp)
				}//if(salesman)
			}//for(salesman)

			if( availableSalesman != null ){	//otherwise transition 'P2P2_no_more_exchanges_to_propose" terminates this statechard
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
				citiesAllocated.remove( city );
				solve();
				if( routeLength() < shortestRouteLength ) {
					P2P_possible_receiving_guest = availableSalesman;
					P2P_city_proposed_to_guest = city;
					shortestRouteLength = routeLength();
				}//if(routeLength)
				citiesAllocated = (ArrayList)citiesAllocated_backup.clone();
			}//if(availableSalesman)
		}//if(city)
	}//for(city)

	if( P2P_city_proposed_to_guest != null){
		//traceln(this + " **PROPOSES** " + P2P2_cityProposedToSalesmanA + " to " + P2P2_possibleReceiver_A + " routeLen without exchange="+currentRouteLength+" routeLen with exchange="+shortestRouteLength);
		send( new P2P_offer_proposition(P2P_city_proposed_to_guest, (currentRouteLength-shortestRouteLength), this ), P2P_possible_receiving_guest );
		P2P_previously_proposed_cities[ P2P_possible_receiving_guest.getIndex() ][ P2P_city_proposed_to_guest.getIndex() ] = true;
	}//if(currentlyProposedCity) (2d one)
	route = route_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></Description>
					<X>1550</X><Y>410</Y>
					<Label><X>15</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<EntryAction><![CDATA[/*for(Salesman salesman : get_Main().salesmen){
	trace("\n"+this + " " + salesman+" ");
	boolean[] previouslyProposedCities_temp = previouslyProposedCities[salesman.getIndex()];
	for(City city : get_Main().cities){
		if(previouslyProposedCities_temp[city.getIndex()])
			trace("\tTr");
		else
			trace("\tf");
		}
}
trace("\nAllocated "+this);
for(Agent city : citiesAllocated)
		trace("\t"+city.getIndex());
trace("\nRoute     "+this);
for(Agent city : route)
		trace("\t"+city.getIndex());
traceln();*/

double currentRouteLength = routeLength();

if(city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = allocatedCities.size();
	
	double shortestRouteLength = Double.MAX_VALUE;
	
	for(City city : citiesAllocated_backup){ //Find the city to give which has never been proposed to anybody - This city corresponds to the shortest route if this city was not to be visited by a salesman
		if(city.getIndex()>0){
			Salesman availableSalesman = null;
			for(Salesman salesman : get_Main().salesmen){ //check if at least one salesman has not been proposed this city
				if( !salesman.equals(this)) {
					boolean[] previouslyProposedCities_temp = propCities[ salesman.getIndex() ];
					if( previouslyProposedCities_temp[city.getIndex()] == false){
						availableSalesman = salesman;	//a possibleReceiver has been found
						break;
					}//if(previouslyProposedCities_temp)
				}//if(salesman)
			}//for(salesman)

			if( availableSalesman != null ){	//otherwise transition 'P2P2_no_more_exchanges_to_propose" terminates this statechard
				allocatedCities = (ArrayList)citiesAllocated_backup.clone();
				allocatedCities.remove( city );
				solve();
				if( routeLength() < shortestRouteLength ) {
					guest = availableSalesman;
					city_proposed_to_guest = city;
					shortestRouteLength = routeLength();
				}//if(routeLength)
				allocatedCities = (ArrayList)citiesAllocated_backup.clone();
			}//if(availableSalesman)
		}//if(city)
	}//for(city)

	if( city_proposed_to_guest != null){
		//traceln(this + " **PROPOSES** " + P2P2_cityProposedToSalesmanA + " to " + P2P2_possibleReceiver_A + " routeLen without exchange="+currentRouteLength+" routeLen with exchange="+shortestRouteLength);
		send( new P2P_offer_proposition(city_proposed_to_guest, (currentRouteLength-shortestRouteLength), this ), guest );
		propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
	}//if(currentlyProposedCity) (2d one)
	route = route_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="FinalState" ParentState="ROOT_NODE">
					<Id>1466168614702</Id>
					<Name><![CDATA[P2PWR_FinalState_OLD]]></Name>
					<X>1650</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Properties>	
						<Action><![CDATA[if(city_proposed_to_guest == null || nbReallocations() >= maxReallocations){	//same condition a transition P2PWR_no_more_exchanges_to_propose.... I don't understand: there is no problem with standard experiment, but this transition is fired with parameter variation experiments?!?!?!
	if(get_Main().selectedTspSolver==0)
		trace("i\t");
	else if(get_Main().selectedTspSolver==1)
		 trace("c\t");
	else trace("o\t");
	trace(get_Main().salesmen.size()+"\t"+get_Main().cities.size()+"\t=\t");
	double totalTotalComputationTime = 0;
	for(Salesman salesman : get_Main().salesmen ){
		totalTotalComputationTime += salesman.my_computation_time;
		trace(salesman.my_computation_time+"+");
	}
	trace("=\t"+totalTotalComputationTime+"\t");
	double totalRouteLength = 0;
	double currentRouteLength = 0;
	for(Salesman salesman : get_Main().salesmen){
		currentRouteLength = salesman.routeLength();
		totalRouteLength += currentRouteLength;
		trace((int)currentRouteLength+"+");
	}
	trace("=\t"+(int)totalRouteLength+"\t"+maxReallocations+"\t");
	int total_number_of_messages_received = 0;
	for(Salesman salesman : get_Main().salesmen){
		total_number_of_messages_received += salesman.number_of_messages_received;
		trace(salesman.number_of_messages_received+"+");
	}
	traceln("=\t"+total_number_of_messages_received);
}]]></Action>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1466616362408</Id>
					<Name><![CDATA[A10_bid_on_every_proposed_city]]></Name>
					<X>790</X><Y>469</Y>
					<Label><X>5</X><Y>11</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[if(get_Main().debugOutput){
	trace("10   " + this + " has ");
	for(Agent city : route)
		trace(city+" ");
	traceln(" and proposes " + city_proposed_to_guest+" = "+routeLength());
}
ArrayList<City>citiesAllocated_first_backup	= (ArrayList)allocatedCities.clone();
ArrayList<Agent>route_backup	= (ArrayList)route.clone();
allocatedCities.remove( city_proposed_to_guest );
ArrayList<City>citiesAllocated_second_backup	= (ArrayList)allocatedCities.clone();
solve();
get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[get_Main().salesmen.size()+getIndex()] += duration_of_last_call_to_the_solver ;
//if(get_Main().debugOutput)	traceln("10 "+this+" remainingComputationTime="+get_Main().remainingComputationTime+" duration_of_last_call_to_solve="+duration_of_last_call_to_the_solver);
double currentRouteLength = routeLength();
if(get_Main().debugOutput){
	trace("10   " + this + " route length on ");
	for(Agent city : route)
		trace(city+" ");
	traceln(" = "+currentRouteLength);
}

double[] myBids = new double[ list_of_bids.length ];

for( int salesman=0 ; salesman<list_of_bids.length ; salesman++)
//salesman!=getIndex()  && list_of_bids[ salesman ] != city_proposed_to_guest
	if( list_of_bids[ salesman ] != city_proposed_to_guest	){
		assert list_of_bids[ salesman ] != null;
		allocatedCities.add( list_of_bids[ salesman ] );
		solve();
		
		get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[get_Main().salesmen.size()+getIndex()] += duration_of_last_call_to_the_solver ;
		//if(get_Main().debugOutput)	traceln("10 "+this+" remainingComputationTime="+get_Main().remainingComputationTime+" duration_of_last_call_to_solve="+duration_of_last_call_to_the_solver);
		
		if(get_Main().debugOutput){
			trace("10   " + this + " tries on "+list_of_bids[ salesman ]+" that is:");
			for(Agent city : route)
				trace(city+" ");
			traceln(" = "+routeLength());
		}
		myBids[ salesman ] = routeLength() - currentRouteLength ;
		//traceln("10 " + this + " currentRouteLength="+currentRouteLength+", length with " +  Auc_bids[ salesman ] + " instead of " + P2P_city_proposed_to_guest +" = " + routeLength());
		allocatedCities = (ArrayList)citiesAllocated_second_backup.clone();
	}//if() & for()
Message message = new Message(myBids, this);
send( message, myCentralPlanner );
if(get_Main().debugOutput)	traceln("10  " + this+" is sending "+message);


allocatedCities = citiesAllocated_first_backup;
route = route_backup;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1468857137624</Id>
					<Name><![CDATA[P2P6_host_proposes_city_to_guest]]></Name>
					<Description><![CDATA[This looks like 2-opt, except that we swap 2 cities between salesmen, instead of swapping 2 edges within a route

if(P2P_city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)citiesAllocated.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = citiesAllocated.size();
	
/*	for(int salesman=0; salesman<get_Main().salesmen.size(); salesman++){
		trace("\npreviously_proposed_cities salesman"+salesman);
		for(int city=0; city<get_Main().cities.size(); city++){
			trace("\t"+P2P_previously_proposed_cities[salesman][city]);
		}
	}
	traceln();
	for(City city : citiesAllocated)
		trace(city+"\t");
	traceln();
	*/
	//Try to remove cities previously proposed to salesmen from citiesAllocated, in order to decrease the time of CPLEX optimisation
	for(City city : citiesAllocated_backup){
		int nb_salesmen_who_have_been_proposed_this_city = 0;
		for(Salesman salesman : get_Main().salesmen)
			if( salesman != this )
			{
				if( P2P_previously_proposed_cities[salesman.getIndex()][city.getIndex()] == true)
					nb_salesmen_who_have_been_proposed_this_city++;
				if (nb_salesmen_who_have_been_proposed_this_city >= get_Main().salesmen.size()-1 )
					citiesAllocated.remove( city );
			}
	}

	solve_TSPcplex_give(true);

	if( P2P_city_proposed_to_guest != null){
		//"P2P_city_proposed_to_guest" is assigned a city by "solve_TSPcplex_giver()", but the possible receiver needs to be found by the following for():
		for(Salesman salesman : get_Main().salesmen)
			if(salesman != this){
				//traceln("P2P_city_proposed_to_guest="+P2P_city_proposed_to_guest);
				if( ! P2P_previously_proposed_cities[salesman.getIndex()][P2P_city_proposed_to_guest.getIndex()] )
					P2P_possible_receiving_guest = salesman;
			}
		assert P2P_possible_receiving_guest != null;
		
		//The following 3 lines are the only difference with P2PWR_1_propose_city_to_guest	
		P2Pswap_nego_invitation message = new P2Pswap_nego_invitation(this);
		traceln("1 " + this + " invites " + P2P_possible_receiving_guest);
		send( message, P2P_possible_receiving_guest);
	
	}//if( P2P_city_proposed_to_guest != null){
	route = route_backup;
	citiesAllocated = citiesAllocated_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></Description>
					<X>330</X><Y>700</Y>
					<Label><X>0</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[ArrayList<City>citiesAllocated_backup	= (ArrayList)allocatedCities.clone();

allocatedCities.add( city_proposed_by_guest );
allocatedCities.remove( city_proposed_to_host );

get_Main().remainingComputationTime = get_Main().maximumComputationTimeSpan - P2P_end_date_of_computation;
double CPLEXrouteLength = solve_modifiedTSPcplex(true, false, true, false);
P2P_end_date_of_computation			+= duration_of_last_call_to_the_solver;
guest.P2P_end_date_of_computation	+= duration_of_last_call_to_the_solver;
//traceln("4 "+this+" host="+this+" has " + P2P_end_date_of_computation +" guest="+guest+" has " + guest.P2P_end_date_of_computation);

get_Main().durations_of_calls_to_the_solver.get( P2P_index_of_hosted_interaction )[3] = duration_of_last_call_to_the_solver;

if(get_Main().debugOutput)	traceln("6 " + this+" host proposes "+city_proposed_to_guest+ " (old length="+routeLength()+" new length="+CPLEXrouteLength+") to " + guest);

//if( city_proposed_by_guest != city_proposed_to_guest )
if( !guest.allocatedCities.contains( city_proposed_to_guest ) )
	propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;

send( new P2P_offer_proposition(city_proposed_to_guest, possible_saving_from_giving, this ), guest );
allocatedCities = citiesAllocated_backup;
//traceln(this+"\tP2Pswap6\t"+duration_of_last_call_to_solve);
]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1468857137626</Id>
					<Name><![CDATA[P2P2_host_invites_guest]]></Name>
					<Description><![CDATA[if(P2P_city_proposed_to_guest == null){
	get_Main().consoleOutput = false;
	ArrayList<City> citiesAllocated_backup	= (ArrayList)citiesAllocated.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	int citiesAllocated_number = citiesAllocated.size();
	
/*	for(int salesman=0; salesman<get_Main().salesmen.size(); salesman++){
		trace("\npreviously_proposed_cities salesman"+salesman);
		for(int city=0; city<get_Main().cities.size(); city++){
			trace("\t"+P2P_previously_proposed_cities[salesman][city]);
		}
	}
	traceln();
	for(City city : citiesAllocated)
		trace(city+"\t");
	traceln();
	*/
	//Try to remove cities previously proposed to salesmen from citiesAllocated, in order to decrease the time of CPLEX optimisation
	for(City city : citiesAllocated_backup){
		int nb_salesmen_who_have_been_proposed_this_city = 0;
		for(Salesman salesman : get_Main().salesmen)
			if( salesman != this )
			{
				if( P2P_previously_proposed_cities[salesman.getIndex()][city.getIndex()] == true)
					nb_salesmen_who_have_been_proposed_this_city++;
				if (nb_salesmen_who_have_been_proposed_this_city >= get_Main().salesmen.size()-1 )
					citiesAllocated.remove( city );
			}
	}

	solve_TSPcplex_give(true);

	if( P2P_city_proposed_to_guest != null){
		//"P2P_city_proposed_to_guest" is assigned a city by "solve_TSPcplex_giver()", but the possible receiver needs to be found by the following for():
		for(Salesman salesman : get_Main().salesmen)
			if(salesman != this){
				//traceln("P2P_city_proposed_to_guest="+P2P_city_proposed_to_guest);
				if( ! P2P_previously_proposed_cities[salesman.getIndex()][P2P_city_proposed_to_guest.getIndex()] )
					P2P_possible_receiving_guest = salesman;
			}
		assert P2P_possible_receiving_guest != null;
		
		//The following 3 lines are the only difference with P2PWR_1_propose_city_to_guest	
		P2Pswap_nego_invitation message = new P2Pswap_nego_invitation(this);
		traceln("1 " + this + " invites " + P2P_possible_receiving_guest);
		send( message, P2P_possible_receiving_guest);
	
	}//if( P2P_city_proposed_to_guest != null){
	route = route_backup;
	citiesAllocated = citiesAllocated_backup;
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
}//if(P2P2_cityProposedToSalesmanA)
]]></Description>
					<X>50</X><Y>690</Y>
					<Label><X>30</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[get_Main().durations_of_calls_to_the_solver.add( new double[6] );
P2P_index_of_hosted_interaction = get_Main().durations_of_calls_to_the_solver.size()-1;
get_Main().durations_of_calls_to_the_solver.get( P2P_index_of_hosted_interaction )[0] = getIndex();

int[]	nb_cities_proposed_to_salesman = new int[ get_Main().salesmen.size() ];
for( int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
	if( salesman!= this.getIndex() )
		for( int city=0 ; city<get_Main().cities.size() ; city++)
			if( propCities[ salesman ][ city ] )
				nb_cities_proposed_to_salesman[ salesman ]++;

//remove the salesmen who were already proposed all my cities
for( int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
	if(nb_cities_proposed_to_salesman[ salesman ] == ownedCities.size()-1 )
		nb_cities_proposed_to_salesman[ salesman ] = Integer.MAX_VALUE;

//among the remaining salesmen, 'guest' is the one with the lowest number of cities previously proposed
int lowest_nb_cities_proposed = Integer.MAX_VALUE;
for( int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
	if( salesman!= this.getIndex() )
		if( lowest_nb_cities_proposed > nb_cities_proposed_to_salesman[ salesman ]){
			lowest_nb_cities_proposed = nb_cities_proposed_to_salesman[ salesman ];
			guest = get_Main().salesmen.get( salesman );
		}

//send an invitation to negotiate to 'guest'
if(guest!=null)	//otherwise, stop inviting salesmen (and the protocol stops when this is true for all salesmen)
{
	send( new CNP_P2Pswap_nego_invitation(this), guest);
	if(get_Main().debugOutput)	traceln("2 " + this +" host invites " + guest+" lowest_nb_cities_proposed="+lowest_nb_cities_proposed);
}
else
	if(get_Main().debugOutput)	traceln("2 " + this +" invites nobody");


/*
 *	TRACELNs useful for debugging
 */
/*traceln();
get_Main().button_previously_proposed_cities.action();
traceln();*/
/*for(Salesman s : get_Main().salesmen){
	trace(s+" "+s.routeLength()+"\t");
	s.printRoute();
	s.routeLength_verbose();
	traceln();
}*/
/*for(Salesman s : get_Main().salesmen)
	trace((int)s.routeLength()+"\t");
traceln();*/]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1468857137630</Id>
					<Name><![CDATA[P2P4_guest_proposes_a_city]]></Name>
					<X>820</X><Y>650</Y>
					<Label><X>30</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[get_Main().durations_of_calls_to_the_solver.get( host.P2P_index_of_hosted_interaction )[1] = getIndex();

ArrayList<City>	citiesAllocated_backup	= (ArrayList)allocatedCities.clone();

double start_date_of_this_state = max(P2P_end_date_of_computation, host.P2P_end_date_of_computation);
get_Main().remainingComputationTime = get_Main().maximumComputationTimeSpan - start_date_of_this_state;
solve_modifiedTSPcplex(false, false, true, false);
P2P_end_date_of_computation	= host.P2P_end_date_of_computation	= start_date_of_this_state + duration_of_last_call_to_the_solver;
//traceln("4 "+this+" host="+host+" has " + host.P2P_end_date_of_computation +" guest="+this+" has " + P2P_end_date_of_computation);

if(get_Main().debugOutput)	traceln("4 "+this+" duration_of_last_call_to_solve="+duration_of_last_call_to_the_solver);
get_Main().durations_of_calls_to_the_solver.get( host.P2P_index_of_hosted_interaction )[2] = duration_of_last_call_to_the_solver;
if(get_Main().debugOutput)	traceln("4 " + this + " guest accepts nego with " + host + " and proposes city_proposed_to_host=" + city_proposed_to_host);
send(new CNP_P2Pswap_nego_reply(city_proposed_to_host, 0, this), host);
if(city_proposed_to_host != null)
	propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ] = true;

allocatedCities = citiesAllocated_backup ;
//traceln(this+"\tP2Pswap4\t"+duration_of_last_call_to_solve);]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1468857137632</Id>
					<Name><![CDATA[P2P0_initialisation]]></Name>
					<X>50</X><Y>635</Y>
					<Label><X>55</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
if( get_Main().mechanismStartTime == -1)	//if this salesman is the first to initialise this statechart
	get_Main().mechanismStartTime = System.currentTimeMillis();
possible_saving_from_giving = Double.MIN_VALUE;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1469092399740</Id>
					<Name><![CDATA[P2P1_guest_waits_for_invitation]]></Name>
					<X>570</X><Y>650</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1469093561522</Id>
					<Name><![CDATA[P2Pswap_0_guest_initialisation]]></Name>
					<X>1700</X><Y>740</Y>
					<Label><X>15</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="200" Height="30">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1473348762141</Id>
					<Name><![CDATA[A16_acknowledge]]></Name>
					<X>790</X><Y>549</Y>
					<Label><X>50</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[send("Acknowledgement", myCentralPlanner);
if(get_Main().debugOutput)	traceln("16  "+this+" acknowledges the proposed city");]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1481128258953</Id>
					<Name><![CDATA[P2P9_host_does_nothing]]></Name>
					<X>320</X><Y>610</Y>
					<Label><X>35</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="FinalState" ParentState="ROOT_NODE">
					<Id>1491836002862</Id>
					<Name><![CDATA[P2Pswap_finalState]]></Name>
					<X>130</X><Y>750</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Properties>	
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491919974029</Id>
					<Name><![CDATA[CNP0_initialisation]]></Name>
					<X>30</X><Y>300</Y>
					<Label><X>35</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="250" Height="20">
						<EntryAction><![CDATA[propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
if( get_Main().mechanismStartTime == -1)	//if this salesman is the first to initialise this statechart
	get_Main().mechanismStartTime = System.currentTimeMillis();
possible_saving_from_giving = Double.MIN_VALUE;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491920065061</Id>
					<Name><![CDATA[CNP3_host_broadcasts_RFPs]]></Name>
					<X>30</X><Y>350</Y>
					<Label><X>15</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="250" Height="20">
						<EntryAction><![CDATA[//if(get_Main().debugOutput)	traceln("\n3 "+this+"\tremainingComputationTime="+get_Main().remainingComputationTime);
get_Main().durations_of_calls_to_the_solver.add(new double[get_Main().salesmen.size()+3]);
//save the id of the host in the last position of the current interaction
get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[get_Main().salesmen.size()+2] = getIndex() ;

//get_Main().button_previously_proposed_cities.action();
//if(get_Main().debugOutput)	getEngine().pause();

ArrayList<City>	citiesAllocated_backup	= (ArrayList)allocatedCities.clone();

solve_modifiedTSPcplex(false, false, false, true);	//solve_TSPcplex_give(false, true, false, false);

if( get_Main().remainingComputationTime -  duration_of_last_call_to_the_solver > 0)
	get_Main().remainingComputationTime -= duration_of_last_call_to_the_solver;
else if(-Double.MAX_VALUE != -Double.MAX_VALUE)
	get_Main().remainingComputationTime = 0;
get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[get_Main().salesmen.size()] = duration_of_last_call_to_the_solver ;

//if(get_Main().debugOutput) traceln("3 "+this+"\tremainingComputationTime="+get_Main().remainingComputationTime);
city_proposed_to_guest = CNP_city_to_get_rid_of;

if(CNP_city_to_get_rid_of!=null){	//CPLEX has found a solution
	for(Salesman guest: get_Main().salesmen)
		if(guest!=this){
			send(new CNP_P2Pswap_nego_invitation(city_proposed_to_guest, this), guest);
			//propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
			//propCities[	 this.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
		}
	//if(get_Main().debugOutput)	traceln("3 " + this + " is BROADCASTING an RFP for " + city_proposed_to_guest);

	CNP_number_of_replies	= 0;
	list_of_bids			= new City[ get_Main().salesmen.size() ];
	list_of_savings			= new double[ get_Main().salesmen.size() ];
}

allocatedCities = citiesAllocated_backup ;
//traceln(this+"\tP2Pswap4\t"+duration_of_last_call_to_solve);]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491924740849</Id>
					<Name><![CDATA[CNP1_guest_waits_for_RFP]]></Name>
					<X>530</X><Y>300</Y>
					<Label><X>30</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[city_proposed_by_host	= null;
city_proposed_to_host	= null;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491924740851</Id>
					<Name><![CDATA[CNP5_guest_sends_proposal]]></Name>
					<X>530</X><Y>350</Y>
					<Label><X>25</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="240" Height="20">
						<EntryAction><![CDATA[ArrayList<City>citiesAllocated_backup	= (ArrayList)allocatedCities.clone();

double route_length_without_exchange = routeLength();

allocatedCities.add( city_proposed_by_host );

double route_length_with_exchange = solve_modifiedTSPcplex(false, false, false, true);
get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[getIndex()] = duration_of_last_call_to_the_solver ;
//if(get_Main().debugOutput)
route_if_exchange_accepted_as_guest = (ArrayList)route_found_by_solve_modifiedTSPcplex.clone();

//traceln("5 "+this+" duration_of_last_call_to_solve="+duration_of_last_call_to_solve);

possible_saving_from_giving = route_length_without_exchange - route_length_with_exchange;	//this is sent to guest, but he does not care about this information since he only wants to find a city reducing his own route length
//if(get_Main().debugOutput)	traceln("4 possible_saving_from_giving="+possible_saving_from_giving+" route_length_without_exchange="+route_length_without_exchange+" route_length_with_exchange="+route_length_with_exchange);

if(city_proposed_by_host != CNP_city_to_get_rid_of)
	city_proposed_to_host = CNP_city_to_get_rid_of;
else
	city_proposed_to_host = null;

if(possible_saving_from_giving < 0 ){
	possible_saving_from_giving = 0;
	city_proposed_to_host = null;
}

send(new CNP_P2Pswap_nego_reply(city_proposed_to_host, possible_saving_from_giving, this), host);

if(city_proposed_to_host!=null)
	propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ] = true;	//remember not to propose again this city to any host (a simple improvement to explore a larger part of the search space of the allocation problem would be to add a dimension to propCities in order not to propose again this city to this particular host, but to propose it to other hosts

//if(get_Main().debugOutput)	traceln("5 " + this + " is PROPOSING " + city_proposed_to_host + " and would save "+possible_saving_from_giving + " (because he was proposed " + city_proposed_by_host+" FROM " + host+")");

allocatedCities = citiesAllocated_backup;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491926973461</Id>
					<Name><![CDATA[CNP9_host_sends_allocation_replies]]></Name>
					<X>30</X><Y>510</Y>
					<Label><X>0</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="250" Height="20">
						<EntryAction><![CDATA[ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
ArrayList<Agent>route_backup			= (ArrayList)route.clone();
int m = get_Main().salesmen.size();

//take the duration time of the parallel calls to CPLEX in the guests' CNP5 into account
double[] temp_durations_of_calls_to_solve = new double[ get_Main().salesmen.size() ];
for(int i=0 ; i<get_Main().salesmen.size() ; i++)
	temp_durations_of_calls_to_solve[i] = get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i];
if( get_Main().remainingComputationTime -  max(temp_durations_of_calls_to_solve) > 0)
	get_Main().remainingComputationTime -= max(temp_durations_of_calls_to_solve);
else if(-Double.MAX_VALUE != -Double.MAX_VALUE)
	get_Main().remainingComputationTime = 0;
//if(get_Main().debugOutput)	traceln("9 "+this+"\tremainingComputationTime="+get_Main().remainingComputationTime);

//Assess the distance saved by visiting each city proposed by the guests instead of 'city_proposed_to_guest'
double route_length_without_exchange = routeLength();
double best_saving_for_myself = -1;
ArrayList<Agent> best_route = (ArrayList)route;
int best_salesman = -1;
for(int salesman=0 ; salesman<m ; salesman++)
	if(salesman!=this.getIndex() && list_of_bids[salesman]!=null){
		allocatedCities.remove( city_proposed_to_guest );
		allocatedCities.add( list_of_bids[salesman] );

		boolean consoleOutput_bkp = get_Main().consoleOutput;
		get_Main().consoleOutput = false;
		solve_TSPcplex();

		if( get_Main().remainingComputationTime -  duration_of_last_call_to_the_solver > 0)
			get_Main().remainingComputationTime -= duration_of_last_call_to_the_solver;
		else if(-Double.MAX_VALUE != -Double.MAX_VALUE)
			get_Main().remainingComputationTime = 0;
		get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[get_Main().salesmen.size()+1] += duration_of_last_call_to_the_solver ;

		//if(get_Main().debugOutput)	traceln("9 " + this+"\tsolve_TSPcplex() duration_of_last_call_to_solve=\t"+duration_of_last_call_to_solve);
		get_Main().consoleOutput = consoleOutput_bkp;
		
		double saving_for_myself = route_length_without_exchange - routeLength();
		if( best_saving_for_myself < saving_for_myself){
			best_saving_for_myself = saving_for_myself;
			best_salesman = salesman;
			best_route = (ArrayList)route.clone();
		}//if
		allocatedCities = (ArrayList)citiesAllocated_backup.clone() ;
	}//else
route = route_backup;
	
for(int salesman=0 ; salesman<m ; salesman++)
	if(salesman!=this.getIndex() && salesman!=best_salesman){
		if(get_Main().debugOutput)	traceln("9 " + this +" has sent a rejection for " + list_of_bids[salesman] + " to salesman " + salesman);
		propCities[ salesman ][ city_proposed_to_guest.getIndex() ] = true;	//when a guest proposes a city and the host declines it, then do not propose again this city to this guest (the guest thus cannot propose another city, otherwise we would need a 3rd dimension, i.e., propCities[guest][cityProposedByHost] would be replaced by propCities[guest][cityProposedByHost][cityProposedByGuest] (which would allow to explore the entire research space of the allocation problem)
		send(new Message("reject", this), get_Main().salesmen.get(salesman));
	}//if
for(int salesman=0 ; salesman<m ; salesman++){
	if(salesman==best_salesman){	//if an exchange of cities is agreed on
		if(get_Main().debugOutput)	System.err.print("9 " + this +" has sent an ACCEPTATION to give " + city_proposed_to_guest+ " to " + get_Main().salesmen.get(salesman) +" and receive "+list_of_bids[best_salesman]+"\n");
		allocatedCities.remove( city_proposed_to_guest );
		allocatedCities.add( list_of_bids[best_salesman] );
		route = best_route;
		eraseRoute();
		drawRoute();
		propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
		send(new Message("accept", this), get_Main().salesmen.get(best_salesman));
		
	}
}//for]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1491927601473</Id>
					<Name><![CDATA[CNP7_host_waits_for_all_proposals]]></Name>
					<X>30</X><Y>430</Y>
					<Label><X>0</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="250" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="FinalState" ParentState="ROOT_NODE">
					<Id>1492086813281</Id>
					<Name><![CDATA[finalState]]></Name>
					<X>450</X><Y>360</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<Properties>	
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1463581758153</Id>
					<Name><![CDATA[P2PWR]]></Name>
					<Description><![CDATA[The difference between P2P2self and P2P3benev is in P2P2????_receive_proposition_from_any_salesman_B:
- P2P2self minimises the route length of the agent (=selfish) => see 'if( currentRouteLength-routeLength() <= 0 )'
- P2P2benev minimises the route length of both agents (=benevolent) => see 'if( currentRouteLength-routeLength() <= msg.savingFromGivingThisCity )'

We may also add P2P2self which maximises the number of cities visited...]]></Description>
					<X>460</X><Y>910</Y>
					<Label><X>5</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
					</Points>
					<Properties Target="1463581758147">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1463581758155</Id>
					<Name><![CDATA[P2PWR0_start]]></Name>
					<X>380</X><Y>950</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1463581758147" Target="1463581758149" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 6 && !get_Main().swap]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1463581758157</Id>
					<Name><![CDATA[P2PWR2_receive_proposition_from_host]]></Name>
					<X>370</X><Y>1000</Y>
					<Label><X>-205</X><Y>-40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-20</X><Y>10</Y></Point>
						<Point><X>-190</X><Y>10</Y></Point>
						<Point><X>-190</X><Y>-30</Y></Point>
						<Point><X>-20</X><Y>-30</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>210.0</IconOffset>
					<Properties Source="1463581758149" Target="1463581758149" Trigger="message">
						<Action><![CDATA[number_of_messages_received ++;
get_Main().consoleOutput = false;
double currentRouteLength = routeLength();

ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
ArrayList<Agent> route_backup			= (ArrayList)route.clone();
allocatedCities.remove(city_proposed_to_guest);
allocatedCities.add(msg.city);
solve();

if( currentRouteLength-routeLength() >= - msg.savingFromGivingThisCity	){	//benevolent
//if( currentRouteLength-routeLength() >= 0								){	//selfish
	if(get_Main().debugOutput)	traceln(this+" **ACCEPTS** " +msg.city);
	send( new P2P_offer_reply(true, this), msg.sender);		//send ACCEPT
	allocatedCities = citiesAllocated_backup;
	allocatedCities.add(msg.city);
	if(get_Main().solveNdrawAutomatically)	eraseRoute();
	solve_TSPcplex();
	if(get_Main().solveNdrawAutomatically)	drawRoute();
}//if(currentRouteLength)
else {
	if(get_Main().debugOutput)	traceln(this+" **DECLINES** "+msg.city);
	send( new P2P_offer_reply(false, this), msg.sender);	//send DECLINE
	allocatedCities	= citiesAllocated_backup;
	route			= route_backup;
}//if(!currentRouteLength)
get_Main().consoleOutput = get_Main().consoleOutput_backup;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 1]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1463581758159</Id>
					<Name><![CDATA[P2PWR_3_receive_reply_from_guest]]></Name>
					<Description><![CDATA[Selfish agent: if( currentRouteLength-routeLength() >= 0 ){
Benevolent agent: if( currentRouteLength-routeLength() >= msg.savingFromGivingThisCity ){
]]></Description>
					<X>550</X><Y>1000</Y>
					<Label><X>20</X><Y>-40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>20</X><Y>10</Y></Point>
						<Point><X>190</X><Y>10</Y></Point>
						<Point><X>190</X><Y>-30</Y></Point>
						<Point><X>20</X><Y>-30</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>220.0</IconOffset>
					<Properties Source="1463581758149" Target="1463581758149" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
if(msg.accept){
	if(get_Main().debugOutput)	traceln(this + " gives " + city_proposed_to_guest + " to " + guest);
	allocatedCities.remove( city_proposed_to_guest );
	if(get_Main().solveNdrawAutomatically)	eraseRoute();
	get_Main().consoleOutput = false;
	solve();
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	if(get_Main().solveNdrawAutomatically)	drawRoute();
	//previouslyProposedCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];	//reinitialise previouslyProposedCities in ordre to propose again any city
}
city_proposed_to_guest = null;
guest = null;
]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_reply]]></MessageType>
						<DefaultTransition>false</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1463581758161</Id>
					<Name><![CDATA[P2PWR4_no_more_exchanges_to_propose]]></Name>
					<X>380</X><Y>1000</Y>
					<Label><X>5</X><Y>25</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>32</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1463581758149" Target="1463581758151" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[city_proposed_to_guest == null || nbReallocations() >= maxReallocations || get_Main().remainingComputationTime == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464610581051</Id>
					<Name><![CDATA[OLD_P2Pswap_2_receive_invitation_from_host]]></Name>
					<Description><![CDATA[P2Pswap_nego_invitation]]></Description>
					<X>1570</X><Y>630</Y>
					<Label><X>-215</X><Y>50</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-20</X><Y>40</Y></Point>
						<Point><X>-140</X><Y>40</Y></Point>
						<Point><X>-160</X><Y>20</Y></Point>
					</Points>
					<IconOffset>120.0</IconOffset>
					<Properties Source="1464610581041" Target="1464610581045" Trigger="message">
						<Action><![CDATA[host  = msg.sender;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 1]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_invitation]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[host == null]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464610581053</Id>
					<Name><![CDATA[OLD_P2P3_7_Receive_reply_from_guest]]></Name>
					<X>1830</X><Y>610</Y>
					<Label><X>-95</X><Y>-30</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-10</X><Y>-20</Y></Point>
						<Point><X>-160</X><Y>-20</Y></Point>
						<Point><X>-190</X><Y>-10</Y></Point>
					</Points>
					<IconOffset>70.0</IconOffset>
					<Properties Source="1464610581039" Target="1464610581041" Trigger="message">
						<Action><![CDATA[if(msg.accept){
	//traceln(this + " gives " + P2P2_city_proposed_to_guest + " to " + P2P2_possible_receiving_guest);
	allocatedCities.remove( city_proposed_to_guest );
	allocatedCities.add( city_proposed_by_guest );
	eraseRoute();
	get_Main().consoleOutput = false;
	solve();
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	drawRoute();
	propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];	//reinitialise previouslyProposedCities in ordre to propose again any city
}
else{
	propCities[ guest.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;
}
city_proposed_to_guest = null;
guest = null;
city_proposed_by_host = null;
OLD_P2Pswap_possible_saving_of_guest = Double.MAX_VALUE;

for(Salesman salesman : get_Main().salesmen)
			if( !salesman.equals(this) ){
				boolean[] previouslyProposedCities_temp = propCities[ salesman.getIndex() ];
				//for(int pos=0; pos<previouslyProposedCities_temp.length ; pos++)
				//	if( previouslyProposedCities_temp[pos] )
				//		trace("\t"+pos+"Tr");
				//	else
				//		trace("\t"+pos+"f");
				//traceln();
			}]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_reply]]></MessageType>
						<DefaultTransition>false</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.sender == guest]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464610581056</Id>
					<Name><![CDATA[OLD_P2Pswap_no_more_exchanges_to_propose]]></Name>
					<X>1620</X><Y>630</Y>
					<Label><X>-220</X><Y>70</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>82</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1464610581041" Target="1464610581043" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[city_proposed_to_guest == null || nbReallocations() >= maxReallocations]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464610581058</Id>
					<Name><![CDATA[OLD_P2Pswap_4_negotiation_accepted_by_guest]]></Name>
					<X>1670</X><Y>630</Y>
					<Label><X>55</X><Y>40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>20</X><Y>30</Y></Point>
						<Point><X>150</X><Y>30</Y></Point>
						<Point><X>160</X><Y>10</Y></Point>
					</Points>
					<IconOffset>120.0</IconOffset>
					<Properties Source="1464610581041" Target="1464610581039" Trigger="message">
						<Action><![CDATA[traceln("4 " + this + " nego accepted");
city_proposed_by_guest = msg.city;
OLD_P2Pswap_possible_saving_of_guest = msg.savingFromGivingThisCity;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.city != null]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464610581061</Id>
					<Name><![CDATA[OLD_P2P3_6_receive_proposition_and_accept_or_reject]]></Name>
					<Description><![CDATA[Benevolent agent: if( currentRouteLength-routeLength() > - msg.savingFromGivingThisCity ){
Selfish agent: if( currentRouteLength-routeLength() > 0 ){]]></Description>
					<X>1410</X><Y>620</Y>
					<Label><X>-100</X><Y>-40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>20</X><Y>-30</Y></Point>
						<Point><X>160</X><Y>-30</Y></Point>
						<Point><X>190</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>90.0</IconOffset>
					<Properties Source="1464610581045" Target="1464610581041" Trigger="message">
						<Action><![CDATA[get_Main().consoleOutput = false;

traceln("6 " + this + " msg="+msg.city+" for " +msg.savingFromGivingThisCity);

if(msg.city!=null){
	double currentRouteLength = routeLength();

	ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	allocatedCities.remove(city_proposed_to_guest);
	allocatedCities.add(msg.city);
	solve();
	
	//traceln(this+" "+currentRouteLength+"->"+routeLength()+ " ("+P2Pswap_possible_giving_host+" saves "+msg.savingFromGivingThisCity+") "+P2P_city_proposed_to_guest+"->"+msg.city+" ");

	if( currentRouteLength-routeLength() > 0 ){	//if( currentRouteLength-routeLength() > - msg.savingFromGivingThisCity ){		//version of a benevolent salesman
		traceln("6 " + this+" **ACCEPTS** "+msg.city+" and gives "+city_proposed_to_guest+" currentRouteLength="+currentRouteLength+ " routeLength()="+routeLength());
		send( new P2P_offer_reply(true, this), host);		//send ACCEPT
		eraseRoute();
		solve();
		drawRoute();
		propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];	//reinitialise previouslyProposedCities in ordre to propose again any city
	}//if(currentRouteLength)
	else {
		traceln("6 " + this+" **DECLINES** "+msg.city+" and keeps "+city_proposed_to_guest+" currentRouteLength="+currentRouteLength+ " routeLength()="+routeLength());
		send( new P2P_offer_reply(false, this), host);		//send DECLINE
		allocatedCities	= citiesAllocated_backup;
		route			= route_backup;
	}//if(!currentRouteLength)
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	possible_saving_from_giving = 0;
	city_proposed_by_host = null;
	host = null;
}
else{
	//traceln(this+" confirms cancellation from " + P2P3_possible_giving_host);
	send( new P2P_offer_reply(false, this), host);		//send DECLINE
}
host  = null;
city_proposed_to_host = null;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[host == msg.sender]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1464688386592</Id>
					<Name><![CDATA[Auction]]></Name>
					<X>810</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>19</Y></Point>
					</Points>
					<Properties Target="1464688386588">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464688386594</Id>
					<Name><![CDATA[A0_start]]></Name>
					<X>810</X><Y>309</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1464688386588" Target="1464688386590" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 5]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1464782716370</Id>
					<Name><![CDATA[OLD_P2Pswap]]></Name>
					<X>1620</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<Properties Target="1464782725388">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1464782730387</Id>
					<Name><![CDATA[OLD_P2Pswap_0_start]]></Name>
					<X>1620</X><Y>570</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1464782725388" Target="1464610581041" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[false;	//get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1465569780086</Id>
					<Name><![CDATA[A3_receive_RFP]]></Name>
					<X>810</X><Y>359</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1464688386590" Target="1465569762917" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
if(get_Main().debugOutput)	traceln("3   "+this+" has received a " +msg);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[String]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[equalsTo]]></FilterType>
						<EqualsExpression><![CDATA["Request For Proposals"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1466168614704</Id>
					<Name><![CDATA[P2PWR_OLD]]></Name>
					<Description><![CDATA[The difference between P2P2self and P2P3benev is in P2P2????_receive_proposition_from_any_salesman_B:
- P2P2self minimises the route length of the agent (=selfish) => see 'if( currentRouteLength-routeLength() <= 0 )'
- P2P2benev minimises the route length of both agents (=benevolent) => see 'if( currentRouteLength-routeLength() <= msg.savingFromGivingThisCity )'

We may also add P2P2self which maximises the number of cities visited...]]></Description>
					<X>1650</X><Y>330</Y>
					<Label><X>5</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
					</Points>
					<Properties Target="1466168614696">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1466168614707</Id>
					<Name><![CDATA[P2PWR_0_start_OLD]]></Name>
					<X>1650</X><Y>380</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1466168614696" Target="1466168614700" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[false;	//get_Main().selectedAllocationMechanism == 6]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1466168614709</Id>
					<Name><![CDATA[P2PWR_2_receive_propo_from_host_OLD]]></Name>
					<X>1550</X><Y>430</Y>
					<Label><X>-180</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>-150</X><Y>0</Y></Point>
						<Point><X>-150</X><Y>-10</Y></Point>
						<Point><X>0</X><Y>-10</Y></Point>
					</Points>
					<IconOffset>50.0</IconOffset>
					<Properties Source="1466168614700" Target="1466168614700" Trigger="message">
						<Action><![CDATA[number_of_messages_received ++;
get_Main().consoleOutput = false;
double currentRouteLength = routeLength();

ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
ArrayList<Agent> route_backup			= (ArrayList)route.clone();
allocatedCities.remove(city_proposed_to_guest);
allocatedCities.add(msg.city);
solve();

//traceln(this +" routeLen without exchange="+currentRouteLength+" routeLen with exchange="+routeLength());

if( currentRouteLength-routeLength() >= 0 ){	//if( currentRouteLength > routeLength() ){		//version of a selfish salesman
	//traceln(this+" **ACCEPTS** " +msg.city);
	send( new P2P_offer_reply(true, this), msg.sender);		//send ACCEPT
	allocatedCities = citiesAllocated_backup;
	allocatedCities.add(msg.city);
	if(get_Main().solveNdrawAutomatically)	eraseRoute();
	solve_TSPcplex();
	if(get_Main().solveNdrawAutomatically)	drawRoute();
}//if(currentRouteLength)
else {
	traceln(this+" **DECLINES** "+msg.city);
	send( new P2P_offer_reply(false, this), msg.sender);		//send DECLINE
	allocatedCities	= citiesAllocated_backup;
	route			= route_backup;
}//if(!currentRouteLength)
get_Main().consoleOutput = get_Main().consoleOutput_backup;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 1]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1466168614711</Id>
					<Name><![CDATA[P2PWR_3_receive_reply_from_guest_OLD]]></Name>
					<Description><![CDATA[Selfish agent: if( currentRouteLength-routeLength() >= 0 ){
Benevolent agent: if( currentRouteLength-routeLength() >= msg.savingFromGivingThisCity ){
]]></Description>
					<X>1750</X><Y>430</Y>
					<Label><X>0</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>150</X><Y>0</Y></Point>
						<Point><X>150</X><Y>-10</Y></Point>
						<Point><X>0</X><Y>-10</Y></Point>
					</Points>
					<IconOffset>60.0</IconOffset>
					<Properties Source="1466168614700" Target="1466168614700" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
if(msg.accept){
	//traceln(this + " gives " + P2P2_cityProposedToSalesmanA + " to " + P2P2_possibleReceiver_A);
	allocatedCities.remove( city_proposed_to_guest );
	if(get_Main().solveNdrawAutomatically)	eraseRoute();
	get_Main().consoleOutput = false;
	solve();
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	if(get_Main().solveNdrawAutomatically)	drawRoute();
	//previouslyProposedCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];	//reinitialise previouslyProposedCities in ordre to propose again any city
}
city_proposed_to_guest = null;
guest = null;
]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_reply]]></MessageType>
						<DefaultTransition>false</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1466168614714</Id>
					<Name><![CDATA[P2PWR_no_more_exchanges_to_propose_OLD]]></Name>
					<X>1650</X><Y>440</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>32</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1466168614700" Target="1466168614702" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[city_proposed_to_guest == null || nbReallocations() >= maxReallocations]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1466616419360</Id>
					<Name><![CDATA[A9_receive_list_of_proposed_cities]]></Name>
					<X>810</X><Y>409</Y>
					<Label><X>5</X><Y>41</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>60</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1465569762917" Target="1466616362408" Trigger="message">
						<Action><![CDATA[list_of_bids = msg;
number_of_messages_received++;
if(get_Main().debugOutput)	traceln("9   "+this+" has received "+msg);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[City[]]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468845526594</Id>
					<Name><![CDATA[OLD_P2Pswap_4_negotiation_declined_by_guest]]></Name>
					<X>1660</X><Y>630</Y>
					<Label><X>35</X><Y>75</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>30</X><Y>60</Y></Point>
						<Point><X>30</X><Y>90</Y></Point>
						<Point><X>-20</X><Y>0</Y></Point>
					</Points>
					<IconOffset>80.0</IconOffset>
					<Properties Source="1464610581041" Target="1464610581041" Trigger="message">
						<Action><![CDATA[traceln("4 " + this + " nego declined");
city_proposed_by_guest = null;
OLD_P2Pswap_possible_saving_of_guest = Double.MIN_VALUE;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.city == null]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137634</Id>
					<Name><![CDATA[P2P3_guest_receives_invitation_from_host]]></Name>
					<Description><![CDATA[P2Pswap_nego_invitation]]></Description>
					<X>700</X><Y>670</Y>
					<Label><X>-40</X><Y>40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
						<Point><X>220</X><Y>30</Y></Point>
						<Point><X>220</X><Y>0</Y></Point>
					</Points>
					<IconOffset>260.0</IconOffset>
					<Properties Source="1469092399740" Target="1468857137630" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
host  = msg.sender;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 1]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_invitation]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[host == null && get_Main().selectedAllocationMechanism == 6 && get_Main().swap]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137636</Id>
					<Name><![CDATA[P2P8_host_receives_acceptation_or_rejection]]></Name>
					<X>340</X><Y>700</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
						<Point><X>160</X><Y>-20</Y></Point>
						<Point><X>160</X><Y>-70</Y></Point>
					</Points>
					<IconOffset>200.0</IconOffset>
					<Properties Source="1468857137624" Target="1481128258953" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
if(msg.accept && city_proposed_to_guest != city_proposed_by_guest){
	//if(get_Main().debugOutput)	System.err.println("8 " + this + " host gives " + city_proposed_to_guest + " to " + guest +" and receives " + city_proposed_by_guest);
	allocatedCities.remove( city_proposed_to_guest );
	allocatedCities.add( city_proposed_by_guest );
	eraseRoute();
	get_Main().consoleOutput = false;
	
	get_Main().remainingComputationTime = get_Main().maximumComputationTimeSpan - P2P_end_date_of_computation;
	solve();
	P2P_end_date_of_computation			+= duration_of_last_call_to_the_solver;	//this calculation must not be done by the guest
	//traceln("8 "+this+" host="+this+" has " + P2P_end_date_of_computation +" guest="+guest+" has " + guest.P2P_end_date_of_computation);
	
	//traceln(this+" 8 "+duration_of_last_call_to_solve);
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	get_Main().durations_of_calls_to_the_solver.get( P2P_index_of_hosted_interaction )[5] = duration_of_last_call_to_the_solver;
	drawRoute();
	for( int city=0 ; city<get_Main().cities.size() ; city++)
		propCities[ guest.getIndex() ][ city ] = false;	//reinitialise previouslyProposedCities in ordre to propose again any city
	for( int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
		if( salesman!= getIndex()){
			propCities[ salesman ][ city_proposed_to_guest.getIndex() ] = false;
			propCities[ salesman ][ city_proposed_by_guest.getIndex() ] = false;
		}
}
/*else{
	if(get_Main().debugOutput)	traceln("8 " + this + " host does nothing");
}*/
city_proposed_to_guest = null;
possible_saving_from_giving = Double.MIN_VALUE;
guest = null;
city_proposed_by_host = null;
//P2Pswap_possible_saving_of_guest = Double.MAX_VALUE;

/*traceln(this+"\tP2Pswap8\t"+duration_of_last_call_to_solve);
for(double[] interaction : get_Main().durations_of_calls_to_solve)
	traceln(interaction[0]+"\t"+interaction[1]+"\t"+interaction[2]+"\t"+interaction[3]+"\t"+interaction[4]+"\t"+interaction[5]);
for(Salesman salesman : get_Main().salesmen)
	traceln("FUCK "+salesman+"\t"+salesman.total_computation_time);*/]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[possiblyGiveCity_accepted == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_reply]]></MessageType>
						<DefaultTransition>false</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.sender == guest]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137640</Id>
					<Name><![CDATA[P2P5_host_receives_city_proposed_by_guest]]></Name>
					<X>260</X><Y>710</Y>
					<Label><X>-5</X><Y>40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
						<Point><X>80</X><Y>30</Y></Point>
						<Point><X>80</X><Y>10</Y></Point>
					</Points>
					<IconOffset>20.0</IconOffset>
					<Properties Source="1468857137626" Target="1468857137624" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
//traceln("5 " + this + " host receives negotiation acceptation with " + msg.city);
city_proposed_by_guest = msg.city;
//P2Pswap_possible_saving_of_guest = msg.savingFromGivingThisCity;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.city != null]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137642</Id>
					<Name><![CDATA[P2P7_guest_receives_proposition_and_sends_reply]]></Name>
					<Description><![CDATA[Benevolent agent: if( currentRouteLength-routeLength() > - msg.savingFromGivingThisCity ){
Selfish agent: if( currentRouteLength-routeLength() > 0 ){]]></Description>
					<X>920</X><Y>650</Y>
					<Label><X>-235</X><Y>-45</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>-30</Y></Point>
						<Point><X>-220</X><Y>-30</Y></Point>
						<Point><X>-220</X><Y>0</Y></Point>
					</Points>
					<IconOffset>260.0</IconOffset>
					<Properties Source="1468857137630" Target="1469092399740" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
get_Main().consoleOutput = false;
city_proposed_by_host = msg.city;

if( city_proposed_by_host!=null ){
	double currentRouteLength = routeLength();

	ArrayList<City> citiesAllocated_backup	= (ArrayList)allocatedCities.clone();
	ArrayList<Agent> route_backup			= (ArrayList)route.clone();
	allocatedCities.remove(city_proposed_to_host);
	allocatedCities.add(msg.city);
	
	get_Main().remainingComputationTime = get_Main().maximumComputationTimeSpan - P2P_end_date_of_computation;
	solve();
	P2P_end_date_of_computation			+=  duration_of_last_call_to_the_solver;
	host.P2P_end_date_of_computation	+=  duration_of_last_call_to_the_solver;
	get_Main().remainingComputationTime -= duration_of_last_call_to_the_solver;
	//traceln("71 "+this+" host="+host+" has " + host.P2P_end_date_of_computation +" guest="+this+" has " + P2P_end_date_of_computation);
	
	//traceln(this+" 71 "+duration_of_last_call_to_solve);
	get_Main().durations_of_calls_to_the_solver.get( host.P2P_index_of_hosted_interaction )[4] = duration_of_last_call_to_the_solver;
	
	if( currentRouteLength-routeLength() >= 0 && city_proposed_by_host != city_proposed_to_host ){	//if( currentRouteLength-routeLength() > - msg.savingFromGivingThisCity ){		//version of a benevolent salesman
		if(get_Main().debugOutput)	traceln("7 "+this+" guest  ACCEPTS "+ city_proposed_by_host +" and gives "+city_proposed_to_host+" to "+host+" because the gain is"+(currentRouteLength-routeLength()));
		//if(get_Main().debugOutput)	System.err.println("7 " + this+" host **ACCEPTS** "+msg.city+" and gives "+P2Pswap_city_proposed_to_host+" to " + P2Pswap_host_name);
		send( new P2P_offer_reply(true, this), host);		//send ACCEPT
		eraseRoute();

		solve();
		P2P_end_date_of_computation			+= duration_of_last_call_to_the_solver;
		host.P2P_end_date_of_computation	+= duration_of_last_call_to_the_solver;
		//traceln("72 "+this+" host="+host+" has " + host.P2P_end_date_of_computation +" guest="+this+" has " + P2P_end_date_of_computation);
		
		//traceln(this+" 72 "+duration_of_last_call_to_solve);
		get_Main().durations_of_calls_to_the_solver.get( host.P2P_index_of_hosted_interaction )[4] += duration_of_last_call_to_the_solver;
		drawRoute();
		propCities[host.getIndex()] = new boolean[ get_Main().cityNumber ];	//reinitialise previouslyProposedCities in ordre to propose again any city
		for( int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
			if( salesman!= getIndex()){
				propCities[ salesman ][ city_proposed_to_host.getIndex() ] = false;
				propCities[ salesman ][ msg.city.getIndex() ] = false;
			}
	}//if(currentRouteLength)
	else {
		if(get_Main().debugOutput)	traceln("7 "+this+" guest  REJECTS "+ city_proposed_by_host+" and does not give "+city_proposed_to_host+" to "+host+" because the gain is"+(currentRouteLength-routeLength()));
		//if(get_Main().debugOutput)	traceln("7 " + this+" host **DECLINES** "+msg.city+" and keeps "+P2Pswap_city_proposed_to_host+" belonging to " + P2Pswap_host_name);
		send( new P2P_offer_reply(false, this), host);		//send DECLINE
		allocatedCities	= citiesAllocated_backup;
		route			= route_backup;
	}//if(!currentRouteLength)
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	possible_saving_from_giving = 0;
	city_proposed_by_host = null;
	host = null;
}
else{
	if(get_Main().debugOutput)	traceln("7 "+this+" guest confirms rejection to " +host );
	//if(get_Main().debugOutput)	traceln("7 " + this+" host should not propose any more cities to " + msg.sender +" -- msg.city=" +msg.city+" proposed by " + msg.sender);
	send( new P2P_offer_reply(false, this), host);		//send DECLINE
}
host  = null;
city_proposed_to_host = null;
get_Main().consoleOutput = get_Main().consoleOutput_backup;
//traceln(this+"\tP2Pswap7\t"+duration_of_last_call_to_solve);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[host == msg.sender]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1468857137644</Id>
					<Name><![CDATA[P2P_host]]></Name>
					<X>60</X><Y>610</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>25</Y></Point>
					</Points>
					<Properties Target="1468857137632">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137646</Id>
					<Name><![CDATA[P2P0_host_starts]]></Name>
					<X>60</X><Y>655</Y>
					<Label><X>5</X><Y>20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>35</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1468857137632" Target="1468857137626" Trigger="condition">
						<Action><![CDATA[/*
  if durations_of_calls_to_solve (which saves the computation time to find the initial route) has
  NOT been initialised before (i.e., this is the first host to run in a simulation)
*/
if( get_Main().durations_of_calls_to_the_solver.size() == 0){
	for( Salesman salesman : get_Main().salesmen){
		get_Main().durations_of_calls_to_the_solver.add( new double[6] );
		get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[0] = salesman.getIndex();
		get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[1] = -1;
		get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[2] = salesman.duration_of_last_call_to_the_solver;
	}
}]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 6 && get_Main().swap]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1468857137648</Id>
					<Name><![CDATA[P2P5_host_receives_negotiation_rejection]]></Name>
					<X>110</X><Y>710</Y>
					<Label><X>-65</X><Y>65</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>50</Y></Point>
						<Point><X>-50</X><Y>50</Y></Point>
						<Point><X>-50</X><Y>0</Y></Point>
					</Points>
					<IconOffset>80.0</IconOffset>
					<Properties Source="1468857137626" Target="1468857137626" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
send( new P2P_offer_proposition(null, Double.MIN_VALUE, this ), guest );
for( Agent city : allocatedCities )
	if(city != get_Main().cities.get(0))
	propCities[ guest.getIndex() ][ city.getIndex() ]=true;
//if(get_Main().debugOutput)	traceln("5bis " + this + " host receives negotiation rejection from " +msg.sender);
city_proposed_by_guest = null;
city_proposed_to_guest = null;
possible_saving_from_giving = Double.MIN_VALUE;
guest = null;
//P2Pswap_possible_saving_of_guest = Double.MIN_VALUE;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.city == null]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1469093561524</Id>
					<Name><![CDATA[P2P_guest]]></Name>
					<X>590</X><Y>610</Y>
					<Label><X>5</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>40</Y></Point>
					</Points>
					<Properties Target="1469092399740">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1469093561526</Id>
					<Name><![CDATA[P2Pswap_0_guest_starts]]></Name>
					<X>1700</X><Y>630</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>180</X><Y>110</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1464610581041" Target="1469093561522" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473256003333</Id>
					<Name><![CDATA[A15_receive_allocated_city]]></Name>
					<X>810</X><Y>489</Y>
					<Label><X>5</X><Y>41</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>60</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1466616362408" Target="1473348762141" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
//P2P_previously_proposed_cities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
//if(get_Main().debugOutput) traceln("14 " + this + " swap "+msg+" with " + P2P_city_proposed_to_guest);

/*for(int k=0; k<get_Main().salesmen.size(); k++){
	trace("14 " + this+ " SM"+k+"  ");
	for(int i=0; i<get_Main().cities.size(); i++)
		if(previously_proposed_cities[k][i])
			trace("TRUE\t");
		else
			trace("f\t");
	traceln();
}*/

if(msg!=city_proposed_to_guest)	//if I receive a city which reduces the length of my route
{
	//traceln("15 "+this+" is removing " + P2P_city_proposed_to_guest + ", add " + msg + " and reinitialise P2P_previously_proposed_cities");
	allocatedCities.remove(city_proposed_to_guest);
	allocatedCities.add(msg);
	solve();
	my_computation_time -= duration_of_last_call_to_the_solver; 	//This call of CPLEX should be removed because this problem was already solved in A10 (I keep it but I do not take this computation time into account)
	eraseRoute();
	drawRoute();
	propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
}
else{
	//traceln("15 "+this+" is adding a true in P2P_previously_proposed_cities");
	propCities[0][ city_proposed_to_guest.getIndex() ] = true;	//Protocol Auc only needs a vector (the other lines in 'previously_proposed_cities' are requested by P2P protocols).
}

if(get_Main().debugOutput){
	for(int k=0; k<get_Main().salesmen.size(); k++){
		trace("15  " + this+ " previously_proposed_cities["+k+"][?]=  ");
		for(int i=0; i<get_Main().cities.size(); i++)
			if(propCities[k][i])
				trace("TRUE\t");
			else
				trace("f\t");
		traceln();
	}
}]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[City]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA[P2P_city_proposed_to_guest]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[get_Main().auctioneer.nb_salesmen_who_have_finished_an_iteration]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473348856143</Id>
					<Name><![CDATA[A19_start_over]]></Name>
					<X>1030</X><Y>559</Y>
					<Label><X>-75</X><Y>-289</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>30</X><Y>1</Y></Point>
						<Point><X>30</X><Y>-279</Y></Point>
						<Point><X>0</X><Y>-279</Y></Point>
						<Point><X>-20</X><Y>-270</Y></Point>
					</Points>
					<IconOffset>20.0</IconOffset>
					<Properties Source="1473348762141" Target="1464688386588" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1481128348166</Id>
					<Name><![CDATA[P2P10_host_waits]]></Name>
					<X>330</X><Y>630</Y>
					<Label><X>0</X><Y>15</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>40</Y></Point>
						<Point><X>-70</X><Y>40</Y></Point>
						<Point><X>-70</X><Y>60</Y></Point>
					</Points>
					<IconOffset>60.0</IconOffset>
					<Properties Source="1481128258953" Target="1468857137626" Trigger="timeout">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MILLISECOND]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491836025397</Id>
					<Name><![CDATA[P2P5_timeout]]></Name>
					<X>130</X><Y>710</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>32</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1468857137626" Target="1491836002862" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().remainingComputationTime <= 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1491919950231</Id>
					<Name><![CDATA[CNP_host]]></Name>
					<X>50</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
					</Points>
					<Properties Target="1491919974029">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491920068110</Id>
					<Name><![CDATA[CNP2_host_starts]]></Name>
					<X>50</X><Y>320</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1491919974029" Target="1491920065061" Trigger="condition">
						<Action><![CDATA[/*
  if durations_of_calls_to_solve (which saves the computation time to find the initial route) has
  NOT been initialised before (i.e., this is the first host to run in a simulation)
*/
/*if( get_Main().durations_of_calls_to_solve.size() == 0){
	get_Main().durations_of_calls_to_solve.add( new double[get_Main().salesmen.size() + 1] );
	for( Salesman salesman : get_Main().salesmen)
		get_Main().durations_of_calls_to_solve.get( 0 )[salesman.getIndex()] = salesman.duration_of_last_call_to_solve;
	get_Main().durations_of_calls_to_solve.get( 0 )[get_Main().salesmen.size()] = -1;
}*/]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1491924740853</Id>
					<Name><![CDATA[CNP_guest]]></Name>
					<X>550</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
					</Points>
					<Properties Target="1491924740849">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491924740855</Id>
					<Name><![CDATA[CNP4_guest_received_RFP]]></Name>
					<X>550</X><Y>320</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1491924740849" Target="1491924740851" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
city_proposed_by_host = msg.city;
host = msg.sender;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_invitation]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[get_Main().selectedAllocationMechanism == 7]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491926739236</Id>
					<Name><![CDATA[CNP6b_host_received_proposal]]></Name>
					<X>280</X><Y>440</Y>
					<Label><X>16</X><Y>-6</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>20</X><Y>10</Y></Point>
						<Point><X>200</X><Y>10</Y></Point>
						<Point><X>200</X><Y>-25</Y></Point>
						<Point><X>15</X><Y>-25</Y></Point>
						<Point><X>-10</X><Y>-10</Y></Point>
					</Points>
					<IconOffset>120.0</IconOffset>
					<Properties Source="1491927601473" Target="1491927601473" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
CNP_number_of_replies++;
list_of_bids[ msg.sender.getIndex() ] = msg.city;
//msg.savingFromGivingThisCity is not saved since the guest allocates his city depending on his own savings (not on the guest's saving)

if(msg.city==null)	//remember not to propose 'city_proposed_to_guest' again to 'msg.sender'
	propCities[ msg.sender.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[get_Main().selectedAllocationMechanism == 7]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491926896268</Id>
					<Name><![CDATA[CNP6_host_received_proposal]]></Name>
					<X>50</X><Y>370</Y>
					<Label><X>6</X><Y>40</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>60</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1491920065061" Target="1491927601473" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
CNP_number_of_replies++;
list_of_bids[ msg.sender.getIndex() ] = msg.city;
//msg.savingFromGivingThisCity is not saved since the guest allocates his city depending on his own savings (not on the guest's saving)

if(msg.city==null)	//remember not to propose 'city_proposed_to_guest' again to 'msg.sender'
	propCities[ msg.sender.getIndex() ][ city_proposed_to_guest.getIndex() ] = true;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 7]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[CNP_P2Pswap_nego_reply]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[get_Main().selectedAllocationMechanism == 7]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491927458094</Id>
					<Name><![CDATA[CNP11_host_waits_for_1ms]]></Name>
					<X>50</X><Y>530</Y>
					<Label><X>0</X><Y>35</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>40</Y></Point>
						<Point><X>-30</X><Y>40</Y></Point>
						<Point><X>-30</X><Y>-190</Y></Point>
						<Point><X>-10</X><Y>-180</Y></Point>
					</Points>
					<IconOffset>60.0</IconOffset>
					<Properties Source="1491926973461" Target="1491920065061" Trigger="timeout">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[MILLISECOND]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1491927741665</Id>
					<Name><![CDATA[CNP8_host_received_all_proposals]]></Name>
					<X>50</X><Y>450</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>60</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1491927601473" Target="1491926973461" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[CNP_number_of_replies == get_Main().salesmen.size() - 1;]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1492015626060</Id>
					<Name><![CDATA[CNP10_guest_received_acceptation]]></Name>
					<X>550</X><Y>370</Y>
					<Label><X>-56</X><Y>38</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
						<Point><X>-30</X><Y>30</Y></Point>
						<Point><X>-30</X><Y>-80</Y></Point>
						<Point><X>-10</X><Y>-70</Y></Point>
					</Points>
					<IconOffset>80.0</IconOffset>
					<Properties Source="1491924740851" Target="1491924740849" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
allocatedCities.add( city_proposed_by_host );
allocatedCities.remove( city_proposed_to_host );
route = route_if_exchange_accepted_as_guest;
eraseRoute();
drawRoute();
propCities = new boolean[ get_Main().salesmanNumber ][ get_Main().cityNumber ];
//if(get_Main().debugOutput)	traceln("10 " + this + " has received " + city_proposed_by_host + " and given " + city_proposed_to_host+" to "+msg.sender);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Message]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["accept"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.content.equals("accept")]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1492015727370</Id>
					<Name><![CDATA[CNP10_guest_received_rejection]]></Name>
					<X>760</X><Y>370</Y>
					<Label><X>-204</X><Y>78</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>70</Y></Point>
						<Point><X>20</X><Y>70</Y></Point>
						<Point><X>20</X><Y>-80</Y></Point>
						<Point><X>0</X><Y>-70</Y></Point>
					</Points>
					<IconOffset>60.0</IconOffset>
					<Properties Source="1491924740851" Target="1491924740849" Trigger="message">
						<Action><![CDATA[number_of_messages_received++;
//if(get_Main().debugOutput)	traceln("10 " + this + " has been rejected by " +host);
if(city_proposed_to_host!=null){
	//if(get_Main().debugOutput)	traceln("11 " + this + " propCities[ "+host+" ][ "+ city_proposed_to_host+" ]="+propCities[ host.getIndex() ][ city_proposed_by_host.getIndex() ]);
	//assert !propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ];
	propCities[ host.getIndex() ][ city_proposed_to_host.getIndex() ] = true;
}]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Message]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[satisfies]]></FilterType>
						<EqualsExpression><![CDATA["reject"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[msg.content.equals("reject")]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1492086819749</Id>
					<Name><![CDATA[CNP4_host_has_no_more_cities_to_RFP]]></Name>
					<X>270</X><Y>350</Y>
					<Label><X>-45</X><Y>-20</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>20</X><Y>-10</Y></Point>
						<Point><X>170</X><Y>-10</Y></Point>
						<Point><X>176</X><Y>2</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1491920065061" Target="1492086813281" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[city_proposed_to_guest == null;	//state "CNP2" has not found a city to broadcast in an RFP
//if(get_Main().debugOutput)	traceln("4 "+this+" CNP4_no_more_cities_to_RFP");]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1493126011069</Id>
					<Name><![CDATA[CNP4_timeout]]></Name>
					<X>270</X><Y>370</Y>
					<Label><X>40</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>10</X><Y>10</Y></Point>
						<Point><X>170</X><Y>10</Y></Point>
						<Point><X>176</X><Y>-3</Y></Point>
					</Points>
					<IconOffset>40.0</IconOffset>
					<Properties Source="1491920065061" Target="1492086813281" Trigger="condition">
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().remainingComputationTime == 0]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
			</StatechartElements>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1429199474961</Id>
					<Name><![CDATA[solve]]></Name>
					<X>30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/*trace("route: ");
for(Agent city : route)
	trace(city+" \t");
trace("\nalloc: ");
for(Agent city : citiesAllocated)
	trace(city+" \t");
traceln();
*/
switch(get_Main().selectedTspSolver){
	case 0:								solve_DTSPinsert();									break;
	case 1:	if(get_Main().staticSolver)	solve_TSPcplex();		else solve_DTSPcplex();		break;
	case 2:	if(get_Main().staticSolver)	solve_TSPojalgo();		else solve_DTSPojalgo();	break;
	case 3:	if(get_Main().staticSolver)	solve_TSPcplex();		else solve_DTSPcplex();		break;
}
//traceln(this+" computationTime="+computationTime+" => "+totalComputationTime);

//if(get_Main().consoleOutput)	trace("\t"+getIndex()+"\t"+allocatedCities.size()+"\t" + computationTime);

//if(get_Main().consoleOutput)	traceln("\t=\t" + (int)routeLength());

nextCity2visit = route.get(0);

//moveTo( nextCity2visit.getX(), nextCity2visit.getY() );]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1432902678247</Id>
					<Name><![CDATA[solve_DTSPinsert]]></Name>
					<X>163</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace(get_Main().instance+"\tTSPi");

if( route.size() == 0)
	route.add( allocatedCities.get(0) );	//finishes at depot
route.add( 0, this );				//start from current position (usefull in this function, but removed at the end before returning the route)

long computationStartTime = System.currentTimeMillis();

for(City city : allocatedCities){
	if( route.indexOf( city) == -1 ){	//add only new cities2visit into route
		if( ! city.equals( get_Main().cities.get(0) ) ){
			int bestIndex		= Integer.MAX_VALUE;
			double bestIncrease	= Double.MAX_VALUE;
			double testedIncrease	= Double.MAX_VALUE;
			for(int testedIndex=0 ; testedIndex < route.size() - 1 ; testedIndex++){
				testedIncrease =	Math.sqrt( Math.pow( route.get(testedIndex).getX()-city.getX(), 2) + Math.pow(route.get(testedIndex).getY()-city.getY(), 2)) + Math.sqrt( Math.pow(route.get(testedIndex+1).getX()-city.getX(), 2) + Math.pow(route.get(testedIndex+1).getY()-city.getY(), 2) )
								-	Math.sqrt( Math.pow( route.get(testedIndex).getX()-route.get(testedIndex+1).getX(), 2) + Math.pow( route.get(testedIndex).getY()-route.get(testedIndex+1).getY(), 2) );
				if(bestIncrease > testedIncrease){
					bestIncrease = testedIncrease;
					bestIndex = testedIndex;
				}//if(bestLength
			}//for(int testedposition)
		route.add(bestIndex+1, city);
//		traceln("Truck"+getIndex()+" insert "+city+"\t"+route);
		}//if(city != depot)
	}//if(city not in route)
//	else	traceln("Truck"+getIndex()+" does NOT insert "+city);
}
//route.remove(0);	//remove the current position (which is not a city)
my_computation_time += System.currentTimeMillis() - computationStartTime;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1432931520759</Id>
					<Name><![CDATA[drawRoute]]></Name>
					<X>420</X><Y>-70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[for(int i=1 ; i<route.size() ; i++){
	ShapeLine line;
	line = new ShapeLine(true, route.get(i-1).getX(), route.get(i-1).getY(), black, route.get(i).getX() - route.get(i-1).getX(), route.get(i).getY() - route.get(i-1).getY(), 0.5, LINE_STYLE_SOLID);
	line.setColor(color);
	line.setLineWidth(1.5);
	line.setEndArrowStyle(LineArrowStyle.ARROW_THIN);
	shapeLines.add(line);
	get_Main().presentation.add(line);

}

/*for(int i=0 ; i<route.size() ; i++){
	ShapeLine line;
	if (i==0)	line = new ShapeLine(true, getX(), getY(), black, route.get(0).getX() - getX(), route.get(0).getY() - getY(), 0.5, LINE_STYLE_SOLID);
	else		line = new ShapeLine(true, route.get(i-1).getX(), route.get(i-1).getY(), black, route.get(i).getX() - route.get(i-1).getX(), route.get(i).getY() - route.get(i-1).getY(), 0.5, LINE_STYLE_SOLID);
	line.setColor(color);
	line.setLineWidth(1.5);
	line.setEndArrowStyle(LineArrowStyle.ARROW_THIN);
	shapeLines.add(line);
	get_Main().presentation.add(line);

}*/]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1432933780075</Id>
					<Name><![CDATA[eraseRoute]]></Name>
					<X>420</X><Y>-90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[while( shapeLines.isEmpty() == false ){
	ShapeLine line = shapeLines.remove(0);
	get_Main().presentation.remove(line);
	line=null;
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1433335151562</Id>
					<Name><![CDATA[solve_TSPcplex]]></Name>
					<Description><![CDATA[CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Salesman agent
System.out.println(System.getProperty("java.library.path"));

Difference with solve_cplex_shortPath:
- current position not taken into account (since the salesman is assumed to start from the depot)
- the salesman goes to the depot, then does the loop and returns to the depot (solve_cplex_shortPath is quicker since it directly goes to the 1st city)]]></Description>
					<X>30</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	{trace(get_Main().instance+"\tTSPc");	}
/*trace("solve_TSPcplex on: ");
for(City city : allocatedCities)
	trace(city +"\t");
traceln();*/

IloCplex cplex;
int n = allocatedCities.size();	//Index in CPLEX: 0='depot', 1..n-1='cities'
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = allocatedCities.get(city_i);
	//traceln();
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = allocatedCities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
		//trace("c["+city_i+"]["+city_j+"]="+d[city_i][city_j]+";\t");
	}
}
//traceln();

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(n);
	}
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	// Objective
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				obj.addTerm(d[i][j], x[i][j]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// Constraint 1: for each node j, only one leaving edge
	// FORALL j, SUM_i(i<>j) x[i][j] = 1
	for(int j=0 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  1.0);
	}//for(j)
	
	// Constraint 2: for each node i, only one entering edge
	// FORALL i, SUM_j(i<>j) x[i][j] = 1
	for(int i=0 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  1.0);
	}//for(i)
	
	// Constraint 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-2
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,		x[i][j]);
				cplex.addLe(expr,	n-1);
			}//if
		}//for(j)
	}//for(i)
	
	// write model to file
	//cplex.exportModel("salesman" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime <= 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		duration_of_last_call_to_the_solver = computationEndTime - computationStartTime;
//if(get_Main().debugOutput)	traceln(this+"\tTSPcplex duration_of_last_call_to_solve=\t"+duration_of_last_call_to_the_solver);
		my_computation_time += duration_of_last_call_to_the_solver;
		//if(get_Main().debugOutput)	System.err.println(this+" TSP get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		//Display the result found by CPLEX
/*		trace("\nx[][] =\t");
		for(int i=0 ; i<n ; i++)
			trace("C"+ i+"\t");
		trace("\n");
		for(int i=0; i<n ; i++){
			System.out.print("\nL"+i+"\t");
			for(int j=0; j<n ; j++){
				if(i!=j){
					if(cplex.getValue(x[i][j]) > .9)	trace(cplex.getValue(x[i][j])+"\t");
					else								trace("\t");
				} else									trace("-\t");
			}
		}
		trace("\n");
*/		
		//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp = new int[n+1];
		solution_temp[0] = 0;	//start from the depot
		for( int position = 0 ; position < n ; position++){
			for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
				if(solution_temp[position] != column_in_x){
					if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ] ) > 0.9){
						solution_temp[position+1] = column_in_x;
						break;
					}
				}
			}//for(column_in_x)
		}//for(position)

		//convert solution_temp[] into 'route' ArrayList
		route.clear();
		//route.add(citiesAllocated.get(0));
		for(int position = 0 ; position < n+1 ; position++)
			route.add(allocatedCities.get( solution_temp[position] ));
			
	}//if(cplex.solve)
	else{
		if(get_Main().debugOutput)	traceln(this+" has *NOT* found a route");
		//assert allocatedCities.size() == 1;
		route = (ArrayList)allocatedCities.clone();
	}
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[City]]></ReturnType>
					<Id>1433347968064</Id>
					<Name><![CDATA[_findClosestCity]]></Name>
					<X>420</X><Y>-110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[int closestCity = -1;
double closestDistance = Double.MAX_VALUE;
double testedDistance;
for(int testedCity = 0 ; testedCity < ownedCities.size() ; testedCity++){
	testedDistance = Math.sqrt( Math.pow( getX() - ownedCities.get(testedCity).getX(), 2) + Math.pow( getY() - ownedCities.get(testedCity).getY(), 2));
	if(closestDistance > testedDistance){
		closestCity		= testedCity;
		closestDistance	= testedDistance;
	}
}
return ownedCities.get(closestCity);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1434966875213</Id>
					<Name><![CDATA[printRoute]]></Name>
					<X>420</X><Y>-50</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[for(Agent city : route){
	trace(city+ "\t");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1437399122429</Id>
					<Name><![CDATA[routeLength]]></Name>
					<X>420</X><Y>-30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double length = 0;
//trace("\nrouteLength()=");
for( int city = 0 ; city < route.size()-1 ; city++ ){
	//trace("+C"+route.get(city).getIndex()+"C"+route.get(city+1).getIndex()+" "+ Math.sqrt( Math.pow( route.get(city).getX() - route.get(city+1).getX(), 2) + Math.pow( route.get(city).getY() - route.get(city+1).getY(), 2))+"+");
	length += Math.sqrt( Math.pow( route.get(city).getX() - route.get(city+1).getX(), 2) + Math.pow( route.get(city).getY() - route.get(city+1).getY(), 2));
}

return length;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1441026157048</Id>
					<Name><![CDATA[solve_DTSPcplex]]></Name>
					<Description><![CDATA[CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Salesman agent
System.out.println(System.getProperty("java.library.path"));

Difference with solve_cplex_tsp: the result is not a loop starting and finishing at the depot, but a path from the current location through all the cities up to the depot.]]></Description>
					<X>163</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace(get_Main().instance+"\tDTSPc");
/*for(City city : citiesAllocated)
	traceln("City\t" + city.getIndex()+"\tX=\t"+city.getX() +"\tY=\t"+city.getY());*/

IloCplex cplex;
int n = allocatedCities.size();	//Index in CPLEX: 0='depot', 1..n-1='cities', n='position of salesman'
double[][] d = new double[n+1][n+1];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = allocatedCities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = allocatedCities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}
for(int city=0 ; city<allocatedCities.size() ; city++){
	d[city][n] = Math.sqrt( Math.pow(allocatedCities.get(city).getX()-getX(), 2) + Math.pow(allocatedCities.get(city).getY()-getY(), 2));
	d[n][city] = d[city][n];
}

d[0][allocatedCities.size()] = 0;	//TSP -ie, subroute elimination constraint 3- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n+1][];
	for(int i=0 ; i<n+1 ; i++){
		x[i] = cplex.boolVarArray(n+1);
	}
	IloNumVar[] u = cplex.numVarArray(n+1, 0, Double.MAX_VALUE);
	
	// Objective
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n+1 ; i++){
		for(int j=0 ; j<n+1 ; j++){
			if(j!=i)
				obj.addTerm(d[i][j], x[i][j]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// Constraint 1: for each node j, only one leaving path
	// FORALL j, SUM_i(i<>j) x[i][j] = 1
	for(int j=0 ; j<n+1 ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n+1 ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  1.0);
	}//for(j)
	
	// Constraint 2: for each node i, only one entering path
	// FORALL i, SUM_j(i<>j) x[i][j] = 1
	for(int i=0 ; i<n+1 ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n+1 ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  1.0);
	}//for(i)
	
	// Constraint 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n+1) x[i][j] <=  n
	for(int i=1 ; i<n+1 ; i++){
		for(int j=1 ; j<n+1 ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n+1,		x[i][j]);
				cplex.addLe(expr,	n);
			}//if
		}//for(j)
	}//for(i)
	
	// Constraint 11: use the zero-distance arc between the depot and the inital position of the saleman
	IloLinearNumExpr expr = cplex.linearNumExpr();
	expr.addTerm(1, x[0][n]);
	cplex.addEq(expr, 1);
	
	// write model to file
	//cplex.exportModel("salesman" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0)
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
	else if(get_Main().remainingComputationTime == 0)
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		duration_of_last_call_to_the_solver = computationEndTime - computationStartTime;
		my_computation_time += duration_of_last_call_to_the_solver;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
		//if(get_Main().debugOutput)	System.err.println(this+" DTSP get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		
		//Display the result found by CPLEX
/*		trace("\nx[][] =\t");
		for(int i=0 ; i<n+1 ; i++)
			if(i<n)	trace("C"+citiesAllocated.get(i).getIndex()+"\t");	else trace("SM"+this.getIndex()+"\t");
		trace("\n");
		for(int i=0; i<n+1 ; i++){
			if(i<n)	trace("C"+citiesAllocated.get(i).getIndex()+"\t");	else trace("SM"+this.getIndex()+"\t");
			for(int j=0; j<n+1 ; j++){
				if(i!=j){
					if(cplex.getValue(x[i][j]) > .9)	trace(Math.round(cplex.getValue(x[i][j])*100)/100+"\t");
					else								trace("-\t");
				} else									trace("-\t");
			}
			traceln();
		}
		trace("\n");*/

		//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp = new int[n+1];
		solution_temp[0] = n;
		for( int position = 0 ; position < n ; position++){
			for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
				if(solution_temp[position] != column_in_x)
					if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ] ) > 0.9){
						solution_temp[position+1] = column_in_x;
						break;
					}
			}//for(column_in_x)
		}//for(position)

		//convert solution_temp[] into 'route' ArrayList
		route.clear();
		route.add(this);	//start at current position
		for(int position = 1 ; position < n+1 ; position++)
			route.add(allocatedCities.get( solution_temp[position] ));
			
	}//if(cplex.solve)
	else{
		if(get_Main().debugOutput)	traceln(this+" has *NOT* found a route");
		assert allocatedCities.size() == 1;
		route = (ArrayList)allocatedCities.clone();
	}
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1456145550811</Id>
					<Name><![CDATA[solve_TSPojalgo]]></Name>
					<Description><![CDATA[CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Salesman agent
System.out.println(System.getProperty("java.library.path"));

Difference with solve_cplex_shortPath:
- current position not taken into account (since the salesman is assumed to start from the depot)
- the salesman goes to the depot, then does the loop and returns to the depot (solve_cplex_shortPath is quicker since it directly goes to the 1st city)]]></Description>
					<X>30</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace(get_Main().instance+"\tTSPo");

int n = allocatedCities.size();	//Index in CPLEX: 0='depot', 1..n-1='cities'
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = allocatedCities.get(city_i);
	//traceln();
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = allocatedCities.get(city_j);
		if( city_i != city_j)
			d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
		else
			d[city_i][city_j] = Double.MAX_VALUE;
		//trace("c["+city_i+"]["+city_j+"]="+d[city_i][city_j]+";\t");
	}
}
//traceln();

final ExpressionsBasedModel model = new ExpressionsBasedModel();
//DECISION VARIABLES
// x
final Variable[][] x = new Variable[n][n];
for(int i=0 ; i<n ; i++){
	for(int j=0 ; j<n ; j++)
		if(i!=j){
			x[i][j] = Variable.make("x"+i+"_"+j).binary().weight(d[i][j]);
			model.addVariable(x[i][j]);
		}
}
//u
final Variable[] u = new Variable[n];
for(int i=1 ; i<n ; i++){
	u[i] = new Variable("u"+i);
	model.addVariable(u[i]);
}

//CONSTRAINTS
//forall(i in cities)
//	flow_out:
//	sum(j in cities : i!=j) x[i][j]==1;
for(int i=0 ; i<n ; i++){
	final Expression constraint_line = model.addExpression("constraint_line"+i).lower(1).upper(1);
	for( int j=0 ; j<n ; j++){
		if( i!=j)
			constraint_line.setLinearFactor(x[i][j], 1);
	}
}

//forall(j in cities)
//	flow_in:
//	sum(i in cities : i!=j) x[i][j]==1;
for(int j=0 ; j<n ; j++){
	final Expression constraint_column = model.addExpression("constraint_column"+j).lower(1).upper(1);
	for( int i=0 ; i<n ; i++){
		if( i!=j)
			constraint_column.setLinearFactor(x[i][j], 1);
	}
}

//forall(i in cities: i>=1, j in cities: j>=1)
//	subroute:
//	u[i]-u[j]+n*x[i][j] <= n-1;
for(int i=1 ; i<n ; i++){
	for( int j=1 ; j<n ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n-1);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n);
		}
	}
}

long computationStartTime = System.currentTimeMillis() ;
Optimisation.Result result = model.minimise();
duration_of_last_call_to_the_solver = System.currentTimeMillis() - computationStartTime;
my_computation_time += duration_of_last_call_to_the_solver;

/*trace("\n\t  ");
for(int i=1 ; i<n ; i++)	trace(u[i].getValue().intValue()+" ");
trace("\n\t");
for(int i=0 ; i<n ; i++)	trace(citiesAllocated.get(i).getIndex()+" ");
traceln();
for(int i=0 ; i<n ; i++){
	trace(citiesAllocated.get(i).getIndex()+"\t");
	for(int j=0 ; j<n ; j++){
		trace(x[i][j].getValue().intValue() + " ");
	}
	traceln();
}*/

//BasicLogger.debug(result);

//Convert from 'x[][]' matrix into 'solution_temp[]'		
int[] solution_temp = new int[n+1];
solution_temp[0] = 0;	//start from the depot
for( int position = 0 ; position < n ; position++){
	for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
		if(solution_temp[position] != column_in_x){
			if( x[ solution_temp[position] ][ column_in_x ].getValue().doubleValue()  > 0.9){
				solution_temp[position+1] = column_in_x;
				break;
			}
				}
			}//for(column_in_x)
		}//for(position)

//convert solution_temp[] into 'route' ArrayList
route.clear();
//route.add(citiesOwned.get(0));
for(int position = 0 ; position < n+1 ; position++)
	route.add(allocatedCities.get( solution_temp[position] ));]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1456926101255</Id>
					<Name><![CDATA[solve_DTSPojalgo]]></Name>
					<Description><![CDATA[CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Salesman agent
System.out.println(System.getProperty("java.library.path"));

Difference with solve_cplex_shortPath:
- current position not taken into account (since the salesman is assumed to start from the depot)
- the salesman goes to the depot, then does the loop and returns to the depot (solve_cplex_shortPath is quicker since it directly goes to the 1st city)]]></Description>
					<X>163</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace(get_Main().instance+"\tDTSPo");

int n = allocatedCities.size();	//Index in CPLEX: 0='depot', 1..n-1='cities', n='position of salesman'
double[][] d = new double[n+1][n+1];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = allocatedCities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = allocatedCities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}
for(int city=0 ; city<allocatedCities.size() ; city++){
	d[city][n] = Math.sqrt( Math.pow(allocatedCities.get(city).getX()-getX(), 2) + Math.pow(allocatedCities.get(city).getY()-getY(), 2));
	d[n][city] = d[city][n];
}

d[0][allocatedCities.size()] = 0;	//TSP -ie, subroute elimination constraint 3- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route

final ExpressionsBasedModel model = new ExpressionsBasedModel();
//DECISION VARIABLES
// x
final Variable[][] x = new Variable[n+1][n+1];
for(int i=0 ; i<n+1 ; i++){
	for(int j=0 ; j<n+1 ; j++)
		if(i!=j){
			x[i][j] = Variable.make("x"+i+"_"+j).binary().weight(d[i][j]);
			model.addVariable(x[i][j]);
		}
}
//u
final Variable[] u = new Variable[n+1];
for(int i=1 ; i<n+1 ; i++){
	u[i] = new Variable("u"+i);
	u[i].lower(0);
	model.addVariable(u[i]);
}

//CONSTRAINTS
//forall(i in cities)
//	flow_out:
//	sum(j in cities : i!=j) x[i][j]==1;
for(int i=0 ; i<n+1 ; i++){
	final Expression constraint_line = model.addExpression("constraint_line"+i).lower(1).upper(1);
	for( int j=0 ; j<n+1 ; j++){
		if( i!=j)
			constraint_line.setLinearFactor(x[i][j], 1);
	}
}

//forall(j in cities)
//	flow_in:
//	sum(i in cities : i!=j) x[i][j]==1;
for(int j=0 ; j<n+1 ; j++){
	final Expression constraint_column = model.addExpression("constraint_column"+j).lower(1).upper(1);
	for( int i=0 ; i<n+1 ; i++){
		if( i!=j)
			constraint_column.setLinearFactor(x[i][j], 1);
	}
}

//forall(i in cities: i>=1, j in cities: j>=1)
//	subroute:
//	u[i]-u[j]+n*x[i][j] <= n-1;
for(int i=1 ; i<n+1 ; i++){
	for( int j=1 ; j<n+1 ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n+1);
		}
	}
}

long computationStartTime = System.currentTimeMillis() ;
Optimisation.Result result = model.minimise();
duration_of_last_call_to_the_solver = System.currentTimeMillis() - computationStartTime;
my_computation_time = duration_of_last_call_to_the_solver;

/* THIS DOES NOT WORK (but I  don't need it now)
trace("\n\t");
for(int i=0 ; i<n+1 ; i++)	trace(u[i].getValue().intValue()+" ");
trace("\n\t");
for(int i=0 ; i<n ; i++)	trace(citiesAllocated.get(i).getIndex()+" ");
traceln();
for(int i=0 ; i<n+1 ; i++){
	trace(citiesAllocated.get(i).getIndex()+"\t");
	for(int j=0 ; j<n+1 ; j++){
		trace(x[i][j].getValue().intValue() + " ");
	}
	traceln();
}*/

//BasicLogger.debug(result);

//Convert from 'x[][]' matrix into 'solution_temp[]'		
int[] solution_temp = new int[n+1];
solution_temp[0] = n;
for( int position = 0 ; position < n ; position++){
	for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
		if(solution_temp[position] != column_in_x)
			if( x[ solution_temp[position] ][ column_in_x ].getValue().doubleValue() > 0.9){
				solution_temp[position+1] = column_in_x;
				break;
			}
	}//for(column_in_x)
}//for(position)

//convert solution_temp[] into 'route' ArrayList
route.clear();
route.add(this);	//start at current position
for(int position = 1 ; position < n+1 ; position++)
	route.add(allocatedCities.get( solution_temp[position] ));]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[int]]></ReturnType>
					<Id>1460649730488</Id>
					<Name><![CDATA[nbReallocations]]></Name>
					<X>30</X><Y>40</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[int nbReallocations = 0;
for(Agent cityOwned : ownedCities)
	if( !allocatedCities.contains( cityOwned ) )
		nbReallocations++;
for(Agent cityAllocated : allocatedCities)
	if( !ownedCities.contains( cityAllocated))
		nbReallocations++;
return nbReallocations;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1465569837188</Id>
					<Name><![CDATA[solve_modifiedTSPcplex]]></Name>
					<Description><![CDATA[Conversely to other solve_...() functions, this one does NOT store the optimal result in 'route'.

Parameter give_to_guest == true -> give to guest (i.e., the optimal route is stored in P2P_city_proposed_to_guest)
Parameter give_to_guest == false -> give to host (i.e., the optimal route is stored in P2Pswap_city_proposed_to_host)

CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Salesman agent
System.out.println(System.getProperty("java.library.path"));

Difference with solve_cplex_shortPath:
- current position not taken into account (since the salesman is assumed to start from the depot)
- the salesman goes to the depot, then does the loop and returns to the depot (solve_cplex_shortPath is quicker since it directly goes to the 1st city)]]></Description>
					<X>163</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[give_to_guest_if_true_and_host_if_false]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[constraint5_for_Auction]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[constraint5_for_P2P]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[constraint5_for_CNP]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[//if(get_Main().consoleOutput)	{trace(get_Main().city_deltaY+"\tTSPc");	}
/*trace("solve_TSPcplex_give on: ");
for(City city : allocatedCities)
	trace(city +"\t");
traceln();*/

IloCplex cplex;
int n = allocatedCities.size();	//Index in CPLEX: 0='depot', 1..n-1='cities'
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = allocatedCities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = allocatedCities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}
double CPLEXrouteLength = 0;

CNP_city_to_get_rid_of = null;

/*trace("solve_TSPcplex_give" + this+": ");
for(Agent city : allocatedCities)
	trace(city+"\t");
traceln();*/

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(n);
	}
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	IloNumVar[] kept = cplex.boolVarArray(n);
	
	// Objective
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				obj.addTerm(d[i][j], x[i][j]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// Constraint 1: for each node j, only one leaving edge
	// FORALL j, SUM_i(i<>j) x[i][j] = kept[j]
	for(int j=0 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  kept[j]);
	}//for(j)
	
	// Constraint 2: for each node i, only one entering edge
	// FORALL i, SUM_j(i<>j) x[i][j] = kept[i]
	for(int i=0 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  kept[i]);
	}//for(i)
	
	// Constraint 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-1
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,		x[i][j]);
				cplex.addLe(expr,	n-1);
			}//if
		}//for(j)
	}//for(i)
	
	// Constraint 4: one of the cities is not visited
	IloLinearNumExpr constraint4 = cplex.linearNumExpr();
	for(int i=1; i<n ; i++)
		constraint4.addTerm(1.0, kept[i]);
	cplex.addEq(constraint4, n-2);
	

/*	// Constraint 5 (version for P2P): any previously proposed city i has kept[i]=true
	if(give_to_guest_if_true_and_host_if_false)//if called from P2Pswap6_host_proposes_city_to_guest
	{
		for(int city=0 ; city<n ; city++){
			int nb_salesmen_who_have_been_proposed_this_city = 0;
			for(Salesman salesman : get_Main().salesmen)
				if( salesman != this )
				{
					if( propCities[salesman.getIndex()][ allocatedCities.get( city ).getIndex() ] == true)
						nb_salesmen_who_have_been_proposed_this_city++;
				}//if(salesman)
				if (nb_salesmen_who_have_been_proposed_this_city >= get_Main().salesmen.size()-1 ){
						if(get_Main().debugOutput) traceln(this+ ": solve_TSPcplex_give() uses kept["+allocatedCities.get( city )+"]=true");
						IloLinearNumExpr constraint5 = cplex.linearNumExpr();
						constraint5.addTerm(1.0, kept[ city ]);
						cplex.addEq(constraint5, 1);
						
				}//if(nb_salesmen_who_have_been_proposed_this_city)
		}//for(city)
	}//if(P2Pswap6_host_proposes_city_to_guest)*/
	
	// Constraint 5 (version for P2P): any previously proposed city i has kept[i]=true
	//if( get_Main().selectedAllocationMechanism == 6 )
	if(constraint5_for_P2P)
	{
		Agent otherAgent;
		if(give_to_guest_if_true_and_host_if_false == false)
			otherAgent = host;
		else
			otherAgent = guest;
		
		for(City city : allocatedCities){
			if( propCities[otherAgent.getIndex()][ city.getIndex() ] == true){
				//if(get_Main().debugOutput)	traceln(this+ ": solve_TSPcplex_give() uses kept["+city+"]=true because this city has already been proposed to "+otherAgent);
				IloLinearNumExpr constraint5 = cplex.linearNumExpr();
				constraint5.addTerm(1.0, kept[ allocatedCities.indexOf(city) ]);
				cplex.addEq(constraint5, 1);
			}//if(nb_salesmen_who_have_been_proposed_this_city)
		}//for(city)
	}//if(P2Pswap6_host_proposes_city_to_guest)
	// Constraint 5 (version for Auction): if City "city' previously proposed, then kept[city] = 1;
	//if( get_Main().selectedAllocationMechanism == 5 ){
	if(constraint5_for_Auction){
		for(int city = 0; city < n ; city++){
			//trace("kept=1 for " + citiesAllocated.get(city).getIndex() + "="+previously_proposed_cities[0][ citiesAllocated.get(city).getIndex() ]+"\t");
			if( propCities[0][ allocatedCities.get(city).getIndex() ] ){
				//traceln("kept=1 for "+citiesAllocated.get(city));
				IloLinearNumExpr constraint5 = cplex.linearNumExpr();
				constraint5.addTerm(1.0, kept[ city ]);
				//if(get_Main().debugOutput)	traceln(this+": solve_TSPcplex_give -> kept["+allocatedCities.get(city)+"]=true");
				cplex.addEq(constraint5, 1);
			}
		}
	}
	// Constraint 5 (version for host in CNP): if City "city' previously proposed TO ALL salesmen, then kept[city] = 1;
	if(constraint5_for_CNP){
		for(int city = 0; city < n ; city++){
			int number_of_trues_in_propCities = 0;
			for(int salesman=0 ; salesman<get_Main().salesmen.size() ; salesman++)
				if(salesman!=this.getIndex())
					if( propCities[ salesman ][ allocatedCities.get(city).getIndex() ] )
						number_of_trues_in_propCities++;
			//if(get_Main().debugOutput)	traceln("constraint5_for_CNP city="+allocatedCities.get(city).getIndex()+" number_of_trues_in_propCities="+number_of_trues_in_propCities);
			if(number_of_trues_in_propCities++ == get_Main().salesmen.size()-1){
				IloLinearNumExpr constraint5 = cplex.linearNumExpr();
				constraint5.addTerm(1.0, kept[ city ]);
				if(get_Main().debugOutput)	traceln(this+": solve_TSPcplex_give -> kept["+allocatedCities.get(city)+"]=true");
				cplex.addEq(constraint5, 1);
			}//if(keep)
		}//for(city)
	}//if(constraint5_for_CNP)
	
	// write model to file
	//cplex.exportModel("salesman" + getIndex() + ".lp");
	cplex.setOut(null);

	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime <= 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}		
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		duration_of_last_call_to_the_solver = computationEndTime - computationStartTime;
//if(get_Main().debugOutput)	traceln(this+"\tsolve_modifiedTSPcplex duration_of_last_call_to_solve=\t"+duration_of_last_call_to_the_solver);
		my_computation_time += duration_of_last_call_to_the_solver;
		//if(get_Main().debugOutput)	System.err.println(this+" TSPgive get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		
/*		//Display the result found by CPLEX
		trace("\nx[][] =\t");
		for(int city=0 ; city<n ; city++)
			trace("C"+ city +"\t");
		trace("\ncities=\t");
		for(int city=0 ; city<n ; city++)
			trace(allocatedCities.get( city )+"\t");
		trace("\nkept[]=\t");
		for(int i=0 ; i<n ; i++)
			trace(cplex.getValue( kept[i]) +"\t");
		for(int i=0; i<n ; i++){
			System.out.print("\nL"+i+"\t");
			for(int j=0; j<n ; j++){
				if(i!=j){
					if(cplex.getValue(x[i][j]) > .9)	trace(cplex.getValue(x[i][j])+"\t");
					else								trace("\t");
				} else									trace("-\t");
			}
		}
		trace("\n");	*/

		//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp = new int[n+1];
		solution_temp[0] = 0;	//start from the depot
		for( int position = 0 ; position < n-1 ; position++){
			for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
				if(solution_temp[position] != column_in_x){
					if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ] ) > 0.9){
						solution_temp[position+1] = column_in_x;
						break;
					}
				}
			}//for(column_in_x)
		}//for(position)

		//convert solution_temp[] into 'route' ArrayList
		route_found_by_solve_modifiedTSPcplex.clear();
		//route.add(citiesAllocated.get(0));
		for(int position = 0 ; position < n ; position++)
			route_found_by_solve_modifiedTSPcplex.add(allocatedCities.get( solution_temp[position] ));
		
		//traceln("cplex.getObjVal()="+cplex.getObjValue());
		//traceln("reouteL" + routeLength());


		for(int city=0 ; city<n ; city++)
			if(cplex.getValue( kept[city] )<0.1)
				CNP_city_to_get_rid_of=allocatedCities.get( city );

		CPLEXrouteLength = cplex.getObjValue();
		if(give_to_guest_if_true_and_host_if_false){
			possible_saving_from_giving	= routeLength() - CPLEXrouteLength;
			//traceln("P2P_possible_saving_from_giving_to_guest="+P2P_possible_saving_from_giving_to_guest	+" = routeLength()="+routeLength() + " - cplex.getObjValue()="+cplex.getObjValue());
		}
		else
			OLD_P2Pswap_possible_saving_of_host	= routeLength() - CPLEXrouteLength;
		
		for(int city=1; city<n; city++)
			if(cplex.getValue( kept[city] )<0.1){
				if(give_to_guest_if_true_and_host_if_false)
					city_proposed_to_guest		= allocatedCities.get( city );
				else
					city_proposed_to_host	= allocatedCities.get( city );
				break;
			}
			
	}//if(cplex.solve)
	else{
		//if(get_Main().debugOutput)	traceln(this+" solve_TSPcplex_give(): No solution found");
		if( constraint5_for_Auction ){
			city_proposed_to_guest = null;
			CNP_city_to_get_rid_of = null;
			possible_saving_from_giving = Double.MIN_VALUE;
		}
		else{
			//assert allocatedCities.size() == 1;
			//route = (ArrayList)allocatedCities.clone();
		}
	}
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}
return CPLEXrouteLength;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1481551399702</Id>
					<Name><![CDATA[routeLength_verbose]]></Name>
					<X>510</X><Y>-30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[double length = 0;
//trace("\nrouteLength()=");
for( int city = 0 ; city < route.size()-1 ; city++ ){
	trace(""+route.get(city).getIndex()+"->"+route.get(city+1).getIndex()+"="+ (int)Math.sqrt( Math.pow( route.get(city).getX() - route.get(city+1).getX(), 2) + Math.pow( route.get(city).getY() - route.get(city+1).getY(), 2))+"  ");
	length += Math.sqrt( Math.pow( route.get(city).getX() - route.get(city+1).getX(), 2) + Math.pow( route.get(city).getY() - route.get(city+1).getY(), 2));
}

return length;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1429198016241</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[P2PWR]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[Auction]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[OLD_P2Pswap]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[P2PWR_OLD]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[P2P_host]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[P2P_guest]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[CNP_host]]></ItemName>
					</StatechartReference>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Salesman]]></ClassName>
						<ItemName><![CDATA[CNP_guest]]></ItemName>
					</StatechartReference>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1429198045127</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Shapes>
				<Oval>
					<Id>1433166886185</Id>
					<Name><![CDATA[ovalShape]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>0</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>0</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-65536</LineColor>
					<LineColorCode><![CDATA[color]]></LineColorCode>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<RadiusX>25</RadiusX>
					<RadiusY>40</RadiusY>
					<Rotation>0.0</Rotation>
					<FillColor/>
					<FillMaterial>null</FillMaterial>
				</Oval>
				<Text>
					<Id>1434985343965</Id>
					<Name><![CDATA[salesmanText]]></Name>
					<X>-20</X><Y>-15</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<ColorCode><![CDATA[color]]></ColorCode>
					<Text><![CDATA[0]]></Text>
					<TextCode><![CDATA[getIndex()]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Polyline>
					<Id>1435048152461</Id>
					<Name><![CDATA[salesmanShape]]></Name>
					<X>-10</X><Y>5</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[if(get_Main().mouseMode==0){
	if( get_Main().selectedSalesman > -1)
		get_Main().salesmen.get( get_Main().selectedSalesman ).ovalShape.setVisible(false);
	else
		for(Salesman salesman : get_Main().salesmen)
			salesman.ovalShape.setVisible(false);
	get_Main().selectedSalesman = getIndex();
	ovalShape.setVisible(true);
	//get_Main().globalOptimization = false;
}]]></OnClickCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16777216</FillColor>
					<FillColorCode><![CDATA[color]]></FillColorCode>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>30</X><Y>-5</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-10</Y><Z>0</Z></Point>
					</Points>
					<Closed>false</Closed>
				</Polyline>
				<Line>
					<Id>1497443102158</Id>
					<Name><![CDATA[line]]></Name>
					<X>10</X><Y>593</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>1060</Dx>
					<Dy>0</Dy>
					<Dz>0</Dz>
				</Line>
				<Line>
					<Id>1497443108125</Id>
					<Name><![CDATA[line1]]></Name>
					<X>786</X><Y>593</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>0</Dx>
					<Dy>-340</Dy>
					<Dz>0</Dz>
				</Line>
			</Shapes>
			<Controls>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1445506601780</Id>
					<Name><![CDATA[maxReallocations_editbox2]]></Name>
					<X>150</X><Y>10</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[0]]></MinValue>
						<MaxValue><![CDATA[get_Main().cities.size()]]></MaxValue>
						<LinkTo>true</LinkTo>
						<Link>maxReallocations</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1493045671191</Id>
					<Name><![CDATA[button_previously_proposed_cities]]></Name>
					<X>300</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[get_Main().button_previously_proposed_cities.action();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Prev. prop._cities]]></LabelText>
					</ExtendedProperties>
				</Control>
			</Controls>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1459942693471</Id>
			<Name><![CDATA[CentralAuthority]]></Name>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<Import><![CDATA[import ilog.concert.*;									// import CPLEX
import ilog.cplex.*;									// import CPLEX

import org.ojalgo.OjAlgoUtils;							//import ojalgo
import org.ojalgo.netio.BasicLogger;					//import ojalgo
import org.ojalgo.optimisation.Expression;				//import ojalgo
import org.ojalgo.optimisation.ExpressionsBasedModel;	//import ojalgo
import org.ojalgo.optimisation.Optimisation;			//import ojalgo
import org.ojalgo.optimisation.Variable;				//import ojalgo
import java.math.BigDecimal;							//import ojalgo
import org.ojalgo.optimisation.linear.LinearSolver;]]></Import>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1459942693470</Id>
				<Name><![CDATA[1459942693470]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<AgentProperties>
	 			<SpaceType>CONTINUOUS</SpaceType>			
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>true</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1460016000000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1459942693468</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<ConnectionsId>1459942693467</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1467193844540</Id>
					<Name><![CDATA[number_of_replies]]></Name>
					<X>220</X><Y>632</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1467202708849</Id>
					<Name><![CDATA[list_of_savings]]></Name>
					<X>40</X><Y>630</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double[][]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1473082619547</Id>
					<Name><![CDATA[list_of_bids]]></Name>
					<X>40</X><Y>590</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[City[]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1473695681005</Id>
					<Name><![CDATA[list_of_bidders]]></Name>
					<X>40</X><Y>612</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[Salesman[]]]></Type>        
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1473784555633</Id>
					<Name><![CDATA[number_of_rounds]]></Name>
					<X>220</X><Y>610</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1473784760662</Id>
					<Name><![CDATA[number_of_messages_received]]></Name>
					<X>220</X><Y>650</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1473785273922</Id>
					<Name><![CDATA[my_computation_time]]></Name>
					<X>40</X><Y>650</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[long]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
			</Variables>
			<StatechartElements>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1459942736225</Id>
					<Name><![CDATA[A0_initialisation]]></Name>
					<X>30</X><Y>250</Y>
					<Label><X>55</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="210" Height="20">
						<EntryAction><![CDATA[list_of_bids	= new City[ get_Main().salesmen.size() ];

list_of_bidders	= new Salesman[ get_Main().salesmen.size() ];
for(Salesman salesman : get_Main().salesmen)
	list_of_bidders[ salesman.getIndex() ] = salesman;]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1459942766936</Id>
					<Name><![CDATA[A2_broadcast_RFPs]]></Name>
					<X>30</X><Y>300</Y>
					<Label><X>50</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<EntryAction><![CDATA[list_of_savings = new double[ get_Main().salesmen.size() ][ get_Main().salesmen.size() ];
number_of_replies = 0;
number_of_rounds++;

if(get_Main().debugOutput){
	traceln("\n0   "+this+"\t\tROUND "+number_of_rounds+"\t\t\troute length="+get_Main().routeLength());
	//getEngine().pause();
}

for(Salesman salesman : list_of_bidders){
	if(get_Main().debugOutput)	traceln("2   "+this+" is sending a Request For Proposals to " + salesman);
	send( "Request For Proposals", salesman);
}

get_Main().durations_of_calls_to_the_solver.add(new double[2*get_Main().salesmen.size()+1]);]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1467194296167</Id>
					<Name><![CDATA[A6_wait_for_all_proposals]]></Name>
					<X>30</X><Y>350</Y>
					<Label><X>55</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1467200588585</Id>
					<Name><![CDATA[A14_send_allocation_of_cities]]></Name>
					<X>30</X><Y>500</Y>
					<Label><X>35</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<EntryAction><![CDATA[/*
	Decrease remainingComputationTime by the duration of the salesmen's A10_bid_on_every_proposed_city
	(i.e., by the max of their duration because they are executed in parallel)
*/
double max_of_durations_of_calls_to_the_solver = 0;
for(int i=get_Main().salesmen.size() ; i<2*get_Main().salesmen.size() ; i++){
	if( max_of_durations_of_calls_to_the_solver < get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i])
		max_of_durations_of_calls_to_the_solver = get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i];
//	traceln(" A14-salesman "+i+": "+get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i]);
}

if( get_Main().remainingComputationTime -  max_of_durations_of_calls_to_the_solver > 0)
	get_Main().remainingComputationTime -= max_of_durations_of_calls_to_the_solver;
else if(get_Main().remainingComputationTime != -Double.MAX_VALUE)
	get_Main().remainingComputationTime = 0;
//if(get_Main().debugOutput)	traceln("14 "+this+" max_of_durations_of_calls_to_the_solver="+max_of_durations_of_calls_to_the_solver+ " get_Main().remainingComputationTime="+get_Main().remainingComputationTime);
			
			
/*

*/


IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();

if(get_Main().debugOutput){
	trace("14  SAVING_FROM_GIVING_THIS_CITY=\t");
	for(int salesman=0 ; salesman < list_of_bids.length ; salesman++)
		trace(list_of_bids[salesman]+"\t");
	traceln();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		trace("14  "+this+" " + list_of_bidders[salesman] + "\t");
		for(int city=0 ; city < list_of_bidders.length ; city++){
			trace(list_of_savings[ salesman ][ city ]+"\t");
		}//for(j)
		traceln();
	}//for(i)
}

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[ list_of_bidders.length ][];
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		x[ salesman ] = cplex.boolVarArray( n );
	}
	
	// Objective
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		for(int city=0 ; city < list_of_bidders.length ; city++){
			obj.addTerm(list_of_savings[ salesman ][ city ], x[ salesman ][ city ]);
		}//for(j)
	}//for(i)
	cplex.addMinimize(obj);
	
	// Constraint 1: each salesman k receives 1 city
	// FORALL i, SUM_j( x[k][i] ) == 1
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int city=0 ; city < list_of_bidders.length ; city++){
			expr.addTerm(1.0, x[ salesman ][ city ]);
		}//for(i)
			cplex.addEq(expr, 1);
	}//for(j)

	// Constraint 2: each city is allocated to 0 or 1 salesman
	// FORALL i, SUM_k( x[k][i] ) <= 1
	for(int city=0 ; city < list_of_bidders.length ; city++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
			expr.addTerm(1.0, x[ salesman ][ city ]);
		}//for(j)
		cplex.addLe(expr, 1);
	}//for(i)
	
	// Constraint 3: each salesman will have a route length shorter to what he has, otherwise he receives the city he is proposing
	// FORALL k, SUM i( x[k][i].saving_from_giving_this_city[k][i] <= saving_from_giving_this_city[k][k] )
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int city=0 ; city < list_of_bidders.length ; city++)
			expr.addTerm(list_of_savings[ salesman ][ city ], x[ salesman ][ city ]);
		cplex.addLe(expr, list_of_savings[salesman][salesman]);
	}//for(salesman)
	
	cplex.setOut(null);
	
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1);
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}	
	
	long computationStartTime = System.currentTimeMillis();
	long computation_time = 0;
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computation_time = System.currentTimeMillis() - computationStartTime;
		my_computation_time += computation_time;
		//if(get_Main().debugOutput)	traceln("solution found");
		
		
		if( get_Main().remainingComputationTime -  computation_time > 0)
			get_Main().remainingComputationTime -= computation_time;
		else if(-Double.MAX_VALUE != -Double.MAX_VALUE)
			get_Main().remainingComputationTime = 0;
		get_Main().durations_of_calls_to_the_solver.get(get_Main().durations_of_calls_to_the_solver.size()-1)[2*get_Main().salesmen.size()] = computation_time ;
		//if(get_Main().debugOutput)	traceln("14 "+this+" remainingComputationTime="+get_Main().remainingComputationTime);


		
		for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
			for(int city=0 ; city < list_of_bidders.length ; city++){
				if( cplex.getValue( x[ salesman ][ city ] )>.9 ){
					if(get_Main().debugOutput)	traceln("14  " + this + " ALLOCATES " + list_of_bids[city]+" to " + list_of_bidders[salesman] );
					send( list_of_bids[city], list_of_bidders[salesman] );
					break;
				}//if
			}//for(city)
		}//for(salemsan)
	}//if ( cplex.solve() )
	cplex.end();
}
catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1467210279895</Id>
					<Name><![CDATA[A8_broadcast_proposed_cities]]></Name>
					<X>30</X><Y>400</Y>
					<Label><X>40</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<EntryAction><![CDATA[/*
	Decrease remainingComputationTime by the duration of the salesmen's A4_propose_a_city_to_give
	(i.e., by the max of their duration because they are executed in parallel)
*/
//take the duration time of the parallel calls to CPLEX in the guests' CNP5 into account
double max_of_durations_of_calls_to_the_solver = 0;
for(int i=0 ; i<get_Main().salesmen.size() ; i++){
	if( max_of_durations_of_calls_to_the_solver < get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i])
		max_of_durations_of_calls_to_the_solver = get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i];
	//traceln(" A4-salesman "+i+": "+get_Main().durations_of_calls_to_the_solver.get( get_Main().durations_of_calls_to_the_solver.size()-1 )[i]);
}

if( get_Main().remainingComputationTime -  max_of_durations_of_calls_to_the_solver > 0)
	get_Main().remainingComputationTime -= max_of_durations_of_calls_to_the_solver;
else if(get_Main().remainingComputationTime != -Double.MAX_VALUE)
	get_Main().remainingComputationTime = 0;
//if(get_Main().debugOutput)	traceln("8 "+this+" max_of_durations_of_calls_to_the_solver="+max_of_durations_of_calls_to_the_solver+ " \tget_Main().remainingComputationTime="+get_Main().remainingComputationTime);


/*
	Broadcast the list of the cities bid by the salesmen
*/
int number_of_salesmen_who_keep_trading = 0;
for( int salesman=0; salesman<list_of_bids.length; salesman++)
	if(list_of_bids[ salesman ] != null)
		number_of_salesmen_who_keep_trading++;

City[]		NEW_list_of_bids	= new City[ number_of_salesmen_who_keep_trading ];
Salesman[]	NEW_list_of_bidders	= new Salesman[number_of_salesmen_who_keep_trading];

double[][]	NEW_saving_from_giving_this_city = new double[ number_of_salesmen_who_keep_trading ][ number_of_salesmen_who_keep_trading ];

int index_new = 0;
for( int index_old=0 ; index_old < list_of_bids.length ; index_old++){
	if( list_of_bids[ index_old ] != null){
		NEW_list_of_bids[ index_new ]		= list_of_bids[ index_old ];
		NEW_list_of_bidders[ index_new ]	= list_of_bidders[index_old];
		NEW_saving_from_giving_this_city[ index_new ][ index_new ]	= list_of_savings[ index_old ][ index_old ];
		index_new++;
	}
}
list_of_bidders					= NEW_list_of_bidders;
list_of_bids					= NEW_list_of_bids;
list_of_savings	= NEW_saving_from_giving_this_city;

if(get_Main().debugOutput){
	trace("8   "+this+" broadcast cities to "+number_of_salesmen_who_keep_trading+" salesmen: ");
	for(int i=0 ; i<list_of_bids.length ; i++){
		trace("[bids["+i+"]="+list_of_bids[i]+" bidders["+i+"]="+list_of_bidders[i]+"]\t");
	}
	traceln();
}

if( number_of_salesmen_who_keep_trading < 2 || get_Main().remainingComputationTime == 0){
	get_Main().consoleOutput = get_Main().consoleOutput_backup;
	if(get_Main().debugOutput)	traceln("\tEND OF AUCTION");
}
else{	//send the list of cities proposed for trading only to the salesmen who proposed a city
	if(get_Main().debugOutput)	trace(" -> Sending " + list_of_bids + " to ");
	for(int salesman=0 ; salesman < number_of_salesmen_who_keep_trading ; salesman++){
		if(get_Main().debugOutput)	trace(list_of_bidders[ salesman ]+"\t");
		send( list_of_bids, list_of_bidders[ salesman ]);
	}//for
	if(get_Main().debugOutput){
		for(int i=0 ; i<list_of_bidders.length ; i++)
			trace(" bidders["+i+"]="+list_of_bidders[i]);
		traceln();
	}
}//else
if(get_Main().debugOutput)	traceln();]]></EntryAction>
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1473090546279</Id>
					<Name><![CDATA[A12_wait_for_all_lists_of_bids]]></Name>
					<X>30</X><Y>450</Y>
					<Label><X>25</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="State" ParentState="ROOT_NODE">
					<Id>1473350025760</Id>
					<Name><![CDATA[A18_wait_for_all_acknowledgements]]></Name>
					<X>30</X><Y>550</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties Width="270" Height="20">
						<FillColor/>
					</Properties>
				</StatechartElement>
				<StatechartElement Class="EntryPoint" ParentState="ROOT_NODE">
					<Id>1459942732776</Id>
					<Name><![CDATA[Auction]]></Name>
					<X>150</X><Y>230</Y>
					<Label><X>-65</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
					</Points>
					<Properties Target="1459942736225">
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1459942808647</Id>
					<Name><![CDATA[A0_start]]></Name>
					<X>50</X><Y>270</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1459942736225" Target="1459942766936" Trigger="condition">
						<Action><![CDATA[get_Main().consoleOutput = false;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[get_Main().selectedAllocationMechanism == 5]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1467194235530</Id>
					<Name><![CDATA[A5_receive_a_proposal]]></Name>
					<X>50</X><Y>320</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1459942766936" Target="1467194296167" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;

int sender_index = -1;
for(int index=0 ; index < list_of_bidders.length ; index++)
	if( list_of_bidders[ index ] == msg.sender ){
		sender_index = index;
		break;
	}
assert sender_index > -1;

list_of_bids[ sender_index ] = msg.city;
list_of_savings[ sender_index ][ sender_index ] = 0.999999 * msg.savingFromGivingThisCity;	//0.999999 is a trick that ensures that Auc_13_allocate_cities always allocates a city to its proposer in the symetric example used to debug (otherwise, the auctioneer is indifferent between two allocations and may thus loop forever between them)
if(get_Main().debugOutput)	traceln("5   "+this+" has received " + msg + " from "+msg.sender+" msg.savingFromGivingThisCity="+msg.savingFromGivingThisCity);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1467194456502</Id>
					<Name><![CDATA[A5b_receive_a_proposal]]></Name>
					<X>290</X><Y>370</Y>
					<Label><X>55</X><Y>-5</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>10</X><Y>10</Y></Point>
						<Point><X>230</X><Y>10</Y></Point>
						<Point><X>230</X><Y>-30</Y></Point>
						<Point><X>20</X><Y>-30</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>50.0</IconOffset>
					<Properties Source="1467194296167" Target="1467194296167" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;

int sender_index = -1;
for(int index=0 ; index < list_of_bidders.length ; index++)
	if( list_of_bidders[ index ] == msg.sender ){
		sender_index = index;
		break;
	}
assert sender_index > -1;

list_of_bids[ sender_index ] = msg.city;
list_of_savings[ sender_index ][ sender_index ] = 0.999999 * msg.savingFromGivingThisCity;	//0.999999 is a trick that ensures that Auc_13_allocate_cities always allocates a city to its proposer in the symetric example used to debug (otherwise, the auctioneer is indifferent between two allocations and may thus loop forever between them)
if(get_Main().debugOutput)	traceln("5b  "+this+" has received " + msg + " from "+msg.sender+" msg.savingFromGivingThisCity="+msg.savingFromGivingThisCity);]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[P2P_offer_proposition]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1467200599046</Id>
					<Name><![CDATA[A7_all_proposals_received]]></Name>
					<X>50</X><Y>370</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1467194296167" Target="1467210279895" Trigger="condition">
						<Action><![CDATA[if(get_Main().debugOutput)	if(get_Main().debugOutput)	traceln("7   "+this+" has received all proposals");
number_of_replies = 0;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[number_of_replies == list_of_bidders.length]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1467210289698</Id>
					<Name><![CDATA[A13_all_bids_received]]></Name>
					<X>50</X><Y>470</Y>
					<Label><X>5</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1473090546279" Target="1467200588585" Trigger="condition">
						<Action><![CDATA[number_of_replies=0;
if(get_Main().debugOutput){
	traceln("13  " + this+ " has received the bids from all the salesmen");
	for(int i=0; i<list_of_bidders.length; i++)
		traceln("13  "+this+" list_of_bidders["+i+"]="+list_of_bidders[i]);
	for(int i=0; i<list_of_bids.length ; i++)
		traceln("13  "+this+" list_of_bids="+list_of_bids[i]);
}]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[number_of_replies == list_of_bidders.length]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473086168395</Id>
					<Name><![CDATA[A11_receive_a_list_of_bids]]></Name>
					<X>50</X><Y>420</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1467210279895" Target="1473090546279" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;
/*if(get_Main().debugOutput){
	trace("11  " + this + " BEFORE " + msg);
	for(int city=0 ; city < list_of_bids.length ; city++)
		trace(list_of_bids[ city ]+"\t");
	traceln();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		trace("11  "+this+ " "+list_of_bidders[salesman]+"\t");
		for( int city=0 ; city < list_of_bidders.length ; city++ ){
			trace(saving_from_giving_this_city[salesman][city]+"\t");
		}
		traceln();
	}
}*/

//find the index of 'msg.sender' in 'salesmen_who_keep_trading'
int sender_index = -1;
for(int index = 0 ; index < list_of_bidders.length ; index++)
	if(list_of_bidders[ index ] == msg.sender){
	sender_index = index;
	break;
	}
	
double[] received_list_of_bids = (double[])msg.content;
if(get_Main().debugOutput)	trace("11  " + this + " receives proposal: " + msg.sender + " can visit\t");
for( int city=0 ; city < list_of_bidders.length ; city++)
	if(city!=sender_index){
		list_of_savings[sender_index][city] = received_list_of_bids[city];
		if(get_Main().debugOutput)	trace( list_of_bids[ city] + " for " + list_of_savings[sender_index][city] +"\t") ;
	}
if(get_Main().debugOutput)	traceln();

/*if(get_Main().debugOutput){
	trace("11  " + this + " AFTER " + msg);
	for(int city=0 ; city < list_of_bids.length ; city++)
		trace(list_of_bids[ city ]+"\t");
	traceln();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		trace("11  "+this+ " "+list_of_bidders[salesman]+"\t");
		for( int city=0 ; city < list_of_bidders.length ; city++ ){
			trace(saving_from_giving_this_city[salesman][city]+"\t");
		}
		traceln();
	}
}*/]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Message]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473090888486</Id>
					<Name><![CDATA[A11b_receive_a_list_of_bids]]></Name>
					<X>290</X><Y>470</Y>
					<Label><X>30</X><Y>-5</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>10</X><Y>10</Y></Point>
						<Point><X>230</X><Y>10</Y></Point>
						<Point><X>230</X><Y>-30</Y></Point>
						<Point><X>20</X><Y>-30</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>50.0</IconOffset>
					<Properties Source="1473090546279" Target="1473090546279" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;
/*if(get_Main().debugOutput){
	trace("11b " + this + " BEFORE " + msg);
	for(int city=0 ; city < list_of_bids.length ; city++)
		trace(list_of_bids[ city ]+"\t");
	traceln();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		trace("11b "+this+ " "+list_of_bidders[salesman]+"\t");
		for( int city=0 ; city < list_of_bidders.length ; city++ ){
			trace(saving_from_giving_this_city[salesman][city]+"\t");
		}
		traceln();
	}
}*/

//find the index of 'msg.sender' in 'salesmen_who_keep_trading'
int sender_index = -1;
for(int index = 0 ; index < list_of_bidders.length ; index++)
	if(list_of_bidders[ index ] == msg.sender){
	sender_index = index;
	break;
	}
	
double[] received_list_of_bids = (double[])msg.content;
if(get_Main().debugOutput)	trace("11b " + this + " receives proposal: " + msg.sender + " can visit\t");
for( int city=0 ; city < list_of_bidders.length ; city++)
	if(city!=sender_index){
		list_of_savings[sender_index][city] = received_list_of_bids[city];
		if(get_Main().debugOutput)	trace( list_of_bids[ city] + " for " + list_of_savings[sender_index][city] +"\t") ;
	}
if(get_Main().debugOutput)	traceln();

/*if(get_Main().debugOutput){
	trace("11b " + this + " AFTER " + msg);
	for(int city=0 ; city < list_of_bids.length ; city++)
		trace(list_of_bids[ city ]+"\t");
	traceln();
	for(int salesman=0 ; salesman < list_of_bidders.length ; salesman++){
		trace("11b "+this+ " "+list_of_bidders[salesman]+"\t");
		for( int city=0 ; city < list_of_bidders.length ; city++ ){
			trace(saving_from_giving_this_city[salesman][city]+"\t");
		}
		traceln();
	}
}*/]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Message]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473164308695</Id>
					<Name><![CDATA[A17_receive_an_acknowledgement]]></Name>
					<X>50</X><Y>520</Y>
					<Label><X>10</X><Y>10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>30</Y></Point>
					</Points>
					<IconOffset>10.0</IconOffset>
					<Properties Source="1467200588585" Target="1473350025760" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;
if(get_Main().debugOutput)	traceln("17  "+this+" has received an acknowledgement");]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[String]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[equalsTo]]></FilterType>
						<EqualsExpression><![CDATA["Acknowledgement"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473350093938</Id>
					<Name><![CDATA[A17bis_receive_an_acknowldg]]></Name>
					<X>290</X><Y>570</Y>
					<Label><X>15</X><Y>-5</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>10</X><Y>10</Y></Point>
						<Point><X>230</X><Y>10</Y></Point>
						<Point><X>230</X><Y>-30</Y></Point>
						<Point><X>20</X><Y>-30</Y></Point>
						<Point><X>0</X><Y>-20</Y></Point>
					</Points>
					<IconOffset>50.0</IconOffset>
					<Properties Source="1473350025760" Target="1473350025760" Trigger="message">
						<Action><![CDATA[number_of_replies++;
number_of_messages_received++;
if(get_Main().debugOutput)	traceln("17b "+this+" has received an acknowledgement");]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[true]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[String]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[equalsTo]]></FilterType>
						<EqualsExpression><![CDATA["Acknowledgement"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
				<StatechartElement Class="Transition" ParentState="ROOT_NODE">
					<Id>1473350240664</Id>
					<Name><![CDATA[A20_start_over]]></Name>
					<X>150</X><Y>570</Y>
					<Label><X>170</X><Y>-275</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Points>
						<Point><X>0</X><Y>0</Y></Point>
						<Point><X>0</X><Y>20</Y></Point>
						<Point><X>380</X><Y>20</Y></Point>
						<Point><X>380</X><Y>-260</Y></Point>
						<Point><X>150</X><Y>-260</Y></Point>
					</Points>
					<IconOffset>760.0</IconOffset>
					<Properties Source="1473350025760" Target="1459942766936" Trigger="condition">
						<Action><![CDATA[number_of_replies=0;]]></Action>
						<Timeout Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="TimeUnits"><![CDATA[HOUR]]></Unit>
						</Timeout>
						<Condition><![CDATA[number_of_replies == list_of_bidders.length]]></Condition>
						<Rate Class="CodeUnitValue">
							<Code><![CDATA[1]]></Code>
							<Unit Class="RateUnits"><![CDATA[PER_HOUR]]></Unit>
						</Rate>
						<MessageType><![CDATA[Object]]></MessageType>
						<DefaultTransition>true</DefaultTransition>
						<FilterType><![CDATA[unconditionally]]></FilterType>
						<EqualsExpression><![CDATA["text"]]></EqualsExpression>
						<SatisfiesExpression><![CDATA[true]]></SatisfiesExpression>
					</Properties>	
				</StatechartElement>
			</StatechartElements>
			<Functions>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484573144522</Id>
					<Name><![CDATA[solve_cluster_Saglam]]></Name>
					<Description><![CDATA[Source of this clustering method: Section 3 B. Saglam ,  F. S. Salman, S. Sayin & M. Türkay, "A mixed-integer approach to the clustering problem with an appplication in customer segmentation", European Journal of Operational Research, 2006, 173:866-879.
(Formulation very close to solve_clustering2() which uses Section 5 in M. R. Rao, "Cluster analysis and mathematical programming", Journal of the American Statistical Association, September 1971, 66(335):622-626.]]></Description>
					<X>30</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_2smtsp_traditional
if(get_Main().consoleOutput)	trace("ClusS");	else get_Main().csv_file.print("ClusS"+get_Main().maximumComputationTimeSpan/3600000);
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(m);
	}
	
	IloNumVar	Dmax	= cplex.numVar(0, Double.MAX_VALUE);
	
	IloNumVar[] D		= cplex.numVarArray(m, 0, Double.MAX_VALUE);

	
	// OBJECTIVE
	cplex.addMinimize(Dmax);
	
	// CONSTRAINT 1:	FORALL(k in salesmen) Dmax >= D[k];
	for(int k=0 ; k<m ; k++){
		cplex.addGe(Dmax, D[k]);
	}//for(k)
	
	// CONSTRAINT 2:	FORALL(i in cities, j in cities, k in salesmen) D[l] >= d[i][j]*(x[i][l] + x[j][l] - 1)
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(d[i][j],	x[i][k]);
				expr.addTerm(d[i][j],	x[j][k]);
				expr.setConstant( -d[i][j] );
				cplex.addGe(D[k],	expr);
			}//for(k)
		}//for(j)
	}//for(i)
	
	// CONSTRAINT 3: FORALL(i in cities) SUM(k in salesmen) x[i][k]=1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int k=0 ; k<m ; k++)
			expr.addTerm(1, x[i][k]);
		cplex.addEq(expr, 1.0);

	}//for(i)

	// write model to file
	//cplex.exportModel("clustering.lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		//the central planner may use up to 50% of the available computation time, thus the ".5"
		cplex.setParam( IloCplex.Param.TimeLimit, .5*(get_Main().remainingComputationTime/1000) ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(cplex.getParam(IloCplex.Param.TimeLimit)*1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}
	
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		//if(get_Main().debugOutput)	traceln(this+" 1 Cluster get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
		//if(get_Main().debugOutput)	traceln(this+" 2 Cluster get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		
		for(Salesman salesman : get_Main().salesmen){
			salesman.allocatedCities.clear();
			salesman.allocatedCities.add( get_Main().cities.get(0) );
		}

		for(int i=1; i<n ; i++){
			//trace("\n"+i+"\t");
			for(int k=0; k<m ; k++){
				if(cplex.getValue(x[i][k])>.9){
					//trace("1\t");
					get_Main().salesmen.get(k).allocatedCities.add( get_Main().cities.get(i) );
				}
				//else
				//	trace("0\t");	
			}//for(k)
		}//for(i)
		//trace("\n");
	

	}//if(cplex.solve)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484574767742</Id>
					<Name><![CDATA[solve_cluster_Saglam_swap]]></Name>
					<Description><![CDATA[Source of this clustering method: Section 3 B. Saglam ,  F. S. Salman, S. Sayin & M. Türkay, "A mixed-integer approach to the clustering problem with an appplication in customer segmentation", European Journal of Operational Research, 2006, 173:866-879.
(Formulation very close to solve_clustering2() which uses Section 5 in M. R. Rao, "Cluster analysis and mathematical programming", Journal of the American Statistical Association, September 1971, 66(335):622-626.]]></Description>
					<X>180</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_2smtsp_traditional
if(get_Main().consoleOutput)	trace("ClusSs");	else get_Main().csv_file.print("ClusSaglamSwap"+get_Main().maximumComputationTimeSpan/3600000);
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}
int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(m);
	}
	
	IloNumVar	Dmax	= cplex.numVar(0, Double.MAX_VALUE);
	
	IloNumVar[] D		= cplex.numVarArray(m, 0, Double.MAX_VALUE);

	
	// OBJECTIVE
	cplex.addMinimize(Dmax);
	
	// CONSTRAINT 1:	FORALL(k in salesmen) Dmax >= D[k];
	for(int k=0 ; k<m ; k++){
		cplex.addGe(Dmax, D[k]);
	}//for(k)
	
	// CONSTRAINT 2:	FORALL(i in cities, j in cities, k in salesmen) D[l] >= d[i][j]*(x[i][l] + x[j][l] - 1)
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(d[i][j],	x[i][k]);
				expr.addTerm(d[i][j],	x[j][k]);
				expr.setConstant( -d[i][j] );
				cplex.addGe(D[k],	expr);
			}//for(k)
		}//for(j)
	}//for(i)
	
	// CONSTRAINT 3: FORALL(i in cities) SUM(k in salesmen) x[i][k] == 1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int k=0 ; k<m ; k++)
			expr.addTerm(1, x[i][k]);
		cplex.addEq(expr, 1.0);

	}//for(i)

	// CONSTRAINT swap : FORALL(k in salesmen) (1+SUM(j in cities) x[j][k]  == SUM(j in cities) o[j][k])
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.setConstant(1);
		for(int j=1 ; j<n ; j++)
			expr.addTerm(1.0, x[j][k]);
		int cities_owned_by_k = 0;
		for(int j=0 ; j<n ; j++)
			cities_owned_by_k += o[j][k];
		cplex.addEq(expr, cities_owned_by_k);
	}

	// write model to file
	//cplex.exportModel("cluster.lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		//the central planner may use up to 50% of the available computation time, thus the ".5"
		cplex.setParam( IloCplex.Param.TimeLimit, .5*(get_Main().remainingComputationTime/1000) ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(cplex.getParam(IloCplex.Param.TimeLimit)*1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		//if(get_Main().debugOutput)	traceln(this+" 1 Cluster1swap get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
		//if(get_Main().debugOutput)	traceln(this+" 2 Cluster1swap get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		
		for(Salesman salesman : get_Main().salesmen){
			salesman.allocatedCities.clear();
			salesman.allocatedCities.add( get_Main().cities.get(0) );
		}

		for(int i=1; i<n ; i++){
			//trace("\n"+i+"\t");
			for(int k=0; k<m ; k++){
				if(cplex.getValue(x[i][k])>.9){
					//trace("1\t");
					get_Main().salesmen.get(k).allocatedCities.add( get_Main().cities.get(i) );
				}
				//else
				//	trace("0\t");	
			}//for(k)
		}//for(i)
		//trace("\n");
	

	}//if(cplex.solve)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484574897825</Id>
					<Name><![CDATA[solve_cluster_Rao]]></Name>
					<Description><![CDATA[Source of this clustering method: Section 5 in M. R. Rao, "Cluster analysis and mathematical programming", Journal of the American Statistical Association, September 1971, 66(335):622-626.
(Formulation very close to solve_clustering2 which uses Section 3 in B. Saglam ,  F. S. Salman, S. Sayin & M. Türkay, "A mixed-integer approach to the clustering problem with an appplication in customer segmentation", European Journal of Operational Research, 2006, 173:866-879.)]]></Description>
					<X>350</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_2smtsp_traditional
if(get_Main().consoleOutput)	trace("ClusR");	else get_Main().csv_file.print("ClusRao"+get_Main().maximumComputationTimeSpan/3600000);
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(m);
	}
	
	IloNumVar	D		= cplex.numVar(0, Double.MAX_VALUE);
	
	// OBJECTIVE
	cplex.addMinimize(D);
	
	// CONSTRAINT 2:	FORALL(i in cities, j in cities: i<j, k in salesmen) D >= d[i][j]*(x[i][l] + x[j][l] - 1);
	for(int i=1 ; i<n-1 ; i++){
		for(int j=i+1 ; j<n ; j++)
			if(i<j){
				for(int k=0 ; k<m ; k++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(d[i][j],	x[i][k]);
					expr.addTerm(d[i][j],	x[j][k]);
					expr.setConstant( -d[i][j] );
					cplex.addLe(expr, D);
				}//for(k)
		}//for(j) & if(i<j)
	}//for(i)
	
	// CONSTRAINT 3: FORALL(i in cities) SUM(k in salesmen) x[i][k]=1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int k=0 ; k<m ; k++)
			expr.addTerm(1, x[i][k]);
		cplex.addEq(expr, 1.0);
	}//for(i)

	// write model to file
	//cplex.exportModel("clustering.lp");

	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		//the central planner may use up to 50% of the available computation time, thus the ".5"
		cplex.setParam( IloCplex.Param.TimeLimit, .5*(get_Main().remainingComputationTime/1000) ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(cplex.getParam(IloCplex.Param.TimeLimit)*1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		//if(get_Main().debugOutput)	traceln(this+" 1 Cluster2 get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
		//if(get_Main().debugOutput)	traceln(this+" 2 Cluster2 get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);

		for(Salesman salesman : get_Main().salesmen){
			salesman.allocatedCities.clear();
			salesman.allocatedCities.add( get_Main().cities.get(0) );
		}

		for(int i=1; i<n ; i++){
			//trace("\n"+i+"\t");
			for(int k=0; k<m ; k++){
				if(cplex.getValue(x[i][k])>.9){
					//trace("1\t");
					get_Main().salesmen.get(k).allocatedCities.add( get_Main().cities.get(i) );
				}
				//else
					//trace("0\t");	
			}//for(k)
		}//for(i)
		//traceln("D = " + cplex.getValue(D));
	}//if(cplex.solve)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484575012093</Id>
					<Name><![CDATA[solve_cluster_Rao_swap]]></Name>
					<Description><![CDATA[Source of this clustering method: Section 5 in M. R. Rao, "Cluster analysis and mathematical programming", Journal of the American Statistical Association, September 1971, 66(335):622-626.
(Formulation very close to solve_clustering2 which uses Section 3 in B. Saglam ,  F. S. Salman, S. Sayin & M. Türkay, "A mixed-integer approach to the clustering problem with an appplication in customer segmentation", European Journal of Operational Research, 2006, 173:866-879.)]]></Description>
					<X>480</X><Y>20</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_2smtsp_traditional
if(get_Main().consoleOutput)	trace("ClusRs");	else get_Main().csv_file.print("ClusRaoSwap"+get_Main().maximumComputationTimeSpan/3600000);
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}
int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(m);
	}
	
	IloNumVar	D		= cplex.numVar(0, Double.MAX_VALUE);
	
	// OBJECTIVE
	cplex.addMinimize(D);
	
	// CONSTRAINT 2:	FORALL(i in cities, j in cities: i<j, k in salesmen) D[l] >= d[i][j]*(x[i][l] + x[j][l] - 1)
	for(int i=1 ; i<n-1 ; i++){
		for(int j=i+1 ; j<n ; j++)
			if(i<j){
				for(int k=0 ; k<m ; k++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(d[i][j],	x[i][k]);
					expr.addTerm(d[i][j],	x[j][k]);
					expr.setConstant( -d[i][j] );
					cplex.addLe(expr, D);
				}//for(k)
		}//for(j) & if(i<j)
	}//for(i)
	
	// CONSTRAINT 3: FORALL(i in cities) SUM(k in salesmen) x[i][k]=1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int k=0 ; k<m ; k++)
			expr.addTerm(1, x[i][k]);
		cplex.addEq(expr, 1.0);
	}//for(i)
	
	// CONSTRAINT swap : FORALL(k in salesmen) (1+SUM(j in cities) x[j][k]  == SUM(j in cities) o[j][k])
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.setConstant(1);
		for(int j=1 ; j<n ; j++)
			expr.addTerm(1.0, x[j][k]);
		int cities_owned_by_k = 0;
		for(int j=0 ; j<n ; j++)
			cities_owned_by_k += o[j][k];
		cplex.addEq(expr, cities_owned_by_k);
	}

	// write model to file
	//cplex.exportModel("clustering.lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		//the central planner may use up to 50% of the available computation time, thus the ".5"
		cplex.setParam( IloCplex.Param.TimeLimit, .5*(get_Main().remainingComputationTime/1000) ); //CPLEX uses second, not milliseconds
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.TimeLimit="+(cplex.getParam(IloCplex.Param.TimeLimit)*1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		//if(get_Main().debugOutput)	System.err.println(this+" IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
	
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		//if(get_Main().debugOutput)	traceln(this+" 1 Cluster2swap get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
		//if(get_Main().debugOutput)	traceln(this+" 2 Cluster2swap get_Main().maximumComputationTimeSpan="+get_Main().maximumComputationTimeSpan);
		
		for(Salesman salesman : get_Main().salesmen){
			salesman.allocatedCities.clear();
			salesman.allocatedCities.add( get_Main().cities.get(0) );
		}

		for(int i=1; i<n ; i++){
			//trace("\n"+i+"\t");
			for(int k=0; k<m ; k++){
				if(cplex.getValue(x[i][k])>.9){
					//trace("1\t");
					get_Main().salesmen.get(k).allocatedCities.add( get_Main().cities.get(i) );
				}
				//else
					//trace("0\t");	
			}//for(k)
		}//for(i)
		//traceln("D = " + cplex.getValue(D));
	}//if(cplex.solve)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484581847914</Id>
					<Name><![CDATA[TRASH_solve_cplex_mtsp]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>-290</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[trace("G_cplex_mtsp");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] c = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		c[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++)
			x[i][j] = cplex.boolVarArray(m);
	}
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(c[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);

	// CONSTRAINT 18: for the depot, as many leaving paths as salesmen
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, x[0][j][k]);
			}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)
/*	// CONSTRAINT 1bis: for each node j, only one leaving path
	// FORALL j, SUM_i(i<>j) x[i][j] = 1
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  1.0);
	}//for(j)

	// CONSTRAINT 2: for the depot, as many leaving paths as trucks
	for(int i=0 ; i<1 ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  salesmen.size()); //all trucks return to the depot
	}//for(i)
	// CONSTRAINT 2bis: for each node i, only one entering path
	// FORALL i, SUM_j(i<>j) x[i][j] = 1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  1.0);
	}//for(i)
	
	// CONSTRAINT 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-2
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n-1,	x[i][j]);
				cplex.addLe(expr,	n-2);
			}//if
		}//for(j)
	}//for(i)
	*/
	// write model to file
	cplex.exportModel("salesmEn.lp");

	cplex.setOut(null);
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
/*		trace("\nx[][]=\t");
		for(int i=0; i<n ; i++)
			trace(i+"\t");
		trace("\n");
		for(int i=0; i<n ; i++){
			System.out.print("\n"+i+"\t");
			for(int j=0; j<n ; j++){
				if(i!=j){
					//System.out.print(cplex.getValue(x[i][j])+"\t");
					if(cplex.getValue(x[i][j]) > .9)
						trace(cplex.getValue(x[i][j]));
					trace("\t");
				}
				else
					trace("-\t");
			}
		}
		trace("\n");	*/
	
		int truckNb = 0;	//CPLEX may need less trucks than 'trucks.size()' or 'truckNumber'
/*		for(int source=1; source<n ; source++)
			if( cplex.getValue( x[source][0] ) > .9 )
				truckNb++;*/
//traceln("CPLEX finds " + truckNb+" routes.");
	
		ArrayList routes = new ArrayList();
		for(int truck=0; truck < truckNb ; truck++){
			ArrayList route = new ArrayList();
			routes.add(route);
		}//for(truck)

		//Convert 'x[][]' matrix into 'route' ArrayLists
/*		int destinationInFirstRow = 0;
		for(int route = 0 ; route < truckNb ; route++){
			int source = 0 ;
			do{ //this 'do' loop goes from one city to the next in x[][]
				for( int destination = 0 ; destination < n ; destination++){ //this 'for' loop scan a line in x[][] until the 'routeIndex'th value '1', the corresponding column is the next client 
					if( source != destination ){
						if( cplex.getValue( x[source][destination] ) > .9 ){
							if(source >0){
								source = destination;
								break;
							}else if(destination > destinationInFirstRow){
								source = destination;
								destinationInFirstRow = destination;
								break;
							}
						}
					}
				}
				((ArrayList)(routes.get(route))).add(cities.get(source));
			}while( source != 0 ); //'while' until the return to the depot (client zero)
		}//fin for(truck)
*/		
/*		for(Object route : routes){
			trace(route+" ");
			for(Object client : (ArrayList)route)
				trace( ((City)client).getIndex() + " ");
			trace("\n");
		}*/
		
		for(Salesman salesman : get_Main().salesmen){
			salesman.route.clear();
			salesman.route.add(get_Main().cities.get(0));
			salesman.route.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
			salesman.ownedCities.clear();
			salesman.ownedCities.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
			salesman.allocatedCities.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
		}//for(salesman)
/*		for(Object route : routes){
			for(Object client : (ArrayList)route)
				truck.route.add(clients.get( (Client)client ));
				trace("\nRoute "+route+" "+ client);
		}*/
	}//if(cplex.solve)
//cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484581847916</Id>
					<Name><![CDATA[TRASH_solve_insertAll_bkp]]></Name>
					<Description><![CDATA[This algo works, but assigns all clients to the same truck.]]></Description>
					<X>-290</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[trace("G_insert_old");
for(Salesman truck : get_Main().salesmen){
	truck.route.clear();
	truck.route.add( get_Main().cities.get(0) );	//add the depot at the beginning of the route
	truck.route.add( get_Main().cities.get(0) );	//add the depot at the end       of the route
}

for(City client : get_Main().cities){
	if( ! client.equals( get_Main().cities.get(0) ) ){
		int bestTruck		= Integer.MAX_VALUE;
		int bestPosition	= Integer.MAX_VALUE;
		double bestLength	= Double.MAX_VALUE;
		double testedLength;
		for(Salesman truck : get_Main().salesmen){
			for(int testedPosition=0 ; testedPosition < truck.route.size() - 1 ; testedPosition++){
				testedLength =	Math.sqrt( Math.pow( truck.route.get(testedPosition).getX()-client.getX(), 2) + Math.pow(truck.route.get(testedPosition).getY()-client.getY(), 2)) + Math.sqrt( Math.pow(truck.route.get(testedPosition+1).getX()-client.getX(), 2) + Math.pow(truck.route.get(testedPosition+1).getY()-client.getY(), 2) )
							-	Math.sqrt( Math.pow( truck.route.get(testedPosition).getX()-truck.route.get(testedPosition+1).getX(), 2) + Math.pow( truck.route.get(testedPosition).getY()-truck.route.get(testedPosition+1).getY(), 2) );
				if(bestLength > testedLength){
					bestTruck	= truck.getIndex();
					bestLength	= testedLength;
					bestPosition= testedPosition;
				}//if(bestLength
			}//for(int testedposition)
		}//for(truck)
		get_Main().salesmen.get(bestTruck).route.add(bestPosition+1, client);
	}
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484581847918</Id>
					<Name><![CDATA[TRASH_solve_cplex_shortPath]]></Name>
					<X>-290</X><Y>139</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[trace("ECD4");
IloCplex cplex;

// Get values from the simulation in order to inject them into CPLEX
int m = get_Main().salesmen.size();

ArrayList cities2visit = new ArrayList();
if(get_Main().salesmenShareDepot0)		cities2visit.add( get_Main().cities.get(0) );
for(Salesman salesman : get_Main().salesmen)
	for(City city : salesman.allocatedCities)
		if( ! cities2visit.contains(city) )
			cities2visit.add( city );

int n = cities2visit.size();	//Index in CPLEX: 0='depot', 1..n='cities', n+m='position of salesmen'

double[][] c = new double[n+m][n+m]; //c[i][j] = distance between city/salesman i and city/salesman j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = (City)cities2visit.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){				//fill in the first n x n square in c
		City city_J = (City)cities2visit.get(city_j);
		c[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}//for(city_j)
	for(int salesman_j=0 ; salesman_j<m ; salesman_j++){	//fill in both n x m rectangles in c
		Salesman salesman_J = get_Main().salesmen.get(salesman_j);
		c[city_i][n+salesman_j] = Math.sqrt( Math.pow(city_I.getX()-salesman_J.getX(), 2) + Math.pow(city_I.getY()-salesman_J.getY(), 2));
		c[n+salesman_j][city_i] = c[city_i][n+salesman_j];
	}//for(salesman_j)
}//for(city_i)
for(Salesman salesman_I: get_Main().salesmen){
	for(Salesman salesman_J: get_Main().salesmen){
		c[n+salesman_I.getIndex()][n+salesman_J.getIndex()] = Math.sqrt( Math.pow(salesman_I.getX()-salesman_J.getX(), 2) + Math.pow(salesman_I.getY()-salesman_J.getY(), 2));
	}//for(salesman_J)
}//for(salesman_I)

if(get_Main().salesmenShareDepot0)
	for(int salesman=0 ; salesman<m ; salesman++)
		c[0][n+salesman] = 0;	//MTSP -ie, subroute elimination constraint 5- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route
else
	traceln("TODO..."+1/0);
/*trace("\nc=\t");
for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n)+"\t");
traceln();
for(int i=0 ; i<n+m ; i++){
	if(i<n)	trace("C"+((City)cities2visit.get(i)).getIndex() +"\t");	else	trace("S"+ (i-n) +"\t");
	for(int j=0; j<n+m ; j++)
		trace( ( Math.round(c[i][j]*10)/10. ) +"\t");
	traceln();
}*/

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City city : salesman.ownedCities)
		o[ cities2visit.indexOf(city) ][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

int[] maxRealloc = new int[m];
for(int salesman=0 ; salesman<m ; salesman++)
	maxRealloc[ salesman ] = get_Main().salesmen.get( salesman ).maxReallocations;

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n+m][n+m][];
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n+m, 0, Double.MAX_VALUE);
	
	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(c[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n+m ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n+m ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n+m ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n+m ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n+m ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n+m ; i++){
		for(int j=1 ; j<n+m ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6bis (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];
	for(int i=0 ; i<n+m ; i++){		//6
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				
				cplex.addLe(expr,	o[j][k]);
				//expr.addTerm(-1.0,	a[j][k]);
				//cplex.addLe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7	eq-6MTSP-enter=leave
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n+m ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8bis (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxReallocations[k];	//8bis
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		cplex.addLe(expr, maxRealloc[k]);
	}//for(k)

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
	
	// Constraint 11: use the zero-distance arc between the depot and the inital position of the salemen
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.addTerm(1, x[0][n+k][k]);
		cplex.addEq(expr, 1);
	}

	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");

//	traceln("solve");
	cplex.setOut(null);
	// Solve the model and display the solution if one was found
	boolean solutionFound = cplex.solve();
//	traceln("Solution found = " + solutionFound);
	if ( solutionFound ) {
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("x SM"+k+"\t");
			for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
			for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n) +"\t");
			traceln();
			for(int i=0 ; i<n+m ; i++){
				if(i<n)	trace("C"+((City)cities2visit.get(i)).getIndex() +"\t");	else	trace("S"+ (i-n) +"\t");
				for(int j=0 ; j<n+m ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(Math.round(cplex.getValue(x[i][j][k])*100)/100+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("o|a\tC");
		for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n+m ; i++)
			trace("\t"+Math.round(cplex.getValue(u[i])*100)/100);
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(solutionFounde)
	//traceln("\nEND of solve_cplex_mtsp");

	//Convert from 'x[][]' matrix into 'solution_temp[]'		
	int[] solution_temp;
	for( int salesman=0 ; salesman<m ; salesman++){
		get_Main().salesmen.get( salesman ).route.clear();
		get_Main().salesmen.get( salesman ).route.add( get_Main().salesmen.get(salesman) );
		solution_temp = new int[n+1];
		solution_temp[0] = n+salesman;
		for( int position = 0 ; position < n ; position++){
			for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
				if(solution_temp[position] != column_in_x){
					if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
						solution_temp[position+1] = column_in_x;
						break;
					}//if(x>0.0)
				}
			}//for(column_in_x)
			//salesmen.get( salesman ).route.add( (City)cities.get( cities2visitIndex[ solution_temp[position+1] ] ) );
			get_Main().salesmen.get( salesman ).route.add( (City)cities2visit.get( solution_temp[position+1] ));
			if( solution_temp[position+1]==0 )
				break;
		}//for(position)
	}//for(salesman)
//cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484581847920</Id>
					<Name><![CDATA[TRASH_solve_cplex_1mtsp]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>-290</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[trace("G_cplex_1mtsp");
IloCplex cplex;

// Get values from the simulation in order to inject them into CPLEX
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();	//Index in CPLEX: 0='depot', 1..n='cities', n+m='position of salesmen'
double[][] c = new double[n+m][n+m]; //c[i][j] = distance between city/salesman i and city/salesman j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	//fill in the first n x n square in c
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		c[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
	//fill in both n x m rectangles in c
	for(int salesman_j=0 ; salesman_j<m ; salesman_j++){
		Salesman salesman_J = get_Main().salesmen.get(salesman_j);
		c[city_i][n+salesman_j] = Math.sqrt( Math.pow(city_I.getX()-salesman_J.getX(), 2) + Math.pow(city_I.getY()-salesman_J.getY(), 2));
		c[n+salesman_j][city_i] = c[city_i][n+salesman_j];
	}
}//for(city_i)
for(Salesman salesman_I: get_Main().salesmen){
	for(Salesman salesman_J: get_Main().salesmen){
		c[n+salesman_I.getIndex()][n+salesman_J.getIndex()] = Math.sqrt( Math.pow(salesman_I.getX()-salesman_J.getX(), 2) + Math.pow(salesman_I.getY()-salesman_J.getY(), 2));
	}//for(salesman_J)
}//for(salesman_I)

if(get_Main().salesmenShareDepot0)
	for(int salesman=0 ; salesman<m ; salesman++)
		c[0][n+salesman] = 0;	//MTSP -ie, subroute elimination constraint 5- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route
else
	traceln("TODO..."+1/0);
/*trace("\nc=\t");
for(int i=0 ; i<n ; i++)	trace("C"+i+"\t");
for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n)+"\t");
traceln();
for(int i=0 ; i<n+m ; i++){
	if(i<n)	trace("C"+i+"\t");	else	trace("S"+ (i-n) +"\t");
	for(int j=0; j<n+m ; j++)
		trace( ( Math.round(c[i][j]*10)/10. ) +"\t");
	traceln();
}*/






int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.allocatedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

int[] maxRealloc = new int[m];
for(int salesman=0 ; salesman<m ; salesman++)
	maxRealloc[ salesman ] = get_Main().salesmen.get( salesman ).maxReallocations;

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(c[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6bis (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];
	for(int i=0 ; i<n ; i++){		//6
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				
				//cplex.addLe(expr,	o[j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8bis (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxReallocations[k];	//8bis
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		cplex.addLe(expr, maxRealloc[k]);
	}//for(k)

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
	
	// Constraint 11: use the zero-distance arc between the depot and the inital position of the salemen
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.addTerm(1, x[0][n+k][k]);
		cplex.addEq(expr, 1);
	}
*/
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");

//	traceln("solve");
	cplex.setOut(null);
	// Solve the model and display the solution if one was found
	boolean solutionFound = cplex.solve();
//	traceln("Solution found = " + solutionFound);
	if ( solutionFound ) {
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("a[][]\t");
		for(int j=0 ; j<n ; j++)
			trace(j+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			get_Main().salesmen.get( salesman ).route.add( get_Main().salesmen.get(salesman) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
		}//for(salesman)
	
//cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}
]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1484581847922</Id>
					<Name><![CDATA[TRASH_solve_cplex_mtsp1]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>-290</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[trace("G_cplex_mtsp");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] c = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		c[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(c[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;			//1
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;				//2
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;			//3
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;				//4
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;									//5
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6 (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];											//6
/*	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0.0);
				//cplex.addLe(expr, a[j][k]);
				//cplex.addLe(x[i][j][k], a[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/
	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8 (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)

	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");

	traceln("solve");
	cplex.setOut(null);
	// Solve the model and display the solution if one was found
	boolean solutionFound = cplex.solve();
	traceln("Solution found = " + solutionFound);
	if ( solutionFound ) {
		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("a[][]\t");
		for(int j=0 ; j<n ; j++)
			trace(j+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)

		traceln("\nSOLUTION FOUND");
	}//if(cplex.solve)
	traceln("\nEND of solve_cplex_mtsp");
//cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582208152</Id>
					<Name><![CDATA[solve_FullCentr]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former names: solve_cplex_2smtsp_traditional, solve_MTSPcplex_2indices and MTSPc2
//solve_MTSPcplex3 uses a 3-index formulation, and this one 2-index 
if(get_Main().consoleOutput)	trace("FullCentr");	else get_Main().csv_file.print("FullCentr"+get_Main().maximumComputationTimeSpan/3600000);	//formerly MTSPc2
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();
	// Variables
	IloNumVar[][] x = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		x[i] = cplex.boolVarArray(n);
	}
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				obj.addTerm(d[i][j], x[i][j]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);

	// CONSTRAINT 1: for the depot, as many entering paths as salesmen
	// sum(i in cities: i>=1) x[i][0]==m;
	for(int j=0 ; j<1 ; j++){	//j=0 only (so that constraint 1bis looks similar)
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr, m); //all trucks leave the depot
	}//for(j)
	// CONSTRAINT 1bis: for each node j, only one entering path
	// FORALL j, SUM_i(i<>j) x[i][j] = 1
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  1.0);
	}//for(j)

	// CONSTRAINT 2: for the depot, as many leaving paths as salesmen
	for(int i=0 ; i<1 ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  get_Main().salesmen.size()); //all trucks return to the depot
	}//for(i)
	// CONSTRAINT 2bis: for each node i, only one entering path
	// FORALL i, SUM_j(i<>j) x[i][j] = 1
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  1.0);
	}//for(i)
	
	// CONSTRAINT 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + n x[i][j] <=  n-1
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j]);
				cplex.addLe(expr,	n-1);
			}//if
		}//for(j)
	}//for(i)
	
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");

	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("solve_FullCentr IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("solve_FullCentr IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
				if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		trace("\nx[][]=\t");
		for(int i=0; i<n ; i++)
			trace(i+"\t");
		trace("\n");
		for(int i=0; i<n ; i++){
			System.out.print("\n"+i+"\t");
			for(int j=0; j<n ; j++){
				if(i!=j){
					//System.out.print(cplex.getValue(x[i][j])+"\t");
					if(cplex.getValue(x[i][j]) > .9)
						trace(cplex.getValue(x[i][j]));
					trace("\t");
				}
				else
					trace("-\t");
			}
		}
		trace("\n");	*/
	
		int truckNb = 0;	//CPLEX may need less trucks than 'trucks.size()' or 'truckNumber'
		for(int source=1; source<n ; source++)
			if( cplex.getValue( x[source][0] ) > .9 )
				truckNb++;
//traceln("CPLEX finds " + truckNb+" routes.");
	
		ArrayList tempRoutes = new ArrayList();
		for(int truck=0; truck < truckNb ; truck++){
			ArrayList tempRoute = new ArrayList();
			tempRoutes.add( tempRoute );
		}//for(truck)

		//Convert 'x[][]' matrix into 'route' ArrayLists
		int destinationInFirstRow = 0;
		for(int foundRoute = 0 ; foundRoute < truckNb ; foundRoute++){
			int source = 0 ;
			do{ //this 'do' loop goes from one city to the next in x[][]
				for( int destination = 0 ; destination < n ; destination++){ //this 'for' loop scan a line in x[][] until the 'routeIndex'th value '1', the corresponding column is the next client 
					if( source != destination ){
						if( cplex.getValue( x[source][destination] ) > .9 ){
							if(source >0){
								source = destination;
								break;
							}else if(destination > destinationInFirstRow){
								source = destination;
								destinationInFirstRow = destination;
								break;
							}
						}
					}
				}
				((ArrayList)( tempRoutes.get(foundRoute)) ).add(get_Main().cities.get(source));
			}while( source != 0 ); //'while' until the return to the depot (client zero)
		}//fin for(truck)
		
/*		for(Object route : routes){
			trace(route+" ");
			for(Object client : (ArrayList)route)
				trace( ((City)client).getIndex() + " ");
			trace("\n");
		}*/
		
		for(Salesman salesman : get_Main().salesmen){
			salesman.route.clear();
			//salesman.route.add(salesman);
			salesman.route.add(get_Main().cities.get(0));
			salesman.route.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
			//salesman.citiesOwned.clear();
			//salesman.citiesOwned.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
			salesman.allocatedCities.clear();
			salesman.allocatedCities.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
		}//for(salesman)
/*		for(Object route : routes){
			for(Object client : (ArrayList)route)
				truck.route.add(clients.get( (Client)client ));
				trace("\nRoute "+route+" "+ client);
		}*/
	}//if(cplex.solve)
if(get_Main().debugOutput)	System.err.println("solve_FullCentr1");
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}
if(get_Main().debugOutput)	System.err.println("solve_FullCentr2");]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582406568</Id>
					<Name><![CDATA[solve_MTSPcplex_3indices]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//solve_MTSPcplex uses a 2-index formulation, and this one 3-index ++ solve_MTSPcplex_3indices_max is similar to solve_MTSPcplex_3indices except that is solves the min-max version instead of min-sum
if(get_Main().consoleOutput)	trace("MTSPc3");	else get_Main().csv_file.print("MTSPc3");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);

	IloNumVar[] L = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	
/*	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
*/	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int k=0 ; k<m ; k++)
		obj.addTerm(1, L[k]);
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 0: objective function
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			for(int j=0 ; j<n ; j++){
				if(i!=j)
					expr.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
		cplex.addEq(L[k], expr);
	}//for(k)
	
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2prime
	// forall (k in salesmen)
	//    sum(i in cities: i>=1) x[i][0][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
		for(int i=1 ; i<n ; i++){		
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(i)
			cplex.addEq(flow_in_depot, 1);
	}//for(k)

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4prime
	// forall(k in salesmen)
	// 		sum(j in cities: j>=1) x[0][j][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
		for(int j=1 ; j<n ; j++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(j)
		cplex.addEq(flow_out_depot, 1);
	}//for(k)

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

/*	// constraint 6 (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];											//6
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0.0);
				//cplex.addLe(expr, a[j][k]);
				//cplex.addLe(x[i][j][k], a[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/	/*for(int i=0 ; i<n ; i++){		//6, not 6bis
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				cplex.addLe(expr,	o[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8 (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)
*/
	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
/*	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)
*/
	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
/*	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
*/
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			//salesmen.get( salesman ).route.add( salesmen.get( salesman ) );
			get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( 0 ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
			get_Main().salesmen.get( salesman ).allocatedCities.clear();
			get_Main().salesmen.get( salesman ).allocatedCities = (ArrayList) get_Main().salesmen.get( salesman ).route.clone();
			get_Main().salesmen.get( salesman ).allocatedCities.remove( get_Main().salesmen.get( salesman ) );
		}//for(salesman)
	
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582537960</Id>
					<Name><![CDATA[solve_MTSPcplex_3indices_max]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>221</X><Y>101</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//solve_MTSPcplex_3indices_max is similar to solve_MTSPcplex_3indices except that is solves the min-max version instead of min-sum
if(get_Main().consoleOutput)	trace("MTSPc3m");	else get_Main().csv_file.print("MTSPc3max");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[]	u	= cplex.numVarArray(n, 0, Double.MAX_VALUE);

	IloNumVar Lmax	= cplex.numVar(0, Double.MAX_VALUE);
	
/*	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
*/	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
//	for(int k=0 ; k<m ; k++)
//		obj.addTerm(1, L[k]);
	cplex.addMinimize(Lmax);
	
	// CONSTRAINTS
	// constraint 0: objective function
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			for(int j=0 ; j<n ; j++){
				if(i!=j)
					expr.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
		cplex.addGe(Lmax, expr);
	}//for(k)
	
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2prime
	// forall (k in salesmen)
	//    sum(i in cities: i>=1) x[i][0][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
		for(int i=1 ; i<n ; i++){		
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(i)
			cplex.addEq(flow_in_depot, 1);
	}//for(k)

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4prime
	// forall(k in salesmen)
	// 		sum(j in cities: j>=1) x[0][j][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
		for(int j=1 ; j<n ; j++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(j)
		cplex.addEq(flow_out_depot, 1);
	}//for(k)

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

/*	// constraint 6 (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];											//6
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0.0);
				//cplex.addLe(expr, a[j][k]);
				//cplex.addLe(x[i][j][k], a[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/	/*for(int i=0 ; i<n ; i++){		//6, not 6bis
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				cplex.addLe(expr,	o[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8 (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)
*/
	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
/*	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)
*/
	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
/*	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
*/
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			//salesmen.get( salesman ).route.add( salesmen.get( salesman ) );
			get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( 0 ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
			get_Main().salesmen.get( salesman ).allocatedCities.clear();
			get_Main().salesmen.get( salesman ).allocatedCities = (ArrayList) get_Main().salesmen.get( salesman ).route.clone();
			get_Main().salesmen.get( salesman ).allocatedCities.remove( get_Main().salesmen.get( salesman ) );
		}//for(salesman)
	
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582656640</Id>
					<Name><![CDATA[solve_OptDecentr]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>422</X><Y>102</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_MTSPcplex_3indices_swap and MTSPc3s
//solve_MTSPcplex uses a 2-index formulation, and this one 3-index ++ solve_MTSPcplex_3indices_max is similar to solve_MTSPcplex_3indices except that is solves the min-max version instead of min-sum
if(get_Main().consoleOutput)	trace("OptDecentr");	else get_Main().csv_file.print("OptDecentr_"+get_Main().maximumComputationTimeSpan/3600000);
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);

	IloNumVar[] L = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	
/*	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
*/	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int k=0 ; k<m ; k++)
		obj.addTerm(1, L[k]);
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 0: objective function
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			for(int j=0 ; j<n ; j++){
				if(i!=j)
					expr.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
		cplex.addEq(L[k], expr);
	}//for(k)

	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2prime
	// forall (k in salesmen)
	//    sum(i in cities: i>=1) x[i][0][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
		for(int i=1 ; i<n ; i++){		
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(i)
			cplex.addEq(flow_in_depot, 1);
	}//for(k)

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4prime
	// forall(k in salesmen)
	// 		sum(j in cities: j>=1) x[0][j][k]<=m;
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
		for(int j=1 ; j<n ; j++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(j)
		cplex.addEq(flow_out_depot, 1);
	}//for(k)

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

/*	// constraint 6 (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];											//6
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0.0);
				//cplex.addLe(expr, a[j][k]);
				//cplex.addLe(x[i][j][k], a[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/	/*for(int i=0 ; i<n ; i++){		//6, not 6bis
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				cplex.addLe(expr,	o[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8 (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)
*/
	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
/*	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)
*/
	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
/*	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
*/
	// CONSTRAINT 'swap'
	// forall(k in salesmen)
	//   sum(i in cities, j in cities: j!=i) x[i][j][k] == sum(j in cities) o[j][k];
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++)
			for(int j=0 ; j<n ; j++)
				if(i!=j)
					expr.addTerm(1.0, x[i][j][k]);
		int cities_owned_by_k = 0;
		for(int j=0 ; j<n ; j++)
			cities_owned_by_k += o[j][k];
		cplex.addEq(expr, cities_owned_by_k);
	}	

	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("solve_OptDecentr IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("solve_OptDecentr IloCplex.Param.MIP.Limits.Solutions=1");
	}

	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			//salesmen.get( salesman ).route.add( salesmen.get( salesman ) );
			get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( 0 ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
			get_Main().salesmen.get( salesman ).allocatedCities.clear();
			get_Main().salesmen.get( salesman ).allocatedCities = (ArrayList) get_Main().salesmen.get( salesman ).route.clone();
			get_Main().salesmen.get( salesman ).allocatedCities.remove( get_Main().salesmen.get( salesman ) );
		}//for(salesman)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582788352</Id>
					<Name><![CDATA[solve_DMTSPcplex]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?

Différence avec la version statique : lorsque le salesman quitte le dépôt, on peut lui affecter n'importe quelle ville (d'où la variable tempRoutes de 2smtsp sur laquelle se base cette fonction). Au contraire, ici, chaque route part d'un salesman particulier auquel il faut donc affecter la route qui a été calculée depuis son point de départ.]]></Description>
					<X>423</X><Y>83</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_2dmtsp_traditional
if(get_Main().consoleOutput)	trace("DMTSPc");	else get_Main().csv_file.print("DMTSPc");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n+m][n+m];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){					//fill in the first n x n square in c
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}//for(city_j)
	for(int salesman_j = 0; salesman_j < m ; salesman_j++){		//fill in both n x m rectangles in c
		Salesman salesman_J = get_Main().salesmen.get(salesman_j);
		d[city_i][n+salesman_j] = Math.sqrt( Math.pow(city_I.getX()-salesman_J.getX(), 2) + Math.pow(city_I.getY()-salesman_J.getY(), 2));
		d[n+salesman_j][city_i] = d[city_i][n+salesman_j];
	}//for(city_j)
}//for(city_i)
for(Salesman salesman_I: get_Main().salesmen){								//fill in the second m x m square in c
	for(Salesman salesman_J: get_Main().salesmen){
		d[n+salesman_I.getIndex()][n+salesman_J.getIndex()] = Math.sqrt( Math.pow(salesman_I.getX()-salesman_J.getX(), 2) + Math.pow(salesman_I.getY()-salesman_J.getY(), 2));
	}//for(salesman_J)
}//for(salesman_I)

if(get_Main().salesmenShareDepot0)
	for(int salesman=0 ; salesman<m ; salesman++)
		d[0][n+salesman] = 0;	//MTSP -ie, subroute elimination constraint 5- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route
else
	traceln("TODO..."+1/0);

try {
	cplex = new IloCplex();
	
	// VARIABLES
	IloNumVar[][] x = new IloNumVar[n+m][];
	for(int i=0 ; i<n+m ; i++){
		x[i] = cplex.boolVarArray(n+m);
	}
	IloNumVar[] u = cplex.numVarArray(n+m, 0, Double.MAX_VALUE);
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				obj.addTerm(d[i][j], x[i][j]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);

	// CONSTRAINT 1: for the depot, as many entering paths as salesmen
	for(int j=0 ; j<1 ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr, m); //all trucks leave the depot
	}//for(j)
	// CONSTRAINT 1bis: for each node j, only one entering path
	// FORALL j, SUM_i(i<>j) x[i][j] = 1
	for(int j=1 ; j<n+m ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n+m ; i++){
			if(i!=j)
				expr.addTerm(1.0, x[i][j]);
			}//for(i)
			cplex.addEq(expr,  1.0);
	}//for(j)

	// CONSTRAINT 2: for the depot, as many leaving paths as trucks
	// -> replaced by constraint 11 below
/*	for(int i=0 ; i<1 ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  salesmen.size()); //all trucks return to the depot
	}//for(i)
*/	
	// CONSTRAINT 2bis: for each node i, only one entering path
	// FORALL i, SUM_j(i<>j) x[i][j] = 1
	for(int i=1 ; i<n+m ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				expr.addTerm(1.0, x[i][j]);
			}//for(j)
		cplex.addEq(expr,  1.0);
	}//for(i)
	
	// CONSTRAINT 3: subroute elimination
	// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-2
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			if(i!=j){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n-1,	x[i][j]);
				cplex.addLe(expr,	n-2);
			}//if
		}//for(j)
	}//for(i)
	
	// Constraint 11: use the zero-distance arc between the depot and the inital position of the salemen
	for(int i=0 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.addTerm(1, x[0][i]);
		cplex.addEq(expr, 0);
	}
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.addTerm(1, x[0][n+k]);
		cplex.addEq(expr, 1);
	}
	
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();
		
	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		trace("x "+"\t");
		for(int i=0 ; i<n ; i++)	trace("C"+i+"\t");
		for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n) +"\t");
		trace("\n");
		for(int i=0; i<n+m ; i++){
			if(i<n)	trace("C"+i+"\t");	else	trace("S"+ (i-n) +"\t");
			for(int j=0; j<n+m ; j++){
				if(i!=j){
					//System.out.print(cplex.getValue(x[i][j])+"\t");
					if(cplex.getValue(x[i][j]) > .9)
						trace(Math.round(cplex.getValue(x[i][j])*100)/100+"\t");
					else
						trace("-\t");
				}
				else
					trace("-\t");
			}//for(j)
			traceln();
		}//for(i)
		trace("\n");	*/
		int truckNb = 0;	//CPLEX may need less trucks than 'trucks.size()' or 'truckNumber'
		for(int source=1; source<n ; source++)
			if( cplex.getValue( x[source][0] ) > .9 )
				truckNb++;
//traceln("CPLEX finds " + truckNb+" routes.");
	
		ArrayList tempRoutes = new ArrayList();
		for(int truck=0; truck < truckNb ; truck++){
			ArrayList tempRoute = new ArrayList();
			tempRoutes.add( tempRoute );
		}//for(truck)

		//Convert 'x[][]' matrix into 'route' ArrayLists
		int destinationInFirstRow = 0;
		for(Salesman salesman : get_Main().salesmen){
			salesman.route.clear();
			salesman.route.add(salesman);
			salesman.allocatedCities.clear();
			int source = n+salesman.getIndex() ;
			//boolean routeIsEmpty = true;
			do{ //this 'do' loop goes from one city to the next in x[][]
				for( int destination = 0 ; destination < n ; destination++){ //this 'for' loop scan a line in x[][] until the 'routeIndex'th value '1', the corresponding column is the next client 
					if( source != destination ){
						if( cplex.getValue( x[source][destination] ) > .9 ){
							if(source >0){
								source = destination;
								//routeIsEmpty = false;
								break;
							}else if(destination > destinationInFirstRow){
								source = destination;
								destinationInFirstRow = destination;
								//routeIsEmpty = false;
								break;
							}//elseif
						}//if(cplex)
					}//if(source!=destination)
				}//for(destination)
				/*if(routeIsEmpty)
					break;
				else {*/
					salesman.route.add(get_Main().cities.get(source));
					salesman.allocatedCities.add(get_Main().cities.get(source));
				//}
				//((ArrayList)( tempRoutes.get(salesm)) ).add(cities.get(source));
			}while( source != 0 ); //'while' until the return to the depot (client zero)
		}//for(salesman)
	}//if(cplex.solve)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}
/*for(Salesman salesman : salesmen){
	trace("\nSM"+salesman.getIndex());
	for(Agent city : salesman.route)
		trace(" " + city);	}	*/]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484582926847</Id>
					<Name><![CDATA[solve_DMTSPinsert]]></Name>
					<X>424</X><Y>64</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace("MTSPi");	else get_Main().csv_file.print("MTSPi");
boolean[] affectedCities = new boolean[ get_Main().cities.size() ];	//record if a city has been affected to a salesman (the index is against `cities')
for(boolean b : affectedCities)	b=false;
long computationStartTime = System.currentTimeMillis() ;

for(Salesman salesman : get_Main().salesmen){
	salesman.route.clear();
	if( get_Main().salesmenShareDepot0 ) {	salesman.route.add( get_Main().cities.get(0) );			//finish at the common depot
								affectedCities[0] = true; }
	else					  {	salesman.route.add( salesman.ownedCities.get(0) );	//finish at the personal depot
								affectedCities[ salesman.ownedCities.get(0).getIndex() ] = true;
							  }

	//Affect the closest (from their current position) of their city still 2 be visited
	City closestCity = null;
	double closestDistance = Double.MAX_VALUE;
	for( City city : salesman.allocatedCities ){
		if( ! city.equals( salesman.route.get(0) ) ) //do not affect the depot twice
			if( closestDistance > pow(salesman.getX()-city.getX(),2) + pow(salesman.getY()-city.getY(),2) ){
				closestDistance = pow(salesman.getX()-city.getX(),2) + pow(salesman.getY()-city.getY(),2);
				closestCity = city;
			}//if(closestDistance)
	}//for(city)
	if( closestCity != null){
		salesman.route.add( 0, closestCity );
		affectedCities[ closestCity.getIndex() ] = true;
	}
}
//traceln("Result of 1st affectation");	for(Salesman salesman : salesmen)	traceln(salesman + " " + salesman.route);	traceln("");

int closestCityIdx = -1 ;
for(Salesman salesman : get_Main().salesmen){
	//If previous affectation not possible, affect the closest city owned by another salesman
	if( salesman.route.isEmpty() ){
		City closestCity = null;
		double closestDistance = Double.MAX_VALUE;
		for( int city = 0 ; city < get_Main().cities.size() ; city++ ){
			if( affectedCities[ city ] )
				if( closestDistance > pow(salesman.getX()-get_Main().cities.get(city).getX(),2) + pow(salesman.getY()-get_Main().cities.get(city).getY(),2) ){
					closestDistance = pow(salesman.getX()-get_Main().cities.get(city).getX(),2) + pow(salesman.getY()-get_Main().cities.get(city).getY(),2);
					closestCityIdx = city;
				}
		}//for(city)
		salesman.route.add( 0, get_Main().cities.get(closestCityIdx) );
	}
}
//traceln("Result of 2nd affectation");	for(Salesman salesman : salesmen)	traceln(salesman + " " + salesman.route);	traceln("");

//Start from the current location
for(Salesman salesman : get_Main().salesmen)
	salesman.route.add( 0, salesman );

for(City city : get_Main().cities){
	if( ! city.equals( get_Main().cities.get(0) ) && ! affectedCities[city.getIndex()] ){
		int bestSalesman	= Integer.MAX_VALUE;
		int bestPosition	= Integer.MAX_VALUE;
		double bestLength	= Double.MAX_VALUE;
		double testedLength;
		for(Salesman salesman : get_Main().salesmen){
			for(int testedPosition=0 ; testedPosition < salesman.route.size() - 1 ; testedPosition++){
				testedLength =	Math.sqrt( Math.pow( salesman.route.get(testedPosition).getX()-city.getX(), 2) + Math.pow(salesman.route.get(testedPosition).getY()-city.getY(), 2)) + Math.sqrt( Math.pow(salesman.route.get(testedPosition+1).getX()-city.getX(), 2) + Math.pow(salesman.route.get(testedPosition+1).getY()-city.getY(), 2) )
							-	Math.sqrt( Math.pow( salesman.route.get(testedPosition).getX()-salesman.route.get(testedPosition+1).getX(), 2) + Math.pow( salesman.route.get(testedPosition).getY()-salesman.route.get(testedPosition+1).getY(), 2) );
				if(bestLength > testedLength){
					bestSalesman= salesman.getIndex();
					bestLength	= testedLength;
					bestPosition= testedPosition;
				}//if(bestLength
			}//for(int testedposition)
		}//for(truck)
		get_Main().salesmen.get(bestSalesman).route.add(bestPosition+1, city);
		//traceln("add " + city + " to salesman " + bestSalesman);
	}
	//for(Salesman salesman : salesmen)	traceln(salesman + " " + salesman.route);
}

//traceln("Final affectation");	for(Salesman salesman : salesmen)	traceln(salesman + " " + salesman.route);
for( Salesman salesman : get_Main().salesmen){
	salesman.allocatedCities = (ArrayList)salesman.route.clone();
	salesman.allocatedCities.remove(0);
}
get_Main().computationTimeOfFunctionSolveOfCentralPlanner += System.currentTimeMillis()-computationStartTime;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583130440</Id>
					<Name><![CDATA[solve_cplex_3smtsp_parallelTSPs]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>120</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/* This function is a modification on solve_MTSPcplex (and a 1st step toward solveMTSPWRcplex). Next, solve_cplex_4smtsp_globRealloc is a modification of this function.
*/
if(get_Main().consoleOutput)	trace("MTSP3c");	else get_Main().csv_file.print("MTSP3c");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
/*	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MIN_VALUE);
	}
*/	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

/*	// constraint 6 (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];											//6
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0.0);
				//cplex.addLe(expr, a[j][k]);
				//cplex.addLe(x[i][j][k], a[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)
*/	for(int i=0 ; i<n ; i++){		//6, not 6bis
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				cplex.addLe(expr,	o[j][k]);
			}//if(k)
		}//for(j)
	}//for(i)


	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8 (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)
*/
	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
/*	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)
*/
	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
/*	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
*/
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("a[][]\t");
		for(int j=0 ; j<n ; j++)
			trace(j+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			get_Main().salesmen.get( salesman ).route.add( get_Main().salesmen.get( salesman ) );			//salesmen.get( salesman ).route.add( cities.get( 0 ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
		}//for(salesman)
	
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583223545</Id>
					<Name><![CDATA[solve_cplex_4smtsp_globRealloc]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>140</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[/* This is a modification of solve_cplex_3smtsp_parallelTSPs  (and a 2d step toward solveMTSPWRcplex). Next, solve_MTSPWRcplex is based on this function.
*/
if(get_Main().consoleOutput)	trace("MTSP4c");	else get_Main().csv_file.print("MTSP4c");
IloCplex cplex;
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	IloNumVar[][] dplus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dplus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] dminus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		dminus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6bis (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				
				//cplex.addLe(expr,	o[j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8bis (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxGifts[k];	//8bis
/*	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(1.0, dminus[j][k]);
		}//for(j)
		//cplex.addLe(expr, maximumReallocation[k]);
		cplex.addLe(expr, 9);
	}//for(k)
*/	IloLinearNumExpr reallocationCounter = cplex.linearNumExpr();		//8
	for( int j=0 ; j<n ; j++){
		for( int k=0 ; k<m ; k++){
			reallocationCounter.addTerm(1.0, dplus[j][k]);
			reallocationCounter.addTerm(1.0, dminus[j][k]);
		}
	}
	int maxReallocations = 4;
	cplex.addLe(reallocationCounter, maxReallocations);

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, dplus[j][k]);
			expr.addTerm(-1.0, dminus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
/*	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, dplus[j][k1]);
					expr.addTerm(-1.0, dminus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
*/
	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
/*		trace("a[][]\t");
		for(int j=0 ; j<n ; j++)
			trace(j+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(cplex.solve)
	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			get_Main().salesmen.get( salesman ).route.add( get_Main().salesmen.get( salesman ) );	//salesmen.get( salesman ).route.add( cities.get( 0 ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
		}//for(salesman)
	
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583310577</Id>
					<Name><![CDATA[solve_MTSPWRcplex]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_5smtsp_indRealloc
if(get_Main().consoleOutput)	trace("MTSPWRc");	else get_Main().csv_file.print("MTSPWRc");
IloCplex cplex;

// Get values from the simulation in order to inject them into CPLEX
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n]; //c[i][j] = distance between cities i and j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}
}

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City  city : salesman.ownedCities)
		o[city.getIndex()][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

int[] maxRealloc = new int[m];
for(int salesman=0 ; salesman<m ; salesman++)
	maxRealloc[ salesman ] = get_Main().salesmen.get( salesman ).maxReallocations;

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n][n][];
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n, 0, Double.MAX_VALUE);
	
	IloNumVar[][] deltaPlus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		deltaPlus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] deltaMinus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		deltaMinus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n ; i++){
		for(int j=1 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6bis (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];
	for(int i=0 ; i<n ; i++){		//6
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				
				//cplex.addLe(expr,	o[j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n ; i++){
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8bis (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxReallocations[k];	//8bis
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, deltaPlus[j][k]);
			expr.addTerm(1.0, deltaMinus[j][k]);
		}//for(j)
		cplex.addLe(expr, maxRealloc[k]);
	}//for(k)

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, deltaPlus[j][k]);
			expr.addTerm(-1.0, deltaMinus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, deltaPlus[j][k1]);
					expr.addTerm(-1.0, deltaMinus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)

	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("SMan"+k+"\t");
			for(int j=0 ; j<n ; j++)
				trace(j+"\t");
			traceln();
			for(int i=0 ; i<n ; i++){
				trace(i+"\t");
				for(int j=0 ; j<n ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(cplex.getValue(x[i][j][k])+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("a[][]\t");
		for(int j=0 ; j<n ; j++)
			trace(j+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n ; i++)
			trace("\t"+cplex.getValue(u[i]));
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\n"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(cplex.solve)
//	traceln("\nEND of solve_cplex_mtsp");
	//Convert from 'x[][]' matrix into 'solution_temp[]'		
		int[] solution_temp;
		for( int salesman=0 ; salesman<m ; salesman++){
			get_Main().salesmen.get( salesman ).route.clear();
			get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( 0 ) );	//salesmen.get( salesman ).route.add( salesmen.get( salesman ) );
			solution_temp = new int[n+1];
			for( int position = 0 ; position < n ; position++){
				for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
					if(solution_temp[position] != column_in_x){
						if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
							solution_temp[position+1] = column_in_x;
							break;
						}//if(x>0.0)
					}
				}//for(column_in_x)
				get_Main().salesmen.get( salesman ).route.add( get_Main().cities.get( solution_temp[position+1] ) );
				if( solution_temp[position+1]==0 )
					break;
			}//for(position)
		}//for(salesman)
	
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583404833</Id>
					<Name><![CDATA[solve_MTSPojalgo_2indices]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>30</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace("MTSPo");	else get_Main().csv_file.print("MTSPo");
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	//traceln();
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		if(city_i != city_j)
			d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
/*		else
			d[city_i][city_j] = 0;	//Double.MAX_VALUE;
	*/	//trace("c["+city_i+"]["+city_j+"]="+d[city_i][city_j]+";\t");
		
	}
}
//traceln();

final ExpressionsBasedModel model = new ExpressionsBasedModel();
//DECISION VARIABLES
// x
final Variable[][] x = new Variable[n][n];
for(int i=0 ; i<n ; i++){
	for(int j=0 ; j<n ; j++)
		if(i!=j){
			x[i][j] = Variable.make("x"+i+"_"+j).binary().weight(d[i][j]);
			model.addVariable(x[i][j]);
		}
}
//u
final Variable[] u = new Variable[n];
for(int i=1 ; i<n ; i++){
	u[i] = new Variable("u"+i);
	model.addVariable(u[i]);
}

// CONSTRAINT 1: for the depot, as many entering paths as salesmen
// sum(i in cities: i>=1) x[i][0]==m;
final Expression constraint_flowInDepot = model.addExpression("constraint_flowInDepot").lower(m).upper(m);
for( int i=1 ; i<n ; i++)
	constraint_flowInDepot.setLinearFactor( x[i][0], 1);
// CONSTRAINT 1bis: for each node j, only one entering path
// FORALL j, SUM_i(i<>j) x[i][j] = 1
for(int j=1 ; j<n ; j++){
	final Expression constraint_flowIn = model.addExpression("constraint_flowIn"+j).lower(1).upper(1);
	for(int i=0 ; i<n ; i++)
		if(i!=j)
			constraint_flowIn.setLinearFactor(x[i][j], 1);
}//for(j)

// CONSTRAINT 2: for the depot, as many leaving paths as salesmen
// sum(j in cities: j>=1) x[0][j]==m;
final Expression constraint_flowOutDepot = model.addExpression("constraint_flowOutDepot").lower(m).upper(m);
for( int j=1 ; j<n ; j++)
	constraint_flowOutDepot.setLinearFactor( x[0][j], 1);
// CONSTRAINT 2bis: for each node i, only one entering path
// FORALL i, SUM_j(i<>j) x[i][j] = 1
for(int i=1 ; i<n ; i++){
	final Expression constraint_flowOut = model.addExpression("constraint_flowOut"+i).lower(1).upper(1);
	for(int j=0 ; j<n ; j++)
		if(j!=i)
			constraint_flowOut.setLinearFactor(x[i][j], 1);
}//for(i)

// CONSTRAINT 3: subroute elimination
// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-2
for(int i=1 ; i<n ; i++){
	for( int j=1 ; j<n ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n-2);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n-1);
		}
	}
}


/*for(int i=1 ; i<n ; i++){
	for( int j=1 ; j<n ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n-2);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n-1);
		}
	}
}*/

long computationStartTime = System.currentTimeMillis() ;
Optimisation.Result result = model.minimise();
get_Main().computationTimeOfFunctionSolveOfCentralPlanner += System.currentTimeMillis() - computationStartTime;

model.options.debug(LinearSolver.class);

traceln("\nRESULT "+result);

/*traceln("\n res = " + result);
trace("\n\t  ");
for(int i=1 ; i<n ; i++)	trace(u[i].getValue().intValue()+" ");
trace("\n\t");
for(int i=0 ; i<n ; i++)	trace(i+" ");
traceln();
for(int i=0 ; i<n ; i++){
	trace(i+"\t");
	for(int j=0 ; j<n ; j++){
		trace(x[i][j].getValue().intValue() + " ");
	}
	traceln();
}*/

int truckNb = 0;	//ojalgo may need less trucks than 'trucks.size()' or 'truckNumber'
for(int source=1; source<n ; source++)
	if( x[source][0].getValue().doubleValue() > .9 )
		truckNb++;
//traceln("CPLEX finds " + truckNb+" routes.");
	
ArrayList tempRoutes = new ArrayList();
for(int truck=0; truck < truckNb ; truck++){
	ArrayList tempRoute = new ArrayList();
	tempRoutes.add( tempRoute );
}//for(truck)

//Convert 'x[][]' matrix into 'route' ArrayLists
int destinationInFirstRow = 0;
for(int foundRoute = 0 ; foundRoute < truckNb ; foundRoute++){
	int source = 0 ;
	do{ //this 'do' loop goes from one city to the next in x[][]
		for( int destination = 0 ; destination < n ; destination++){ //this 'for' loop scan a line in x[][] until the 'routeIndex'th value '1', the corresponding column is the next client 
			if( source != destination ){
				//if( cplex.getValue( x[source][destination] ) > .9 ){
				if( x[source][destination].getValue().doubleValue() > .9 ){
				//if( x[ solution_temp[position] ][ column_in_x ].getValue().doubleValue()  > 0.9){
					if(source >0){
						source = destination;
						break;
					}else if(destination > destinationInFirstRow){
						source = destination;
						destinationInFirstRow = destination;
						break;
					}
				}
			}
		}
		((ArrayList)( tempRoutes.get(foundRoute)) ).add(get_Main().cities.get(source));
	}while( source != 0 ); //'while' until the return to the depot (client zero)
}//fin for(truck)
		
/*for(Object route : routes){
	trace(route+" ");
	for(Object client : (ArrayList)route)
		trace( ((City)client).getIndex() + " ");
	trace("\n");
}*/
		
for(Salesman salesman : get_Main().salesmen){
	salesman.route.clear();
	//salesman.route.add(salesman);
	salesman.route.add(get_Main().cities.get(0));
	salesman.route.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
	//salesman.citiesOwned.clear();
	//salesman.citiesOwned.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
	salesman.allocatedCities.clear();
	salesman.allocatedCities.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
}//for(salesman)]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583583161</Id>
					<Name><![CDATA[solve_DMTSPojalgo]]></Name>
					<Description><![CDATA[Adaptation from TSP to mTSP, where TSP is:
CPLEX & Java 4. Travelling salesman problem
Hernán Cáceres
https://www.youtube.com/watch?v=QzOLL2tUXKE

import ilog.concert.*;	//These 2 imports need to be included in the "imports section"
import ilog.cplex.*; 		//of the "Advanced java" of the properties of this Truck agent
System.out.println(System.getProperty("java.library.path"));

Comment attribuer chaque route à chaque truck:
- hasard ???
- la route la + courte est attribuée au truck apportant le + de cities (à l'ensemble des trucks)
- la route la + courte est attribuée au truck qui a le + de cities dans cette route
- chaque truck peut décider ou non de mettre une city dans le pot commun et de se garder les autres
- + décentralisé : un marché où les salesmen misent pour avoir les cities les + proches (avec la valeur de Shapley: valeur city=CPLEX avec city - CPLEX sans city) -> mais pourquoi les salesmen voudraient-ils maximiser le nombre de cities?
]]></Description>
					<X>421</X><Y>181</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if(get_Main().consoleOutput)	trace("DMTSPo");	else get_Main().csv_file.print("DMTSPo");
int m = get_Main().salesmen.size();
int n = get_Main().cities.size();
double[][] d = new double[n][n];
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = get_Main().cities.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){
		City city_J = get_Main().cities.get(city_j);
		if(city_i != city_j)
			d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
		else
			d[city_i][city_j] = Double.MAX_VALUE;
	}
}

final ExpressionsBasedModel model = new ExpressionsBasedModel();
//DECISION VARIABLES
// x
final Variable[][] x = new Variable[n][n];
for(int i=0 ; i<n ; i++){
	for(int j=0 ; j<n ; j++){
		x[i][j] = Variable.make("x"+i+"_"+j).binary().weight(d[i][j]);
		model.addVariable(x[i][j]);
	}
}
//u
final Variable[] u = new Variable[n];
for(int i=1 ; i<n ; i++){
	u[i] = new Variable("u"+i);
	model.addVariable(u[i]);
}

// CONSTRAINT 1: for the depot, as many entering paths as salesmen
// sum(i in cities: i>=1) x[i][0]==m;
final Expression constraint_flowInDepot = model.addExpression("constraint_flowInDepot").lower(m).upper(m);
for( int i=1 ; i<n ; i++)
	constraint_flowInDepot.setLinearFactor( x[i][0], 1);
// CONSTRAINT 1bis: for each node j, only one entering path
// FORALL j, SUM_i(i<>j) x[i][j] = 1
for(int j=1 ; j<n ; j++){
	final Expression constraint_flowIn = model.addExpression("constraint_flowIn"+j).lower(1).upper(1);
	for(int i=0 ; i<n ; i++)
		if(i!=j)
			constraint_flowIn.setLinearFactor(x[i][j], 1);
}//for(j)

// CONSTRAINT 2: for the depot, as many leaving paths as salesmen
// sum(j in cities: j>=1) x[0][j]==m;
final Expression constraint_flowOutDepot = model.addExpression("constraint_flowOutDepot").lower(m).upper(m);
for( int j=1 ; j<n ; j++)
	constraint_flowOutDepot.setLinearFactor( x[0][j], 1);
// CONSTRAINT 2bis: for each node i, only one entering path
// FORALL i, SUM_j(i<>j) x[i][j] = 1
for(int i=1 ; i<n ; i++){
	final Expression constraint_flowOut = model.addExpression("constraint_flowOut"+i).lower(1).upper(1);
	for(int j=0 ; j<n ; j++)
		if(j!=i)
			constraint_flowOut.setLinearFactor(x[i][j], 1);
}//for(i)

// CONSTRAINT 3: subroute elimination
// FORALL i, FORALL j (i<>j), u[i] - u[j] + (n-1) x[i][j] <=  n-2
/*for(int i=1 ; i<n ; i++){
	for( int j=1 ; j<n ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n-2);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n-1);
		}
	}
}*/


for(int i=1 ; i<n ; i++){
	for( int j=1 ; j<n ; j++){
		if( i!=j ){
			final Expression constraint_subroute = model.addExpression("constraint_subroute"+i+"_"+j).upper(n-2);
			constraint_subroute.setLinearFactor(u[i],    1);
			constraint_subroute.setLinearFactor(u[j],   -1);
			constraint_subroute.setLinearFactor(x[i][j], n-1);
		}
	}
}

long computationStartTime = System.currentTimeMillis() ;
Optimisation.Result result = model.minimise();
get_Main().computationTimeOfFunctionSolveOfCentralPlanner += System.currentTimeMillis() - computationStartTime;

/*traceln("\n res = " + result);
trace("\n\t  ");
for(int i=1 ; i<n ; i++)	trace(u[i].getValue().intValue()+" ");
trace("\n\t");
for(int i=0 ; i<n ; i++)	trace(i+" ");
traceln();
for(int i=0 ; i<n ; i++){
	trace(i+"\t");
	for(int j=0 ; j<n ; j++){
		trace(x[i][j].getValue().intValue() + " ");
	}
	traceln();
}*/

int truckNb = 0;	//ojalgo may need less trucks than 'trucks.size()' or 'truckNumber'
for(int source=1; source<n ; source++)
	if( x[source][0].getValue().doubleValue() > .9 )
		truckNb++;
//traceln("CPLEX finds " + truckNb+" routes.");
	
ArrayList tempRoutes = new ArrayList();
for(int truck=0; truck < truckNb ; truck++){
	ArrayList tempRoute = new ArrayList();
	tempRoutes.add( tempRoute );
}//for(truck)

//Convert 'x[][]' matrix into 'route' ArrayLists
int destinationInFirstRow = 0;
for(int foundRoute = 0 ; foundRoute < truckNb ; foundRoute++){
	int source = 0 ;
	do{ //this 'do' loop goes from one city to the next in x[][]
		for( int destination = 0 ; destination < n ; destination++){ //this 'for' loop scan a line in x[][] until the 'routeIndex'th value '1', the corresponding column is the next client 
			if( source != destination ){
				//if( cplex.getValue( x[source][destination] ) > .9 ){
				if( x[source][destination].getValue().doubleValue() > .9 ){
				//if( x[ solution_temp[position] ][ column_in_x ].getValue().doubleValue()  > 0.9){
					if(source >0){
						source = destination;
						break;
					}else if(destination > destinationInFirstRow){
						source = destination;
						destinationInFirstRow = destination;
						break;
					}
				}
			}
		}
		((ArrayList)( tempRoutes.get(foundRoute)) ).add(get_Main().cities.get(source));
	}while( source != 0 ); //'while' until the return to the depot (client zero)
}//fin for(truck)
		
/*for(Object route : routes){
	trace(route+" ");
	for(Object client : (ArrayList)route)
		trace( ((City)client).getIndex() + " ");
	trace("\n");
}*/
		
for(Salesman salesman : get_Main().salesmen){
	salesman.route.clear();
	salesman.route.add(salesman);	//salesman.route.add(cities.get(0));
	salesman.route.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
	//salesman.citiesOwned.clear();
	//salesman.citiesOwned.addAll( ((ArrayList)routes.get( salesman.getIndex() )) );
	salesman.allocatedCities.clear();
	salesman.allocatedCities.addAll( ((ArrayList)tempRoutes.get( salesman.getIndex() )) );
}//for(salesman)]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[long]]></ReturnType>
					<Id>1484583665153</Id>
					<Name><![CDATA[solve_DMTSPWRcplex]]></Name>
					<X>422</X><Y>162</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[//former name: solve_cplex_5dmtsp_indRealloc
if(get_Main().consoleOutput)	trace("DMTSPWRc");	else get_Main().csv_file.print("DMTSPWRc");
IloCplex cplex;

// Get values from the simulation in order to inject them into CPLEX
int m = get_Main().salesmen.size();

ArrayList cities2visit = new ArrayList();
if(get_Main().salesmenShareDepot0)		cities2visit.add( get_Main().cities.get(0) );
for(Salesman salesman : get_Main().salesmen)
	for(City city : salesman.ownedCities)
		if( ! cities2visit.contains(city) )
			cities2visit.add( city );

int n = cities2visit.size();	//Index in CPLEX: 0='depot', 1..n='cities', n+m='position of salesmen'

double[][] d = new double[n+m][n+m]; //c[i][j] = distance between city/salesman i and city/salesman j
for(int city_i = 0; city_i < n ; city_i++){
	City city_I = (City)cities2visit.get(city_i);
	for(int city_j = 0; city_j < n ; city_j++){				//fill in the first n x n square in c
		City city_J = (City)cities2visit.get(city_j);
		d[city_i][city_j] = Math.sqrt( Math.pow(city_I.getX()-city_J.getX(), 2) + Math.pow(city_I.getY()-city_J.getY(), 2));
	}//for(city_j)
	for(int salesman_j=0 ; salesman_j<m ; salesman_j++){	//fill in both n x m rectangles in c
		Salesman salesman_J = get_Main().salesmen.get(salesman_j);
		d[city_i][n+salesman_j] = Math.sqrt( Math.pow(city_I.getX()-salesman_J.getX(), 2) + Math.pow(city_I.getY()-salesman_J.getY(), 2));
		d[n+salesman_j][city_i] = d[city_i][n+salesman_j];
	}//for(salesman_j)
}//for(city_i)
for(Salesman salesman_I: get_Main().salesmen){							//fill in the second m x m square in c
	for(Salesman salesman_J: get_Main().salesmen){						//THIS PART IS USELESS, ISN'T IT? (but this calculation is ignored in CPLEX computation time))
		d[n+salesman_I.getIndex()][n+salesman_J.getIndex()] = Math.sqrt( Math.pow(salesman_I.getX()-salesman_J.getX(), 2) + Math.pow(salesman_I.getY()-salesman_J.getY(), 2));
	}//for(salesman_J)
}//for(salesman_I)

if(get_Main().salesmenShareDepot0)
	for(int salesman=0 ; salesman<m ; salesman++)
		d[0][n+salesman] = 0;	//MTSP -ie, subroute elimination constraint 5- needs a cycle: this arc allows such a cycle for CPLEX (and constraint 11 forces to use it), but the simulator will not use this arc of the route
else
	traceln("TODO..."+1/0);
/*trace("\nc=\t");
for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n)+"\t");
traceln();
for(int i=0 ; i<n+m ; i++){
	if(i<n)	trace("C"+((City)cities2visit.get(i)).getIndex() +"\t");	else	trace("S"+ (i-n) +"\t");
	for(int j=0; j<n+m ; j++)
		trace( ( Math.round(c[i][j]*10)/10. ) +"\t");
	traceln();
}*/

int[][] o = new int[n][m];	//o[j][k]=1 means salesman k owns city j
for(Salesman salesman : get_Main().salesmen)
	for(City city : salesman.ownedCities)
		o[ cities2visit.indexOf(city) ][salesman.getIndex()] = 1;	//Java seems to put zeroes elsewhere by default

int[] maxRealloc = new int[m];
for(int salesman=0 ; salesman<m ; salesman++)
	maxRealloc[ salesman ] = get_Main().salesmen.get( salesman ).maxReallocations;
long computationTime = -1;

try {
	cplex = new IloCplex();

	// VARIABLES
	IloNumVar[][][] x = new IloNumVar[n+m][n+m][];
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			x[i][j] = cplex.boolVarArray(m);
		}
	}//if(i)
	
	IloNumVar[] u = cplex.numVarArray(n+m, 0, Double.MAX_VALUE);
	
	IloNumVar[][] deltaPlus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		deltaPlus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] deltaMinus = new IloNumVar[n][];
	for(int i=0 ; i<n ; i++){
		deltaMinus[i] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	IloNumVar[][] a = new IloNumVar[n][];
	for(int j=0 ; j<n ; j++){
		a[j] = cplex.numVarArray(m, 0, Double.MAX_VALUE);
	}
	
	// OBJECTIVE
	IloLinearNumExpr obj = cplex.linearNumExpr();
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					obj.addTerm(d[i][j], x[i][j][k]);
			}//for(j)
		}//for(i)
	cplex.addMinimize(obj);
	
	// CONSTRAINTS
	// constraint 1 (lines 72-74 'flow_in' in 5MTSP-individualisedReallocation)
	// forall (j in cities: j>=1)
	//	 sum(i in cities: i!=j, k in salesmen) x[i][j][k]==1;
	for(int j=1 ; j<n+m ; j++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int i=0 ; i<n+m ; i++){
			if(i!=j)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(j)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(j)

	// constraint 2 (lines 76 in 5MTSP-individualisedReallocation)
	// sum(i in cities: i>=1, k in salesmen) x[i][0][k]<=m;
	IloLinearNumExpr flow_in_depot = cplex.linearNumExpr();
	for(int i=1 ; i<n+m ; i++){		
		for(int k=0 ; k<m ; k++){
			flow_in_depot.addTerm(1.0, x[i][0][k]);
		}//for(k)
	}//for(i)
	cplex.addLe(flow_in_depot, m);

	// constraint 3 (lines 78-80 in 5MTSP-individualisedReallocation)
	// forall (i in cities: i>=1)
	//	 sum(j in cities: j!=i, k in salesmen) x[i][j][k]==1;
	for(int i=1 ; i<n+m ; i++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n+m ; j++){
			if(j!=i)
				for(int k=0 ; k<m ; k++)
					expr.addTerm(1.0, x[i][j][k]);
		}//for(i)
		cplex.addEq(expr, 1); //all trucks leave the depot
	}//for(i)

	// constraint 4 (lines 82 in 5MTSP-individualisedReallocation)
	// sum(j in cities: j>=1, k in salesmen) x[0][j][k]<=m;
	IloLinearNumExpr flow_out_depot = cplex.linearNumExpr();
	for(int j=1 ; j<n+m ; j++){
		for(int k=0 ; k<m ; k++){
			flow_out_depot.addTerm(1.0, x[0][j][k]);
		}//for(k)
	}//for(j)
	cplex.addLe(flow_out_depot, m);

	// constraint 5 (lines 84-87 in 5MTSP-individualisedReallocation)
	// Subroute elimination by method of node potentials
	// 	forall (i in cities: i>=1, j in cities: j>=1, k in salesmen)
	//	 u[i]-u[j]+n*x[i][j][k] <= n-1;
	for(int i=1 ; i<n+m ; i++){
		for(int j=1 ; j<n+m ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	u[i]);
				expr.addTerm(-1.0,	u[j]);
				expr.addTerm(n,	x[i][j][k]);
				cplex.addLe(expr, n-1);
				}//if(k)
		}//for(j)
	}//for(i)

	// constraint 6bis (lines 88-90 'flow_in_if_affected' in 5MTSP-individualisedReallocation)
	// 	forall (i in cities, j in cities, k in salesmen)
	//	 x[i][j][k] <= a[j][k];
	for(int i=0 ; i<n+m ; i++){		//6
		for(int j=0 ; j<n ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				expr.addTerm(1.0,	x[i][j][k]);
				
				//cplex.addLe(expr,	o[j][k]);
				expr.addTerm(-1.0,	a[j][k]);
				cplex.addLe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 7 (lines 92-93 in 5MTSP-individualisedReallocation)
	// forall (i in cities, j in cities, k in salesmen)
	//	 (sum(l in cities: l!=j) x[j][l][k]) - x[i][j][k] >= 0;			//7
	for(int i=0 ; i<n+m ; i++){
		for(int j=0 ; j<n+m ; j++){
			for(int k=0 ; k<m ; k++){
				IloLinearNumExpr expr = cplex.linearNumExpr();
				for(int l=0 ; l<n+m ; l++){
					if(l!=j){
						expr.addTerm(1.0, x[j][l][k]);
					}
				}//for(l)
				expr.addTerm(-1.0,	x[i][j][k]);
				cplex.addGe(expr, 0);
			}//if(k)
		}//for(j)
	}//for(i)

	// constraint 8bis (lines 95-97 'maxChanges_of_allocations' in 5MTSP-individualisedReallocation)
	// forall (k in salesmen)
	//	 sum(j in cities) (dplus[j][k] + dminus[j][k]) <= maxReallocations[k];	//8bis
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		for(int j=0 ; j<n ; j++){
			expr.addTerm(1.0, deltaPlus[j][k]);
			expr.addTerm(1.0, deltaMinus[j][k]);
		}//for(j)
		cplex.addLe(expr, maxRealloc[k]);
	}//for(k)

	// constraint 9 (lines 99-100 in 5MTSP-individualisedReallocation)
	// forall(j in cities, k in salesmen)
	//	 dplus[j][k] - dminus[j][k] + a[j][k] == o[j][k];				//9
	for(int j=0 ; j<n ; j++){
		for(int k=0 ; k<m ; k++){
			IloLinearNumExpr expr = cplex.linearNumExpr();
			expr.addTerm(1.0, deltaPlus[j][k]);
			expr.addTerm(-1.0, deltaMinus[j][k]);
			expr.addTerm(1.0, a[j][k]);
			cplex.addEq(expr, o[j][k]);
		}//for(k)
	}//for(j)

	// constraint 10 (lines 102-103 in 5MTSP-individualisedReallocation)
	// forall(k1, k2 in salesmen: k1!=k2, j in cities)
	//	 dplus[j][k1] == dminus[j][k2];									//10
	for(int k1=0 ; k1<m ; k1++){
		for(int k2=0 ; k2<m ; k2++){
			if(k1!=k2){
				for(int j=0 ; j<n ; j++){
					IloLinearNumExpr expr = cplex.linearNumExpr();
					expr.addTerm(1.0, deltaPlus[j][k1]);
					expr.addTerm(-1.0, deltaMinus[j][k2]);
					cplex.addEq(expr, 0);
					//cplex.addEq(expr, dminus[j][k2]);
				}//for(j)
			}//if
		}//for(k2)
	}//for(k1)
	
	// Constraint 11: use the zero-distance arc between the depot and the inital position of the salemen
	for(int k=0 ; k<m ; k++){
		IloLinearNumExpr expr = cplex.linearNumExpr();
		expr.addTerm(1, x[0][n+k][k]);
		cplex.addEq(expr, 1);
	}

	// write model to file
	//cplex.exportModel("truck" + getIndex() + ".lp");
	cplex.setOut(null);
	if(get_Main().remainingComputationTime > 0){
		cplex.setParam( IloCplex.Param.TimeLimit, get_Main().remainingComputationTime/1000 ); //CPLEX uses second, not milliseconds
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.TimeLimit="+(get_Main().remainingComputationTime/1000));
	}
	else if(get_Main().remainingComputationTime == 0){
		cplex.setParam( IloCplex.Param.MIP.Limits.Solutions, 1 );
		if(get_Main().debugOutput)	System.err.println("IloCplex.Param.MIP.Limits.Solutions=1");
	}
	long computationEndTime = 0;
	long computationStartTime = System.currentTimeMillis();

	// Solve the model and display the solution if one was found
	if ( cplex.solve() ) {
		computationEndTime = System.currentTimeMillis();
		get_Main().computationTimeOfFunctionSolveOfCentralPlanner += computationEndTime - computationStartTime;
		if(get_Main().remainingComputationTime != -Double.MAX_VALUE){
			if( get_Main().remainingComputationTime - (computationEndTime - computationStartTime) >= 0)
				get_Main().remainingComputationTime -=(computationEndTime - computationStartTime);
			else
				get_Main().remainingComputationTime = 0;
		}
/*		traceln("\nRESULTS:");
		for(int k=0 ; k<m ; k++){
			trace("x SM"+k+"\t");
			for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
			for(int i=n ; i<n+m ; i++)	trace("S"+ (i-n) +"\t");
			traceln();
			for(int i=0 ; i<n+m ; i++){
				if(i<n)	trace("C"+((City)cities2visit.get(i)).getIndex() +"\t");	else	trace("S"+ (i-n) +"\t");
				for(int j=0 ; j<n+m ; j++)
					if(i!=j){
						if(cplex.getValue(x[i][j][k])>0.9)
							trace(Math.round(cplex.getValue(x[i][j][k])*100)/100+"\t");
						else
							trace("-\t");
					}
					else trace("-\t");
				traceln();
			}//for(j)
		}//for(k)
		trace("o|a\tC");
		for(int i=0 ; i<n ; i++)	trace("C"+((City)cities2visit.get(i)).getIndex()+"\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+o[j][k]+"|"+cplex.getValue(a[j][k]));
			}
		}//for(j)
		trace("\nu\t");
		for(int i=1 ; i<n+m ; i++)
			trace("\t"+Math.round(cplex.getValue(u[i])*100)/100);
		trace("\nd+[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dplus[j][k]));
			}
		}//for(j)
		trace("\nd-[][]\t");
		for(int k=0 ; k<m ; k++){
			trace("\nS"+k);
			for(int j=0 ; j<n ; j++){
				trace("\t"+cplex.getValue(dminus[j][k]));
			}
		}//for(j)
*/
	}//if(solutionFounde)
	//traceln("\nEND of solve_cplex_mtsp");

	//Convert from 'x[][]' matrix into 'solution_temp[]'		
	int[] solution_temp;
	for( int salesman=0 ; salesman<m ; salesman++){
		get_Main().salesmen.get( salesman ).route.clear();
		get_Main().salesmen.get( salesman ).route.add( get_Main().salesmen.get(salesman) );
		solution_temp = new int[n+1];
		solution_temp[0] = n+salesman;
		for( int position = 0 ; position < n ; position++){
			for(int column_in_x = 0 ; column_in_x < n ; column_in_x++){
				if(solution_temp[position] != column_in_x){
					if(cplex.getValue( x[ solution_temp[position] ][ column_in_x ][ salesman ] ) > 0.9){
						solution_temp[position+1] = column_in_x;
						break;
					}//if(x>0.0)
				}
			}//for(column_in_x)
			//salesmen.get( salesman ).route.add( (City)cities.get( cities2visitIndex[ solution_temp[position+1] ] ) );
			get_Main().salesmen.get( salesman ).route.add( (City)cities2visit.get( solution_temp[position+1] ));
			if( solution_temp[position+1]==0 )
				break;
		}//for(position)
	}//for(salesman)
cplex.end();
} catch (IloException e) {
	System.err.println("CPLEX: Concert exception ’" + e + "’ caught at initialisation.");
}]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1459942693467</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<StatechartReference>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[CentralAuthority]]></ClassName>
						<ItemName><![CDATA[Auction]]></ItemName>
					</StatechartReference>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-14774017</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>

			<ContainerLinks>
				<ContainerLink>
					<Id>1459942702665</Id>
					<Name><![CDATA[main]]></Name>
					<X>50</X><Y>-100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<ActiveObjectClass>
						<PackageName><![CDATA[tsp]]></PackageName>
						<ClassName><![CDATA[Main]]></ClassName>
					</ActiveObjectClass>
				</ContainerLink>
			</ContainerLinks>

			<Shapes>
				<Group>
					<Id>1459942693478</Id>
					<Name><![CDATA[person]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>-20</X><Y>20</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>

			<Shapes>
				<Curve ControlPoints="true">
					<Id>1459942693483</Id>
					<Name><![CDATA[shapeBody]]></Name>
					<X>-2</X><Y>-7</Y>
					<Label><X>-20</X><Y>28</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor/>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<FillColor>-16777216</FillColor>
					<FillMaterial>null</FillMaterial>
					<Points>
					   <Point><X>0</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>4</Y><Z>0</Z></Point>
					   <Point><X>3</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>-1</X><Y>3</Y><Z>0</Z></Point>
					   <Point><X>-2</X><Y>3</Y><Z>0</Z></Point>
					   <Point><X>-2</X><Y>10</Y><Z>0</Z></Point>
					   <Point><X>-2</X><Y>11</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>11</Y><Z>0</Z></Point>
					   <Point><X>-1</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>1</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>3</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>17</Y><Z>0</Z></Point>
					   <Point><X>5</X><Y>9</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>11</Y><Z>0</Z></Point>
					   <Point><X>6</X><Y>11</Y><Z>0</Z></Point>
					   <Point><X>6</X><Y>10</Y><Z>0</Z></Point>
					   <Point><X>6</X><Y>3</Y><Z>0</Z></Point>
					   <Point><X>5</X><Y>3</Y><Z>0</Z></Point>
					   <Point><X>1</X><Y>2</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>4</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>0</Y><Z>0</Z></Point>
					   <Point><X>4</X><Y>-3</Y><Z>0</Z></Point>
					   <Point><X>0</X><Y>-3</Y><Z>0</Z></Point>
					</Points>
					<Closed>true</Closed>
				</Curve>
			</Shapes>

				</Group>
			</Shapes>

		</ActiveObjectClass>
	</ActiveObjectClasses>	
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
			<ExportExcelFilePath><![CDATA[]]></ExportExcelFilePath>
		</ExportSettings>
	</Database>	
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1428929294899">
			<Id>1428929294910</Id>
			<Name><![CDATA[Simulation]]></Name>
			<Description><![CDATA[In "Advanced Java", change "Java machine arguments" to point to your CPLEX binaries, e.g.,:

* MAC:
-Djava.library.path=/Users/tmoyaux/Models/CPLEX_mac -enableassertions

* LINUX:
-Djava.library.path=/home/tmoyaux/Models/CPLEX_linux64/ -enableassertions

-Djava.library.path=/home/tmoyaux/Models/CPLEX_linux64/ -enableassertions -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8321

* WIN:
-Djava.library.path=E:\Models\CPLEX_win64 -enableassertions
-Djava.library.path=..\..\CPLEX_win64]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<Frame>
				<X>0</X>
				<Y>0</Y>
				<Width>1000</Width>
				<Height>800</Height>
				<Maximized>false</Maximized>
				<CloseConfirmation>false</CloseConfirmation>
			</Frame>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<InitialSetupCode><![CDATA[traceln("pbID\tinstnce\tMecha\t#SMen\t#cities\tcmpTimes\ttotCmpTime\troutLens\ttotRoutLen\tmaxRealloc\tmsgEx\ttotMsgEx\t#rounds");]]></InitialSetupCode>
			<MaximumMemory>4096</MaximumMemory>
			<RandomNumberGenerationType>randomSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>4</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[-Djava.library.path=/home/tmoyaux/Models/CPLEX_linux64/  -enableassertions]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>
			<SnapshotFile></SnapshotFile>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1432939923551</Id>
					<Name><![CDATA[number_of_salesmen]]></Name>
					<X>60</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[4]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1432940386540</Id>
					<Name><![CDATA[number_of_cities]]></Name>
					<X>60</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[30]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438096785519</Id>
					<Name><![CDATA[salesmen_start_from_their_depot]]></Name>
					<X>60</X><Y>435</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438179886553</Id>
					<Name><![CDATA[salesmen_share_a_unique_depot]]></Name>
					<X>60</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438344876081</Id>
					<Name><![CDATA[selected_solver]]></Name>
					<X>60</X><Y>365</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438345076831</Id>
					<Name><![CDATA[rectangle_width]]></Name>
					<X>60</X><Y>590</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[700]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438345210448</Id>
					<Name><![CDATA[rectangle_height]]></Name>
					<X>60</X><Y>630</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[700]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1438353773631</Id>
					<Name><![CDATA[solve_and_draw_automatically]]></Name>
					<X>60</X><Y>470</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1442407386060</Id>
					<Name><![CDATA[maxReallocations]]></Name>
					<X>60</X><Y>550</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[99]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1458838587895</Id>
					<Name><![CDATA[static_solver]]></Name>
					<X>60</X><Y>395</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1459241762031</Id>
					<Name><![CDATA[instance]]></Name>
					<X>60</X><Y>240</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1460120370221</Id>
					<Name><![CDATA[selected_allocation_mechanism]]></Name>
					<X>60</X><Y>302</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[0]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1469114110221</Id>
					<Name><![CDATA[debugOutput]]></Name>
					<X>60</X><Y>730</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1484585476112</Id>
					<Name><![CDATA[number_of_central_planners]]></Name>
					<X>60</X><Y>670</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[1]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1491568076999</Id>
					<Name><![CDATA[maximum_computation_time_span]]></Name>
					<Description><![CDATA[-Double.MAX_VALUE]]></Description>
					<X>60</X><Y>700</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[double]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[3600000*10]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1491911389287</Id>
					<Name><![CDATA[swap]]></Name>
					<X>60</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1516368961151</Id>
					<Name><![CDATA[problemID]]></Name>
					<X>60</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[int]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[2]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1519054811807</Id>
					<Name><![CDATA[consoleOutput]]></Name>
					<X>60</X><Y>760</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="false">
						<Type><![CDATA[boolean]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
			</Variables>

			<Shapes>
				<Text>
					<Id>1428929294911</Id>
					<Name><![CDATA[text]]></Name>
					<X>40</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[MTSP]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Shapes>
			<Controls>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1428929294912</Id>
					<Name><![CDATA[button]]></Name>
					<X>40</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<ActionCode><![CDATA[if ( getState() == IDLE )
	run();
getPresentation().setPresentable( getEngine().getRoot() );]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Run]]></LabelText>
						<LabelCode><![CDATA[getState() == IDLE ?
	"Run" :
	"Top level agent"]]></LabelCode>
					</ExtendedProperties>
				</Control>
				<Control Type="Slider">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1432939904160</Id>
					<Name><![CDATA[slider]]></Name>
					<X>249</X><Y>130</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="282" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<DefaultValueCode><![CDATA[0]]></DefaultValueCode>
						<Orientation>HORIZONTAL</Orientation>
						<MinValue><![CDATA[1]]></MinValue>
						<MaxValue><![CDATA[51]]></MaxValue>
						<LinkTo>true</LinkTo>
						<Link>number_of_salesmen</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438096713777</Id>
					<Name><![CDATA[salesmenStartFromDepot0_checkBox]]></Name>
					<X>260</X><Y>420</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<DefaultValueCode><![CDATA[false]]></DefaultValueCode>
						<LinkTo>true</LinkTo>
						<Link>salesmen_start_from_their_depot</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438179920062</Id>
					<Name><![CDATA[salesmenShareUniqueDepot_checkbox]]></Name>
					<X>260</X><Y>490</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>salesmen_share_a_unique_depot</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438344759059</Id>
					<Name><![CDATA[selectedTspSolverRadioButtons]]></Name>
					<X>260</X><Y>340</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="260" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[insertion]]></Button>
						<Button><![CDATA[cplex]]></Button>
						<Button><![CDATA[ojalgo]]></Button>
						<LinkTo>true</LinkTo>
						<Link>selected_solver</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438345044689</Id>
					<Name><![CDATA[rectangleWidth_editbox]]></Name>
					<X>260</X><Y>570</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LinkTo>true</LinkTo>
						<Link>rectangle_width</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438345210450</Id>
					<Name><![CDATA[rectangleWidth_editbox1]]></Name>
					<X>260</X><Y>610</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LinkTo>true</LinkTo>
						<Link>rectangle_height</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1438353814346</Id>
					<Name><![CDATA[solveAutomatically_checkbox]]></Name>
					<X>260</X><Y>450</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>solve_and_draw_automatically</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1445507219948</Id>
					<Name><![CDATA[maxReallocations_editbox]]></Name>
					<X>260</X><Y>530</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[0]]></MinValue>
						<LinkTo>true</LinkTo>
						<Link>maxReallocations</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1458848663033</Id>
					<Name><![CDATA[staticSolver_checkbox]]></Name>
					<X>260</X><Y>380</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>static_solver</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1459241776684</Id>
					<Name><![CDATA[city_deltaY_editbox]]></Name>
					<X>260</X><Y>220</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[0]]></MinValue>
						<MaxValue><![CDATA[130]]></MaxValue>
						<LinkTo>true</LinkTo>
						<Link>instance</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1460120462960</Id>
					<Name><![CDATA[selectedAllocationMechanismRadioButtons]]></Name>
					<X>260</X><Y>287</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="750" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[FullCentr]]></Button>
						<Button><![CDATA[OptDecentr]]></Button>
						<Button><![CDATA[-]]></Button>
						<Button><![CDATA[Cluster Rao]]></Button>
						<Button><![CDATA[Cluster Saglam]]></Button>
						<Button><![CDATA[Auction]]></Button>
						<Button><![CDATA[P2P]]></Button>
						<Button><![CDATA[CNP]]></Button>
						<Button><![CDATA[NoRealloc]]></Button>
						<LinkTo>true</LinkTo>
						<Link>selected_allocation_mechanism</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1469179270939</Id>
					<Name><![CDATA[debugOutput_checkbox]]></Name>
					<X>260</X><Y>720</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>debugOutput</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1484585493780</Id>
					<Name><![CDATA[centralPlannerNumber_editbox]]></Name>
					<X>260</X><Y>650</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[1]]></MinValue>
						<LinkTo>true</LinkTo>
						<Link>number_of_central_planners</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1491568102225</Id>
					<Name><![CDATA[maximumComputationTimeSpan_editbox1]]></Name>
					<X>260</X><Y>690</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[-Double.MAX_VALUE]]></MinValue>
						<MaxValue><![CDATA[Double.MAX_VALUE]]></MaxValue>
						<LinkTo>true</LinkTo>
						<Link>maximum_computation_time_span</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="CheckBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1491911405906</Id>
					<Name><![CDATA[swap_checkbox]]></Name>
					<X>260</X><Y>320</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="30" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[]]></LabelText>
						<LinkTo>true</LinkTo>
						<Link>swap</Link>
	 				</ExtendedProperties>
				</Control>
				<Control Type="RadioButtons">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1516369041051</Id>
					<Name><![CDATA[cityPositionRadioButtons]]></Name>
					<X>260</X><Y>250</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="770" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<Orientation>HORIZONTAL</Orientation>
						<Button><![CDATA[uniform]]></Button>
						<Button><![CDATA[normal]]></Button>
						<Button><![CDATA[CH130]]></Button>
						<Button><![CDATA[TS225]]></Button>
						<Button><![CDATA[TSP225]]></Button>
						<Button><![CDATA[A280]]></Button>
						<Button><![CDATA[PR299]]></Button>
						<Button><![CDATA[LIN318]]></Button>
						<Button><![CDATA[FL417]]></Button>
						<Button><![CDATA[GR431]]></Button>
						<Button><![CDATA[D493]]></Button>
						<LinkTo>true</LinkTo>
						<Link>problemID</Link>
					</ExtendedProperties>
				</Control>
				<Control Type="EditBox">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>1516380620907</Id>
					<Name><![CDATA[city_deltaY_editbox1]]></Name>
					<X>260</X><Y>180</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<MinValue><![CDATA[number_of_salesmen]]></MinValue>
						<MaxValue><![CDATA[493]]></MaxValue>
						<LinkTo>true</LinkTo>
						<Link>number_of_cities</Link>
					</ExtendedProperties>
				</Control>
			</Controls>

			<Parameters>			
				<Parameter>
					<ParameterName><![CDATA[instance]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[instance]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[selectedTspSolver]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[selected_solver]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[cityNumber]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[number_of_cities]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[salesmanNumber]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[number_of_salesmen]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[staticSolver]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[static_solver]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[salesmenShareDepot0]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[salesmen_share_a_unique_depot]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[salesmenStartFromTheirDepot]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[salesmen_start_from_their_depot]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[rectangleWidth]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[rectangle_width]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[rectangleHeight]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[rectangle_height]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[solveNdrawAutomatically]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[solve_and_draw_automatically]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[maxReallocations]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[maxReallocations]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[selectedAllocationMechanism]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[selected_allocation_mechanism]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[debugOutput]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[debugOutput]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[centralPlannerNumber]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[number_of_central_planners]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[maximumComputationTimeSpan]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[maximum_computation_time_span]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[swap]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[swap]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[problemID]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[problemID]]></Code>
					</ParameterValue>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[consoleOutput]]></ParameterName>
					<ParameterValue Class="CodeValue">
						<Code><![CDATA[consoleOutput]]></Code>
					</ParameterValue>
				</Parameter>
			</Parameters>			
			<PresentationProperties 
				EnableAdaptiveFrameManagement="true" 
				EnableAntiAliasing="true"
				EnableEnhancedModelElementsAnimation="true"
				EnablePanning="true"
				ToolbarCustomizableAtRuntime="true"
				EnableZoom="true">
				<ExecutionMode><![CDATA[realTimeScaled]]></ExecutionMode>
				<CpuRatio><![CDATA[ratio_1_2]]></CpuRatio>	        
				<Title><![CDATA[TSP : Simulation]]></Title>	
				<FramesPerSecond><![CDATA[20.0]]></FramesPerSecond>
				<RealTimeScale>1.0</RealTimeScale>
				<UIProperty Name="Experiment Progress" Value="false"/>
				<UIProperty Name="Simulation Progress" Value="true"/>
				<UIProperty Name="Statusbar Events Per Second" Value="false"/>
				<UIProperty Name="Statusbar Frames Per Second" Value="false"/>
				<UIProperty Name="Statusbar Memory" Value="true"/>
				<UIProperty Name="Statusbar Model Date" Value="true"/>
				<UIProperty Name="Statusbar Model Step" Value="false"/>
				<UIProperty Name="Statusbar Model Time" Value="true"/>
				<UIProperty Name="Statusbar Real Time Of Simulation" Value="false"/>
				<UIProperty Name="Statusbar Status" Value="true"/>
				<UIProperty Name="Toolbar Animation setup" Value="false"/>
				<UIProperty Name="Toolbar Execution control" Value="true"/>
				<UIProperty Name="Toolbar File" Value="false"/>
				<UIProperty Name="Toolbar Model navigation" Value="true"/>
				<UIProperty Name="Toolbar Time scale setup" Value="true"/>
				<UIProperty Name="Toolbar View" Value="false"/>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Never]]></StopOption>
				<InitialDate><![CDATA[1428883200000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1431475200000]]></FinalDate>	
				<FinalTime><![CDATA[100.0]]></FinalTime>	
			</ModelTimeProperties>
		</SimulationExperiment>
		<!--   =========  Parameter Variation Experiment   ========  -->
		<ParamVariationExperiment ActiveObjectClassId="1428929294899">
			<Id>1458853653788</Id>
			<Name><![CDATA[ParamVar]]></Name>
			<Description><![CDATA[maximumC- omputationTimeSpan_ini = 80 253 800 2530 8000 25300 80000
3600000*.5
3600000*20
-Double.MAX_VALUE

In "Advanced Java", change "Java machine arguments" to point to your CPLEX binaries, e.g.,:

* MAC:
-Djava.library.path=/Users/tmoyaux/Models/CPLEX_mac

* LINUX:
-Djava.library.path=/home/tmoyaux/Models/CPLEX_linux64/ -enableassertions

-Djava.library.path=/home/tmoyaux/Models/CPLEX_linux64/ -enableassertions -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8321

* WIN:
-Djava.library.path=E:\Models\CPLEX_win64 -enableassertions
-Djava.library.path=..\..\CPLEX_win64

Parameters:
- instance: 90+index%130
- selectedTspSolver: 1
- cityNumber: 46+(int)(index/130)
- salesmanNumber: 5
- staticSolver: true
- salesmenShareDepot0: true
- salesmenStartFromTheirDepot: true
- rectangleWidth: 700
- rectangleHeight: 700
- solveNdrawAutomaticcaly: false
- maxReallocations: 99
- consoleOutput: false
- centralPlannerNumber: 1
- maximumComputationTimeSpan: 3600000*.5
- swap: true
- problemID: 2]]></Description>
			<ClientAreaTopLeft><X>0</X><Y>0</Y></ClientAreaTopLeft>
			<PresentationTopGroupPersistent>true</PresentationTopGroupPersistent>
			<IconTopGroupPersistent>true</IconTopGroupPersistent>
			<Frame>
				<X>0</X>
				<Y>0</Y>
				<Width>1000</Width>
				<Height>600</Height>
				<Maximized>false</Maximized>
				<CloseConfirmation>false</CloseConfirmation>
			</Frame>
			<Import><![CDATA[import org.hsqldb.util.CSVWriter;]]></Import>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<MaximumMemory>4096</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>1</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[-Djava.library.path=..\..\CPLEX_win64]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>
			<SnapshotFile></SnapshotFile>

			<Shapes>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text]]></Name>
					<X>40</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[MTSP : ParamVar]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text1]]></Name>
					<X>50</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Iteration:]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text2]]></Name>
					<X>370</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format(getCurrentIteration())]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Line>
					<Id>0</Id>
					<Name><![CDATA[line]]></Name>
					<X>40</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<ZHeight>10</ZHeight>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineMaterial>null</LineMaterial>
					<LineStyle>SOLID</LineStyle>
					<BeginArrowSize>1</BeginArrowSize>
					<BeginArrowStyle>0</BeginArrowStyle>
					<EndArrowSize>1</EndArrowSize>
					<EndArrowStyle>0</EndArrowStyle>
					<Dx>240</Dx>
					<Dy>0</Dy>
					<Dz>0</Dz>
				</Line>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text3]]></Name>
					<X>50</X><Y>160</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Parameters]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text4]]></Name>
					<X>50</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[instance]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text5]]></Name>
					<X>370</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( instance )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text6]]></Name>
					<X>50</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[selectedTspSolver]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text7]]></Name>
					<X>370</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( selectedTspSolver )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text8]]></Name>
					<X>50</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[cityNumber]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text9]]></Name>
					<X>370</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( cityNumber )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text10]]></Name>
					<X>50</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[salesmanNumber]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text11]]></Name>
					<X>370</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( salesmanNumber )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text12]]></Name>
					<X>50</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[staticSolver]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text13]]></Name>
					<X>370</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( staticSolver )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text14]]></Name>
					<X>50</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[salesmenShareDepot0]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text15]]></Name>
					<X>370</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( salesmenShareDepot0 )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text16]]></Name>
					<X>50</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[salesmenStartFromTheirDepot]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text17]]></Name>
					<X>370</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( salesmenStartFromTheirDepot )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text18]]></Name>
					<X>50</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[rectangleWidth]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text19]]></Name>
					<X>370</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( rectangleWidth )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text20]]></Name>
					<X>50</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[rectangleHeight]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text21]]></Name>
					<X>370</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( rectangleHeight )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text22]]></Name>
					<X>50</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[solveNdrawAutomatically]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text23]]></Name>
					<X>370</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( solveNdrawAutomatically )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text24]]></Name>
					<X>50</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[maxReallocations]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text25]]></Name>
					<X>370</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( maxReallocations )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text26]]></Name>
					<X>50</X><Y>410</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[consoleOutput]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text27]]></Name>
					<X>370</X><Y>410</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( consoleOutput )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text28]]></Name>
					<X>50</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[selectedAllocationMechanism]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text29]]></Name>
					<X>370</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( selectedAllocationMechanism )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text30]]></Name>
					<X>50</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[debugOutput]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text31]]></Name>
					<X>370</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( debugOutput )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text32]]></Name>
					<X>50</X><Y>470</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[centralPlannerNumber]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text33]]></Name>
					<X>370</X><Y>470</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( centralPlannerNumber )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text34]]></Name>
					<X>50</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[maximumComputationTimeSpan_ini]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>0</Id>
					<Name><![CDATA[text35]]></Name>
					<X>370</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<VisibleCode><![CDATA[getCurrentIteration() > 0]]></VisibleCode>
					<AsObject>true</AsObject>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12042869</Color>
					<Text><![CDATA[?]]></Text>
					<TextCode><![CDATA[format( maximumComputationTimeSpan )]]></TextCode>
					<Font>
						<Name>SansSerif</Name>
						<Size>12</Size>
						<Style>0</Style>
					</Font>
					<Alignment>RIGHT</Alignment>
				</Text>
			</Shapes>
			<Controls>
				<Control Type="Button">
				 	<EmbeddedIcon>false</EmbeddedIcon>				
					<Id>0</Id>
					<Name><![CDATA[button]]></Name>
					<X>40</X><Y>80</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<BasicProperties Width="100" Height="30" 
				AsObject="true">
                        <EmbeddedIcon>false</EmbeddedIcon>				
						<FillColor/>
						<TextColor/>
						<Enabled>true</Enabled>
						<EnableExpression><![CDATA[getState() == IDLE]]></EnableExpression>
						<ActionCode><![CDATA[run();]]></ActionCode>
					</BasicProperties>
					<ExtendedProperties>
						<Font Name="Dialog" Size="11" Style="0"/>
						<LabelText><![CDATA[Run]]></LabelText>
					</ExtendedProperties>
				</Control>
			</Controls>

			<AllowParallelEvaluations>false</AllowParallelEvaluations>
			<UseFreeformParameters>true</UseFreeformParameters>
			<NumberOfRuns>999999</NumberOfRuns>
			<FreeformParamValue>	
				<Id>1432939692046</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[9]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1432939710079</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[109+(int)(index/130)]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438097066524</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438179992551</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438344938353</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438345000788</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438345018681</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1438353862912</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1442407514543</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[99]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1458831747464</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1459241670424</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[50+index%130]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1459959603899</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[false]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1460119249255</Id>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1469114079695</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[false]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1484585434335</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[1]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1491564485473</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[3600000*.5]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1491911458286</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[true]]></Code>
				</Expression>
			</FreeformParamValue>
			<FreeformParamValue>	
				<Id>1516371552155</Id>
				<Expression Class="CodeValue">
					<Code><![CDATA[2]]></Code>
				</Expression>
			</FreeformParamValue>
			<RangeVariationParamValue>	
				<Id>1432939692046</Id>
				<Type>FIXED</Type>
				<From Class="CodeValue">
					<Code><![CDATA[2]]></Code>
				</From>
				<To Class="CodeValue">
					<Code><![CDATA[5]]></Code>
				</To>
				<Step Class="CodeValue">
					<Code><![CDATA[1]]></Code>
				</Step>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1432939710079</Id>
				<Type>RANGE</Type>
				<From Class="CodeValue">
					<Code><![CDATA[5]]></Code>
				</From>
				<To Class="CodeValue">
					<Code><![CDATA[130]]></Code>
				</To>
				<Step Class="CodeValue">
					<Code><![CDATA[1]]></Code>
				</Step>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438097066524</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438179992551</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438344938353</Id>
				<Type>FIXED</Type>
				<From Class="CodeValue">
					<Code><![CDATA[0]]></Code>
				</From>
				<To Class="CodeValue">
					<Code><![CDATA[2]]></Code>
				</To>
				<Step Class="CodeValue">
					<Code><![CDATA[1]]></Code>
				</Step>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438345000788</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438345018681</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1438353862912</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1442407514543</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1458831747464</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1459241670424</Id>
				<Type>FIXED</Type>
				<From Class="CodeValue">
					<Code><![CDATA[5]]></Code>
				</From>
				<To Class="CodeValue">
					<Code><![CDATA[99]]></Code>
				</To>
				<Step Class="CodeValue">
					<Code><![CDATA[1]]></Code>
				</Step>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1459959603899</Id>
				<Type>FIXED</Type>
				<Expression Class="CodeValue">
					<Code><![CDATA[true]]></Code>
				</Expression>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1460119249255</Id>
				<Type>FIXED</Type>
				<Expression Class="CodeValue">
					<Code><![CDATA[6]]></Code>
				</Expression>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1469114079695</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1484585434335</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1491564485473</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1491911458286</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<RangeVariationParamValue>	
				<Id>1516371552155</Id>
				<Type>FIXED</Type>
			</RangeVariationParamValue>
			<ModelTimeProperties>
				<StopOption><![CDATA[Stop at specified time]]></StopOption>
				<InitialDate><![CDATA[1428883200000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1428886800000]]></FinalDate>	
				<FinalTime><![CDATA[1.0]]></FinalTime>	
			</ModelTimeProperties>
			<PresentationProperties 
				EnableAdaptiveFrameManagement="true" 
				EnableAntiAliasing="true"
				EnableEnhancedModelElementsAnimation="true"
				EnablePanning="true"
				ToolbarCustomizableAtRuntime="true"
				EnableZoom="true">
				<CpuRatio><![CDATA[ratio_1_2]]></CpuRatio>	        
				<Title><![CDATA[MTSP : ParamVar]]></Title>	
				<FramesPerSecond><![CDATA[20.0]]></FramesPerSecond>
				<UIProperty Name="Experiment Progress" Value="true"/>
				<UIProperty Name="Simulation Progress" Value="true"/>
				<UIProperty Name="Statusbar Events Per Second" Value="false"/>
				<UIProperty Name="Statusbar Frames Per Second" Value="false"/>
				<UIProperty Name="Statusbar Memory" Value="true"/>
				<UIProperty Name="Statusbar Real Time Of Simulation" Value="true"/>
				<UIProperty Name="Statusbar Status" Value="true"/>
				<UIProperty Name="Toolbar Animation setup" Value="false"/>
				<UIProperty Name="Toolbar Execution control" Value="true"/>
				<UIProperty Name="Toolbar File" Value="false"/>
				<UIProperty Name="Toolbar View" Value="false"/>
			</PresentationProperties>
			<ReplicationsProperties>
				<UseReplication>false</UseReplication>
				<FixedReplicationsNumber>true</FixedReplicationsNumber>
				<ReplicationPerIteration>130</ReplicationPerIteration>
				<MinimumReplication>2</MinimumReplication>
				<MaximumReplication>10</MaximumReplication>
				<ConfidenceLevel>LEVEL_80</ConfidenceLevel>
				<ErrorPercent>0.5</ErrorPercent>
				<ExpressionForConfidenceComputation><![CDATA[0]]></ExpressionForConfidenceComputation>
			</ReplicationsProperties>
		</ParamVariationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1460020086326</Id>
			<Name><![CDATA[P2P_offer_reply]]></Name>
			<Text><![CDATA[/**
 * Reply
 */	
public class P2P_offer_reply implements Serializable {

	public Salesman sender;

	public boolean accept;

    public P2P_offer_reply(boolean accept, Salesman sender) {
		this.accept = accept;
		this.sender = sender;
    }

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 456123461L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1460973548776</Id>
			<Name><![CDATA[P2P_offer_proposition]]></Name>
			<Text><![CDATA[/**
 * Proposition
 */	
public class P2P_offer_proposition implements Serializable {

	public Salesman sender;
	
	public City city;
	
	public double savingFromGivingThisCity;
	
	public P2P_offer_proposition(City city, double savingFromGivingThisCity, Salesman sender){
		this.sender						= sender;
		this.city						= city;
		this.savingFromGivingThisCity	= savingFromGivingThisCity;
	}
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 326548456L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1460994233539</Id>
			<Name><![CDATA[CNP_P2Pswap_nego_reply]]></Name>
			<Text><![CDATA[/**
 * Reply
 */	
public class CNP_P2Pswap_nego_reply implements Serializable {

	public Salesman sender;
	
	public City city;

	public double savingFromGivingThisCity;

	public CNP_P2Pswap_nego_reply(City city, double savingFromGivingThisCity, Salesman sender){
		this.city						= city;
		this.savingFromGivingThisCity	= savingFromGivingThisCity;
		this.sender						= sender;
	}

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 459423461L;
	
/*	protected void finalize( ) throws Throwable   {
		traceln(this+" gets DESTROYED!!!!!!!!");
		super.finalize();
	}*/
	

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1463563850417</Id>
			<Name><![CDATA[CNP_P2Pswap_nego_invitation]]></Name>
			<Text><![CDATA[/**
 * Invitation to enter negotiation protocol
 */	
public class CNP_P2Pswap_nego_invitation implements Serializable {

	public Salesman sender;
	
	public City city;


    public CNP_P2Pswap_nego_invitation(Salesman sender) {
		this.sender						= sender;
    }
    
    public CNP_P2Pswap_nego_invitation(City city, Salesman sender) {
    	this.city						=city;
		this.sender						= sender;
    }

	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 456493461L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1473088922954</Id>
			<Name><![CDATA[Message]]></Name>
			<Text><![CDATA[/**
 * Proposition
 */	
public class Message implements Serializable {

	public Agent sender;
	
	public Object content;
		
	public Message(){
		
	}
	
	public Message(Object content, Agent sender){
		this.content	= content;
		this.sender		= sender;
	}
	
	/**
	 * This number is here for model snapshot storing purpose<br>
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 324139456156L;

}]]></Text>
		</JavaClass>
	</JavaClasses>
	<ClassPathEntry>
		<Location><![CDATA[cplex.jar]]></Location>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
	<ClassPathEntry>
		<Location><![CDATA[ojalgo-40.0.0.jar]]></Location>
		<Imported>true</Imported>
		<Folder>false</Folder>
	</ClassPathEntry>
</Model>
</AnyLogicWorkspace>